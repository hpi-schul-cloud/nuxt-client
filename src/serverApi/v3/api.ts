/* tslint:disable */
/* eslint-disable */
/**
 * HPI Schul-Cloud Server API
 * This is v3 of HPI Schul-Cloud Server. Checkout /docs for v1.
 *
 * The version of the OpenAPI document: 3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	RequestArgs,
	BaseAPI,
	RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AccountByIdBodyParams
 */
export interface AccountByIdBodyParams {
	/**
	 * The new user name for the user.
	 * @type {string}
	 * @memberof AccountByIdBodyParams
	 */
	username?: string | null;
	/**
	 * The new password for the user.
	 * @type {string}
	 * @memberof AccountByIdBodyParams
	 */
	password?: string | null;
	/**
	 * The new activation state of the user.
	 * @type {boolean}
	 * @memberof AccountByIdBodyParams
	 */
	activated?: boolean | null;
}
/**
 *
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
	/**
	 *
	 * @type {string}
	 * @memberof AccountResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof AccountResponse
	 */
	username: string;
	/**
	 *
	 * @type {string}
	 * @memberof AccountResponse
	 */
	userId: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof AccountResponse
	 */
	activated: boolean;
}
/**
 *
 * @export
 * @interface AccountSearchListResponse
 */
export interface AccountSearchListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<AccountResponse>}
	 * @memberof AccountSearchListResponse
	 */
	data: Array<AccountResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof AccountSearchListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof AccountSearchListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof AccountSearchListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface ApiValidationError
 */
export interface ApiValidationError {
	/**
	 * The response status code.
	 * @type {number}
	 * @memberof ApiValidationError
	 */
	code: number;
	/**
	 * The error type.
	 * @type {string}
	 * @memberof ApiValidationError
	 */
	type: string;
	/**
	 * The error title.
	 * @type {string}
	 * @memberof ApiValidationError
	 */
	title: string;
	/**
	 * The error message.
	 * @type {string}
	 * @memberof ApiValidationError
	 */
	message: string;
	/**
	 * The error details.
	 * @type {object}
	 * @memberof ApiValidationError
	 */
	details?: object;
}
/**
 *
 * @export
 * @interface BasicToolConfigParams
 */
export interface BasicToolConfigParams {
	/**
	 *
	 * @type {string}
	 * @memberof BasicToolConfigParams
	 */
	type: string;
	/**
	 *
	 * @type {string}
	 * @memberof BasicToolConfigParams
	 */
	baseUrl: string;
}
/**
 *
 * @export
 * @interface BoardContextResponse
 */
export interface BoardContextResponse {
	/**
	 *
	 * @type {string}
	 * @memberof BoardContextResponse
	 */
	id: string;
	/**
	 *
	 * @type {BoardExternalReferenceType}
	 * @memberof BoardContextResponse
	 */
	type: BoardExternalReferenceType;
}
/**
 *
 * @export
 * @interface BoardElementResponse
 */
export interface BoardElementResponse {
	/**
	 * the type of the element in the content. For possible types, please refer to the enum
	 * @type {string}
	 * @memberof BoardElementResponse
	 */
	type: BoardElementResponseTypeEnum;
	/**
	 * Content of the Board, either: a task or a lesson specific for the board
	 * @type {object}
	 * @memberof BoardElementResponse
	 */
	content: object;
}

/**
 * @export
 * @enum {string}
 */
export enum BoardElementResponseTypeEnum {
	Task = "task",
	Lesson = "lesson",
	ColumnBoard = "column-board",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum BoardExternalReferenceType {
	Course = "course",
}

/**
 *
 * @export
 * @interface BoardResponse
 */
export interface BoardResponse {
	/**
	 *
	 * @type {string}
	 * @memberof BoardResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BoardResponse
	 */
	title: string;
	/**
	 *
	 * @type {Array<ColumnResponse>}
	 * @memberof BoardResponse
	 */
	columns: Array<ColumnResponse>;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof BoardResponse
	 */
	timestamps: TimestampsResponse;
}
/**
 *
 * @export
 * @interface CardElementParams
 */
export interface CardElementParams {
	/**
	 *
	 * @type {string}
	 * @memberof CardElementParams
	 */
	id?: string;
	/**
	 * Content of the card element, depending on its type
	 * @type {RichTextCardElementParam}
	 * @memberof CardElementParams
	 */
	content: RichTextCardElementParam;
}
/**
 *
 * @export
 * @interface CardElementResponse
 */
export interface CardElementResponse {
	/**
	 * The id of the card element
	 * @type {string}
	 * @memberof CardElementResponse
	 */
	id: string;
	/**
	 * Type of card element
	 * @type {string}
	 * @memberof CardElementResponse
	 */
	cardElementType: CardElementResponseCardElementTypeEnum;
	/**
	 * Content of the card element, depending on its type
	 * @type {CardRichTextElementResponse}
	 * @memberof CardElementResponse
	 */
	content: CardRichTextElementResponse;
}

/**
 * @export
 * @enum {string}
 */
export enum CardElementResponseCardElementTypeEnum {
	RichText = "richText",
}

/**
 *
 * @export
 * @interface CardListResponse
 */
export interface CardListResponse {
	/**
	 *
	 * @type {Array<CardResponse>}
	 * @memberof CardListResponse
	 */
	data: Array<CardResponse>;
}
/**
 *
 * @export
 * @interface CardResponse
 */
export interface CardResponse {
	/**
	 *
	 * @type {string}
	 * @memberof CardResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof CardResponse
	 */
	title?: string;
	/**
	 *
	 * @type {number}
	 * @memberof CardResponse
	 */
	height: number;
	/**
	 *
	 * @type {Array<RichTextElementResponse>}
	 * @memberof CardResponse
	 */
	elements: Array<RichTextElementResponse>;
	/**
	 *
	 * @type {VisibilitySettingsResponse}
	 * @memberof CardResponse
	 */
	visibilitySettings: VisibilitySettingsResponse;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof CardResponse
	 */
	timestamps: TimestampsResponse;
}
/**
 *
 * @export
 * @interface CardRichTextElementResponse
 */
export interface CardRichTextElementResponse {
	/**
	 * The value of the rich text card element
	 * @type {string}
	 * @memberof CardRichTextElementResponse
	 */
	value: string;
	/**
	 * The input format type of the rich text content
	 * @type {string}
	 * @memberof CardRichTextElementResponse
	 */
	inputFormat: CardRichTextElementResponseInputFormatEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum CardRichTextElementResponseInputFormatEnum {
	PlainText = "plainText",
	RichText = "richText",
	Inline = "inline",
	RichTextCk4 = "richTextCk4",
	RichTextCk5 = "richTextCk5",
	RichTextCk5Inline = "richTextCk5Inline",
}

/**
 *
 * @export
 * @interface CardSkeletonResponse
 */
export interface CardSkeletonResponse {
	/**
	 *
	 * @type {string}
	 * @memberof CardSkeletonResponse
	 */
	cardId: string;
	/**
	 * The approximate height of the referenced card. Intended to be used for prerendering purposes. Note, that different devices can lead to this value not being precise
	 * @type {number}
	 * @memberof CardSkeletonResponse
	 */
	height: number;
}
/**
 *
 * @export
 * @interface ChangeLanguageParams
 */
export interface ChangeLanguageParams {
	/**
	 *
	 * @type {string}
	 * @memberof ChangeLanguageParams
	 */
	language: ChangeLanguageParamsLanguageEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ChangeLanguageParamsLanguageEnum {
	De = "de",
	En = "en",
	Es = "es",
	Uk = "uk",
}

/**
 *
 * @export
 * @interface ColumnResponse
 */
export interface ColumnResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ColumnResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ColumnResponse
	 */
	title: string;
	/**
	 *
	 * @type {Array<CardSkeletonResponse>}
	 * @memberof ColumnResponse
	 */
	cards: Array<CardSkeletonResponse>;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof ColumnResponse
	 */
	timestamps: TimestampsResponse;
}
/**
 *
 * @export
 * @interface ConsentRequestBody
 */
export interface ConsentRequestBody {
	/**
	 * The error should follow the OAuth2 error format (e.g. invalid_request, login_required). Defaults to request_denied.
	 * @type {string}
	 * @memberof ConsentRequestBody
	 */
	error?: string;
	/**
	 * Debug contains information to help resolve the problem as a developer. Usually not exposed to the public but only in the server logs.
	 * @type {string}
	 * @memberof ConsentRequestBody
	 */
	error_debug?: string;
	/**
	 * Description of the error in a human readable format.
	 * @type {string}
	 * @memberof ConsentRequestBody
	 */
	error_description?: string;
	/**
	 * Hint to help resolve the error.
	 * @type {string}
	 * @memberof ConsentRequestBody
	 */
	error_hint?: string;
	/**
	 * Represents the HTTP status code of the error (e.g. 401 or 403). Defaults to 400.
	 * @type {number}
	 * @memberof ConsentRequestBody
	 */
	status_code?: number;
	/**
	 * The Oauth2 client id.
	 * @type {Array<string>}
	 * @memberof ConsentRequestBody
	 */
	grant_scope?: Array<string>;
	/**
	 * Remember, if set to true, tells the oauth provider to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope.
	 * @type {boolean}
	 * @memberof ConsentRequestBody
	 */
	remember?: boolean;
	/**
	 * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely.
	 * @type {number}
	 * @memberof ConsentRequestBody
	 */
	remember_for?: number;
}
/**
 *
 * @export
 * @interface ConsentResponse
 */
export interface ConsentResponse {
	/**
	 * ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session
	 * @type {string}
	 * @memberof ConsentResponse
	 */
	acr: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ConsentResponse
	 */
	amr?: Array<string>;
	/**
	 * Is the id/authorization challenge of the consent authorization request. It is used to identify the session.
	 * @type {object}
	 * @memberof ConsentResponse
	 */
	challenge: object;
	/**
	 *
	 * @type {OauthClientResponse}
	 * @memberof ConsentResponse
	 */
	client: OauthClientResponse;
	/**
	 *
	 * @type {object}
	 * @memberof ConsentResponse
	 */
	context: object;
	/**
	 * LoginChallenge is the login challenge this consent challenge belongs to.
	 * @type {string}
	 * @memberof ConsentResponse
	 */
	login_challenge: string;
	/**
	 * LoginSessionID is the login session ID.
	 * @type {string}
	 * @memberof ConsentResponse
	 */
	login_session_id: string;
	/**
	 *
	 * @type {OidcContextResponse}
	 * @memberof ConsentResponse
	 */
	oidc_context: OidcContextResponse;
	/**
	 * RequestUrl is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client.
	 * @type {string}
	 * @memberof ConsentResponse
	 */
	request_url: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ConsentResponse
	 */
	requested_access_token_audience?: Array<string>;
	/**
	 * The request scopes of the login request.
	 * @type {Array<string>}
	 * @memberof ConsentResponse
	 */
	requested_scope?: Array<string>;
	/**
	 * Skip, if true, implies that the client has requested the same scopes from the same user previously.
	 * @type {boolean}
	 * @memberof ConsentResponse
	 */
	skip: boolean;
	/**
	 * Subject is the user id of the end-user that is authenticated.
	 * @type {string}
	 * @memberof ConsentResponse
	 */
	subject: string;
}
/**
 *
 * @export
 * @interface ConsentSessionResponse
 */
export interface ConsentSessionResponse {
	/**
	 * The id of the client.
	 * @type {string}
	 * @memberof ConsentSessionResponse
	 */
	client_id: string;
	/**
	 * The name of the client.
	 * @type {string}
	 * @memberof ConsentSessionResponse
	 */
	client_name: string;
	/**
	 * The id/challenge of the consent authorization request.
	 * @type {string}
	 * @memberof ConsentSessionResponse
	 */
	challenge: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum ContentElementType {
	File = "file",
	RichText = "richText",
	SubmissionContainer = "submissionContainer",
}

/**
 *
 * @export
 * @interface ContextExternalToolPostParams
 */
export interface ContextExternalToolPostParams {
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolPostParams
	 */
	schoolToolId: string;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolPostParams
	 */
	contextId: string;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolPostParams
	 */
	contextType: string;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolPostParams
	 */
	displayName?: string;
	/**
	 *
	 * @type {Array<CustomParameterEntryParam>}
	 * @memberof ContextExternalToolPostParams
	 */
	parameters?: Array<CustomParameterEntryParam>;
	/**
	 *
	 * @type {number}
	 * @memberof ContextExternalToolPostParams
	 */
	toolVersion: number;
}
/**
 *
 * @export
 * @interface ContextExternalToolResponse
 */
export interface ContextExternalToolResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolResponse
	 */
	schoolToolId: string;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolResponse
	 */
	contextId: string;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolResponse
	 */
	contextType: ContextExternalToolResponseContextTypeEnum;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolResponse
	 */
	displayName?: string;
	/**
	 *
	 * @type {Array<CustomParameterEntryResponse>}
	 * @memberof ContextExternalToolResponse
	 */
	parameters: Array<CustomParameterEntryResponse>;
	/**
	 *
	 * @type {number}
	 * @memberof ContextExternalToolResponse
	 */
	toolVersion: number;
	/**
	 *
	 * @type {string}
	 * @memberof ContextExternalToolResponse
	 */
	logoUrl?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ContextExternalToolResponseContextTypeEnum {
	Course = "course",
}

/**
 *
 * @export
 * @interface ContextExternalToolSearchListResponse
 */
export interface ContextExternalToolSearchListResponse {
	/**
	 *
	 * @type {Array<ContextExternalToolResponse>}
	 * @memberof ContextExternalToolSearchListResponse
	 */
	data: Array<ContextExternalToolResponse>;
}
/**
 *
 * @export
 * @interface CopyApiResponse
 */
export interface CopyApiResponse {
	/**
	 * Id of copied element
	 * @type {string}
	 * @memberof CopyApiResponse
	 */
	id?: string;
	/**
	 * Title of copied element
	 * @type {string}
	 * @memberof CopyApiResponse
	 */
	title?: string;
	/**
	 * Type of copied element
	 * @type {string}
	 * @memberof CopyApiResponse
	 */
	type: CopyApiResponseTypeEnum;
	/**
	 * Id of destination course
	 * @type {string}
	 * @memberof CopyApiResponse
	 */
	destinationCourseId?: string;
	/**
	 * Copy progress status of copied element
	 * @type {string}
	 * @memberof CopyApiResponse
	 */
	status: CopyApiResponseStatusEnum;
	/**
	 * List of included sub elements with recursive type structure
	 * @type {Array<CopyApiResponse>}
	 * @memberof CopyApiResponse
	 */
	elements?: Array<CopyApiResponse>;
}

/**
 * @export
 * @enum {string}
 */
export enum CopyApiResponseTypeEnum {
	Board = "BOARD",
	Content = "CONTENT",
	Course = "COURSE",
	CoursegroupGroup = "COURSEGROUP_GROUP",
	File = "FILE",
	FileGroup = "FILE_GROUP",
	Leaf = "LEAF",
	Lesson = "LESSON",
	LessonContentEtherpad = "LESSON_CONTENT_ETHERPAD",
	LessonContentGeogebra = "LESSON_CONTENT_GEOGEBRA",
	LessonContentGroup = "LESSON_CONTENT_GROUP",
	LessonContentLernstore = "LESSON_CONTENT_LERNSTORE",
	LessonContentNexboard = "LESSON_CONTENT_NEXBOARD",
	LessonContentTask = "LESSON_CONTENT_TASK",
	LessonContentText = "LESSON_CONTENT_TEXT",
	LernstoreMaterial = "LERNSTORE_MATERIAL",
	LernstoreMaterialGroup = "LERNSTORE_MATERIAL_GROUP",
	LtitoolGroup = "LTITOOL_GROUP",
	Metadata = "METADATA",
	SubmissionGroup = "SUBMISSION_GROUP",
	Task = "TASK",
	TaskGroup = "TASK_GROUP",
	TimeGroup = "TIME_GROUP",
	UserGroup = "USER_GROUP",
}
/**
 * @export
 * @enum {string}
 */
export enum CopyApiResponseStatusEnum {
	Success = "success",
	Failure = "failure",
	NotDoing = "not-doing",
	NotImplemented = "not-implemented",
	Partial = "partial",
}

/**
 *
 * @export
 * @interface CourseMetadataListResponse
 */
export interface CourseMetadataListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<CourseMetadataResponse>}
	 * @memberof CourseMetadataListResponse
	 */
	data: Array<CourseMetadataResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof CourseMetadataListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof CourseMetadataListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof CourseMetadataListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface CourseMetadataResponse
 */
export interface CourseMetadataResponse {
	/**
	 * The id of the Grid element
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	id: string;
	/**
	 * Title of the Grid element
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	title: string;
	/**
	 * Short title of the Grid element
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	shortTitle: string;
	/**
	 * Color of the Grid element
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	displayColor: string;
	/**
	 * Start date of the course
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	startDate?: string;
	/**
	 * End date of the course. After this the course counts as archived
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	untilDate?: string;
	/**
	 * Start of the copying process if it is still ongoing - otherwise property is not set.
	 * @type {string}
	 * @memberof CourseMetadataResponse
	 */
	copyingSince?: string;
}
/**
 *
 * @export
 * @interface CourseResponse
 */
export interface CourseResponse {
	/**
	 * The id of the Grid element
	 * @type {string}
	 * @memberof CourseResponse
	 */
	id: string;
	/**
	 * Title of the Grid element
	 * @type {string}
	 * @memberof CourseResponse
	 */
	title: string;
	/**
	 * Start date of the course
	 * @type {string}
	 * @memberof CourseResponse
	 */
	startDate?: string;
	/**
	 * End date of the course. After this the course counts as archived
	 * @type {string}
	 * @memberof CourseResponse
	 */
	untilDate?: string;
	/**
	 * List of students enrolled in course
	 * @type {Array<UsersList>}
	 * @memberof CourseResponse
	 */
	students?: Array<UsersList>;
}
/**
 *
 * @export
 * @interface CreateCardBodyParams
 */
export interface CreateCardBodyParams {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof CreateCardBodyParams
	 */
	requiredEmptyElements?: Array<CreateCardBodyParamsRequiredEmptyElementsEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum CreateCardBodyParamsRequiredEmptyElementsEnum {
	File = "file",
	RichText = "richText",
	SubmissionContainer = "submissionContainer",
}

/**
 *
 * @export
 * @interface CreateContentElementBodyParams
 */
export interface CreateContentElementBodyParams {
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof CreateContentElementBodyParams
	 */
	type: ContentElementType;
	/**
	 * to bring element to a specific position, default is last position
	 * @type {number}
	 * @memberof CreateContentElementBodyParams
	 */
	toPosition?: number;
}
/**
 *
 * @export
 * @interface CreateNewsParams
 */
export interface CreateNewsParams {
	/**
	 * Title of the News entity
	 * @type {string}
	 * @memberof CreateNewsParams
	 */
	title: string;
	/**
	 * Content of the News entity
	 * @type {string}
	 * @memberof CreateNewsParams
	 */
	content: string;
	/**
	 * The point in time from when the News entity schould be displayed. Defaults to now so that the news is published
	 * @type {string}
	 * @memberof CreateNewsParams
	 */
	displayAt?: string;
	/**
	 * Target model to which the News entity is related
	 * @type {string}
	 * @memberof CreateNewsParams
	 */
	targetModel: CreateNewsParamsTargetModelEnum;
	/**
	 * Specific target id to which the News entity is related
	 * @type {string}
	 * @memberof CreateNewsParams
	 */
	targetId: string;
}

/**
 * @export
 * @enum {string}
 */
export enum CreateNewsParamsTargetModelEnum {
	Schools = "schools",
	Courses = "courses",
	Teams = "teams",
}

/**
 *
 * @export
 * @interface CreateSubmissionItemBodyParams
 */
export interface CreateSubmissionItemBodyParams {
	/**
	 * Boolean indicating whether the submission is completed.
	 * @type {boolean}
	 * @memberof CreateSubmissionItemBodyParams
	 */
	completed: boolean;
}
/**
 *
 * @export
 * @interface CustomParameterEntryParam
 */
export interface CustomParameterEntryParam {
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterEntryParam
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterEntryParam
	 */
	value?: string;
}
/**
 *
 * @export
 * @interface CustomParameterEntryResponse
 */
export interface CustomParameterEntryResponse {
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterEntryResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterEntryResponse
	 */
	value?: string;
}
/**
 *
 * @export
 * @interface CustomParameterPostParams
 */
export interface CustomParameterPostParams {
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	displayName: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	defaultValue?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	regex?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	regexComment?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	scope: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	location: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterPostParams
	 */
	type: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof CustomParameterPostParams
	 */
	isOptional: boolean;
}
/**
 *
 * @export
 * @interface CustomParameterResponse
 */
export interface CustomParameterResponse {
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	displayName: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	description?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	defaultValue?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	regex?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	regexComment?: string;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	scope: CustomParameterResponseScopeEnum;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	location: CustomParameterResponseLocationEnum;
	/**
	 *
	 * @type {string}
	 * @memberof CustomParameterResponse
	 */
	type: CustomParameterResponseTypeEnum;
	/**
	 *
	 * @type {boolean}
	 * @memberof CustomParameterResponse
	 */
	isOptional: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum CustomParameterResponseScopeEnum {
	Global = "global",
	School = "school",
	Context = "context",
}
/**
 * @export
 * @enum {string}
 */
export enum CustomParameterResponseLocationEnum {
	Path = "path",
	Body = "body",
	Query = "query",
}
/**
 * @export
 * @enum {string}
 */
export enum CustomParameterResponseTypeEnum {
	String = "string",
	Number = "number",
	Boolean = "boolean",
	AutoContextid = "auto_contextid",
	AutoContextname = "auto_contextname",
	AutoSchoolid = "auto_schoolid",
	AutoSchoolnumber = "auto_schoolnumber",
}

/**
 *
 * @export
 * @interface DashboardGridElementResponse
 */
export interface DashboardGridElementResponse {
	/**
	 * The id of the Grid element
	 * @type {string}
	 * @memberof DashboardGridElementResponse
	 */
	id: string;
	/**
	 * Title of the Grid element
	 * @type {string}
	 * @memberof DashboardGridElementResponse
	 */
	title: string;
	/**
	 * Short title of the Grid element
	 * @type {string}
	 * @memberof DashboardGridElementResponse
	 */
	shortTitle: string;
	/**
	 * Color of the Grid element
	 * @type {string}
	 * @memberof DashboardGridElementResponse
	 */
	displayColor: string;
	/**
	 * X position of the Grid element
	 * @type {number}
	 * @memberof DashboardGridElementResponse
	 */
	xPosition: number;
	/**
	 * Y position of the Grid element
	 * @type {number}
	 * @memberof DashboardGridElementResponse
	 */
	yPosition: number;
	/**
	 * The id of the group element
	 * @type {string}
	 * @memberof DashboardGridElementResponse
	 */
	groupId: string;
	/**
	 * List of all subelements in the group
	 * @type {Array<DashboardGridSubElementResponse>}
	 * @memberof DashboardGridElementResponse
	 */
	groupElements: Array<DashboardGridSubElementResponse>;
	/**
	 * Start of the copying process if it is still ongoing - otherwise property is not set.
	 * @type {string}
	 * @memberof DashboardGridElementResponse
	 */
	copyingSince: string;
}
/**
 *
 * @export
 * @interface DashboardGridSubElementResponse
 */
export interface DashboardGridSubElementResponse {
	/**
	 * The id of the Grid element
	 * @type {string}
	 * @memberof DashboardGridSubElementResponse
	 */
	id: string;
	/**
	 * Title of the Grid element
	 * @type {string}
	 * @memberof DashboardGridSubElementResponse
	 */
	title: string;
	/**
	 * Short title of the Grid element
	 * @type {string}
	 * @memberof DashboardGridSubElementResponse
	 */
	shortTitle: string;
	/**
	 * Color of the Grid element
	 * @type {string}
	 * @memberof DashboardGridSubElementResponse
	 */
	displayColor: string;
}
/**
 *
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
	/**
	 * The id of the Dashboard entity
	 * @type {string}
	 * @memberof DashboardResponse
	 */
	id: string;
	/**
	 * List of all elements visible on the dashboard
	 * @type {Array<DashboardGridElementResponse>}
	 * @memberof DashboardResponse
	 */
	gridElements: Array<DashboardGridElementResponse>;
}
/**
 *
 * @export
 * @interface EntityNotFoundError
 */
export interface EntityNotFoundError {
	/**
	 * The response status code.
	 * @type {number}
	 * @memberof EntityNotFoundError
	 */
	code: number;
	/**
	 * The error type.
	 * @type {string}
	 * @memberof EntityNotFoundError
	 */
	type: string;
	/**
	 * The error title.
	 * @type {string}
	 * @memberof EntityNotFoundError
	 */
	title: string;
	/**
	 * The error message.
	 * @type {string}
	 * @memberof EntityNotFoundError
	 */
	message: string;
	/**
	 * The error details.
	 * @type {object}
	 * @memberof EntityNotFoundError
	 */
	details?: object;
}
/**
 *
 * @export
 * @interface ExternalToolConfigurationTemplateResponse
 */
export interface ExternalToolConfigurationTemplateResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolConfigurationTemplateResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolConfigurationTemplateResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolConfigurationTemplateResponse
	 */
	logoUrl?: string;
	/**
	 *
	 * @type {Array<CustomParameterResponse>}
	 * @memberof ExternalToolConfigurationTemplateResponse
	 */
	parameters: Array<CustomParameterResponse>;
	/**
	 *
	 * @type {number}
	 * @memberof ExternalToolConfigurationTemplateResponse
	 */
	version: number;
}
/**
 *
 * @export
 * @interface ExternalToolCreateParams
 */
export interface ExternalToolCreateParams {
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolCreateParams
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolCreateParams
	 */
	url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolCreateParams
	 */
	logoUrl?: string;
	/**
	 *
	 * @type {BasicToolConfigParams | Lti11ToolConfigCreateParams | Oauth2ToolConfigCreateParams}
	 * @memberof ExternalToolCreateParams
	 */
	config:
		| BasicToolConfigParams
		| Lti11ToolConfigCreateParams
		| Oauth2ToolConfigCreateParams;
	/**
	 *
	 * @type {Array<CustomParameterPostParams>}
	 * @memberof ExternalToolCreateParams
	 */
	parameters?: Array<CustomParameterPostParams>;
	/**
	 *
	 * @type {boolean}
	 * @memberof ExternalToolCreateParams
	 */
	isHidden: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof ExternalToolCreateParams
	 */
	openNewTab: boolean;
}
/**
 *
 * @export
 * @interface ExternalToolResponse
 */
export interface ExternalToolResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolResponse
	 */
	url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolResponse
	 */
	logoUrl?: string;
	/**
	 *
	 * @type {object}
	 * @memberof ExternalToolResponse
	 */
	config: object;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ExternalToolResponse
	 */
	parameters: Array<string>;
	/**
	 *
	 * @type {boolean}
	 * @memberof ExternalToolResponse
	 */
	isHidden: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof ExternalToolResponse
	 */
	openNewTab: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof ExternalToolResponse
	 */
	version: number;
}
/**
 *
 * @export
 * @interface ExternalToolSearchListResponse
 */
export interface ExternalToolSearchListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<ExternalToolResponse>}
	 * @memberof ExternalToolSearchListResponse
	 */
	data: Array<ExternalToolResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof ExternalToolSearchListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof ExternalToolSearchListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof ExternalToolSearchListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface ExternalToolUpdateParams
 */
export interface ExternalToolUpdateParams {
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolUpdateParams
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolUpdateParams
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolUpdateParams
	 */
	url?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ExternalToolUpdateParams
	 */
	logoUrl?: string;
	/**
	 *
	 * @type {BasicToolConfigParams | Lti11ToolConfigUpdateParams | Oauth2ToolConfigUpdateParams}
	 * @memberof ExternalToolUpdateParams
	 */
	config:
		| BasicToolConfigParams
		| Lti11ToolConfigUpdateParams
		| Oauth2ToolConfigUpdateParams;
	/**
	 *
	 * @type {Array<CustomParameterPostParams>}
	 * @memberof ExternalToolUpdateParams
	 */
	parameters?: Array<CustomParameterPostParams>;
	/**
	 *
	 * @type {boolean}
	 * @memberof ExternalToolUpdateParams
	 */
	isHidden: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof ExternalToolUpdateParams
	 */
	openNewTab: boolean;
}
/**
 *
 * @export
 * @interface FileContentBody
 */
export interface FileContentBody {
	/**
	 *
	 * @type {string}
	 * @memberof FileContentBody
	 */
	caption: string;
}
/**
 *
 * @export
 * @interface FileElementContent
 */
export interface FileElementContent {
	/**
	 *
	 * @type {string}
	 * @memberof FileElementContent
	 */
	caption: string;
}
/**
 *
 * @export
 * @interface FileElementContentBody
 */
export interface FileElementContentBody {
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof FileElementContentBody
	 */
	type: ContentElementType;
	/**
	 *
	 * @type {FileContentBody}
	 * @memberof FileElementContentBody
	 */
	content: FileContentBody;
}
/**
 *
 * @export
 * @interface FileElementResponse
 */
export interface FileElementResponse {
	/**
	 *
	 * @type {string}
	 * @memberof FileElementResponse
	 */
	id: string;
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof FileElementResponse
	 */
	type: ContentElementType;
	/**
	 *
	 * @type {FileElementContent}
	 * @memberof FileElementResponse
	 */
	content: FileElementContent;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof FileElementResponse
	 */
	timestamps: TimestampsResponse;
}
/**
 *
 * @export
 * @interface ForbiddenOperationError
 */
export interface ForbiddenOperationError {
	/**
	 * The response status code.
	 * @type {number}
	 * @memberof ForbiddenOperationError
	 */
	code: number;
	/**
	 * The error type.
	 * @type {string}
	 * @memberof ForbiddenOperationError
	 */
	type: string;
	/**
	 * The error title.
	 * @type {string}
	 * @memberof ForbiddenOperationError
	 */
	title: string;
	/**
	 * The error message.
	 * @type {string}
	 * @memberof ForbiddenOperationError
	 */
	message: string;
	/**
	 * The error details.
	 * @type {object}
	 * @memberof ForbiddenOperationError
	 */
	details?: object;
}
/**
 *
 * @export
 * @interface ImportUserListResponse
 */
export interface ImportUserListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<ImportUserResponse>}
	 * @memberof ImportUserListResponse
	 */
	data: Array<ImportUserResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof ImportUserListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof ImportUserListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof ImportUserListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface ImportUserResponse
 */
export interface ImportUserResponse {
	/**
	 * id reference to a import user
	 * @type {string}
	 * @memberof ImportUserResponse
	 */
	importUserId: string;
	/**
	 * login name from external system
	 * @type {string}
	 * @memberof ImportUserResponse
	 */
	loginName: string;
	/**
	 * external systems user firstname
	 * @type {string}
	 * @memberof ImportUserResponse
	 */
	firstName: string;
	/**
	 * external systems user lastname
	 * @type {string}
	 * @memberof ImportUserResponse
	 */
	lastName: string;
	/**
	 * list of user roles from external system: student, teacher, admin
	 * @type {Array<string>}
	 * @memberof ImportUserResponse
	 */
	roleNames: Array<ImportUserResponseRoleNamesEnum>;
	/**
	 * names of classes the user attends from external system
	 * @type {Array<string>}
	 * @memberof ImportUserResponse
	 */
	classNames: Array<string>;
	/**
	 * assignemnt to a local user account
	 * @type {UserMatchResponse}
	 * @memberof ImportUserResponse
	 */
	match?: UserMatchResponse;
	/**
	 * manual flag to apply it as filter
	 * @type {boolean}
	 * @memberof ImportUserResponse
	 */
	flagged: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum ImportUserResponseRoleNamesEnum {
	Student = "student",
	Teacher = "teacher",
	Admin = "admin",
}

/**
 *
 * @export
 * @interface LdapAuthorizationBodyParams
 */
export interface LdapAuthorizationBodyParams {
	/**
	 *
	 * @type {string}
	 * @memberof LdapAuthorizationBodyParams
	 */
	systemId: string;
	/**
	 *
	 * @type {string}
	 * @memberof LdapAuthorizationBodyParams
	 */
	username: string;
	/**
	 *
	 * @type {string}
	 * @memberof LdapAuthorizationBodyParams
	 */
	password: string;
	/**
	 *
	 * @type {string}
	 * @memberof LdapAuthorizationBodyParams
	 */
	schoolId: string;
}
/**
 *
 * @export
 * @interface LessonCopyApiParams
 */
export interface LessonCopyApiParams {
	/**
	 * Destination course parent Id the lesson is copied to
	 * @type {string}
	 * @memberof LessonCopyApiParams
	 */
	courseId?: string;
}
/**
 *
 * @export
 * @interface LocalAuthorizationBodyParams
 */
export interface LocalAuthorizationBodyParams {
	/**
	 *
	 * @type {string}
	 * @memberof LocalAuthorizationBodyParams
	 */
	username: string;
	/**
	 *
	 * @type {string}
	 * @memberof LocalAuthorizationBodyParams
	 */
	password: string;
}
/**
 *
 * @export
 * @interface LoginRequestBody
 */
export interface LoginRequestBody {
	/**
	 * The error should follow the OAuth2 error format (e.g. invalid_request, login_required). Defaults to request_denied.
	 * @type {string}
	 * @memberof LoginRequestBody
	 */
	error?: string;
	/**
	 * Debug contains information to help resolve the problem as a developer. Usually not exposed to the public but only in the server logs.
	 * @type {string}
	 * @memberof LoginRequestBody
	 */
	error_debug?: string;
	/**
	 * Description of the error in a human readable format.
	 * @type {string}
	 * @memberof LoginRequestBody
	 */
	error_description?: string;
	/**
	 * Hint to help resolve the error.
	 * @type {string}
	 * @memberof LoginRequestBody
	 */
	error_hint?: string;
	/**
	 * Represents the HTTP status code of the error (e.g. 401 or 403). Defaults to 400.
	 * @type {number}
	 * @memberof LoginRequestBody
	 */
	status_code?: number;
	/**
	 * Remember, if set to true, tells the oauth provider to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope.
	 * @type {boolean}
	 * @memberof LoginRequestBody
	 */
	remember?: boolean;
	/**
	 * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely.
	 * @type {number}
	 * @memberof LoginRequestBody
	 */
	remember_for?: number;
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
	/**
	 * Id of the corresponding client.
	 * @type {string}
	 * @memberof LoginResponse
	 */
	client_id: string;
	/**
	 * The id/challenge of the consent login request.
	 * @type {object}
	 * @memberof LoginResponse
	 */
	challenge: object;
	/**
	 *
	 * @type {object}
	 * @memberof LoginResponse
	 */
	client: object;
	/**
	 *
	 * @type {OidcContextResponse}
	 * @memberof LoginResponse
	 */
	oidc_context: OidcContextResponse;
	/**
	 * The original oauth2.0 authorization url request by the client.
	 * @type {string}
	 * @memberof LoginResponse
	 */
	request_url: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof LoginResponse
	 */
	requested_access_token_audience: Array<string>;
	/**
	 * The request scopes of the login request.
	 * @type {Array<string>}
	 * @memberof LoginResponse
	 */
	requested_scope?: Array<string>;
	/**
	 * The login session id. This parameter is used as sid for the oidc front-/backchannel logout.
	 * @type {string}
	 * @memberof LoginResponse
	 */
	session_id: string;
	/**
	 * Skip, if true, implies that the client has requested the same scopes from the same user previously.
	 * @type {object}
	 * @memberof LoginResponse
	 */
	skip: object;
	/**
	 * User id of the end-user that is authenticated.
	 * @type {object}
	 * @memberof LoginResponse
	 */
	subject: object;
}
/**
 *
 * @export
 * @interface Lti11ToolConfigCreateParams
 */
export interface Lti11ToolConfigCreateParams {
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	type: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	baseUrl: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	key: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	secret: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	resource_link_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	lti_message_type: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigCreateParams
	 */
	privacy_permission: string;
}
/**
 *
 * @export
 * @interface Lti11ToolConfigUpdateParams
 */
export interface Lti11ToolConfigUpdateParams {
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	type: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	baseUrl: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	key: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	secret?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	resource_link_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	lti_message_type: string;
	/**
	 *
	 * @type {string}
	 * @memberof Lti11ToolConfigUpdateParams
	 */
	privacy_permission: string;
}
/**
 *
 * @export
 * @interface MigrationBody
 */
export interface MigrationBody {
	/**
	 * Set if migration is possible in this school
	 * @type {boolean}
	 * @memberof MigrationBody
	 */
	oauthMigrationPossible?: boolean | null;
	/**
	 * Set if migration is mandatory in this school
	 * @type {boolean}
	 * @memberof MigrationBody
	 */
	oauthMigrationMandatory?: boolean | null;
	/**
	 * Set if migration is finished in this school
	 * @type {boolean}
	 * @memberof MigrationBody
	 */
	oauthMigrationFinished?: boolean | null;
}
/**
 *
 * @export
 * @interface MigrationResponse
 */
export interface MigrationResponse {
	/**
	 * Date from when Migration is possible
	 * @type {string}
	 * @memberof MigrationResponse
	 */
	oauthMigrationPossible?: string;
	/**
	 * Date from when Migration is mandatory
	 * @type {string}
	 * @memberof MigrationResponse
	 */
	oauthMigrationMandatory?: string;
	/**
	 * Date from when Migration is finished
	 * @type {string}
	 * @memberof MigrationResponse
	 */
	oauthMigrationFinished?: string;
	/**
	 * Date from when Migration is finally finished and cannot be restarted again
	 * @type {string}
	 * @memberof MigrationResponse
	 */
	oauthMigrationFinalFinish?: string;
	/**
	 * Enable the Migration
	 * @type {boolean}
	 * @memberof MigrationResponse
	 */
	enableMigrationStart: boolean;
}
/**
 *
 * @export
 * @interface MoveCardBodyParams
 */
export interface MoveCardBodyParams {
	/**
	 *
	 * @type {string}
	 * @memberof MoveCardBodyParams
	 */
	toColumnId: string;
	/**
	 *
	 * @type {number}
	 * @memberof MoveCardBodyParams
	 */
	toPosition: number;
}
/**
 *
 * @export
 * @interface MoveColumnBodyParams
 */
export interface MoveColumnBodyParams {
	/**
	 * The id of the target board
	 * @type {string}
	 * @memberof MoveColumnBodyParams
	 */
	toBoardId: string;
	/**
	 *
	 * @type {number}
	 * @memberof MoveColumnBodyParams
	 */
	toPosition: number;
}
/**
 *
 * @export
 * @interface MoveContentElementBody
 */
export interface MoveContentElementBody {
	/**
	 *
	 * @type {string}
	 * @memberof MoveContentElementBody
	 */
	toCardId: string;
	/**
	 *
	 * @type {number}
	 * @memberof MoveContentElementBody
	 */
	toPosition: number;
}
/**
 *
 * @export
 * @interface MoveElementParams
 */
export interface MoveElementParams {
	/**
	 *
	 * @type {MoveElementPositionParams}
	 * @memberof MoveElementParams
	 */
	from: MoveElementPositionParams;
	/**
	 *
	 * @type {MoveElementPositionParams}
	 * @memberof MoveElementParams
	 */
	to: MoveElementPositionParams;
}
/**
 *
 * @export
 * @interface MoveElementPositionParams
 */
export interface MoveElementPositionParams {
	/**
	 *
	 * @type {number}
	 * @memberof MoveElementPositionParams
	 */
	x: number;
	/**
	 *
	 * @type {number}
	 * @memberof MoveElementPositionParams
	 */
	y: number;
	/**
	 * used to identify a position within a group.
	 * @type {number}
	 * @memberof MoveElementPositionParams
	 */
	groupIndex?: number;
}
/**
 *
 * @export
 * @interface NewsListResponse
 */
export interface NewsListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<NewsResponse>}
	 * @memberof NewsListResponse
	 */
	data: Array<NewsResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof NewsListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof NewsListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof NewsListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface NewsResponse
 */
export interface NewsResponse {
	/**
	 * The id of the News entity
	 * @type {string}
	 * @memberof NewsResponse
	 */
	id: string;
	/**
	 * Title of the News entity
	 * @type {string}
	 * @memberof NewsResponse
	 */
	title: string;
	/**
	 * Content of the News entity
	 * @type {string}
	 * @memberof NewsResponse
	 */
	content: string;
	/**
	 * The point in time from when the News entity schould be displayed
	 * @type {string}
	 * @memberof NewsResponse
	 */
	displayAt: string;
	/**
	 * The type of source of the News entity
	 * @type {string}
	 * @memberof NewsResponse
	 */
	source?: NewsResponseSourceEnum;
	/**
	 * The source description of the News entity
	 * @type {string}
	 * @memberof NewsResponse
	 */
	sourceDescription?: string;
	/**
	 *
	 * @type {NewsTargetModel}
	 * @memberof NewsResponse
	 */
	targetModel: NewsTargetModel;
	/**
	 * Specific target id to which the News entity is related
	 * @type {string}
	 * @memberof NewsResponse
	 */
	targetId: string;
	/**
	 * The target object with id and name, could be the school, team, or course name
	 * @type {TargetInfoResponse}
	 * @memberof NewsResponse
	 */
	target: TargetInfoResponse;
	/**
	 * The School ownership
	 * @type {SchoolInfoResponse}
	 * @memberof NewsResponse
	 */
	school: SchoolInfoResponse;
	/**
	 * Reference to the User that created the News entity
	 * @type {UserInfoResponse}
	 * @memberof NewsResponse
	 */
	creator: UserInfoResponse;
	/**
	 * Reference to the User that updated the News entity
	 * @type {UserInfoResponse}
	 * @memberof NewsResponse
	 */
	updater?: UserInfoResponse;
	/**
	 * The creation timestamp
	 * @type {string}
	 * @memberof NewsResponse
	 */
	createdAt: string;
	/**
	 * The update timestamp
	 * @type {string}
	 * @memberof NewsResponse
	 */
	updatedAt: string;
	/**
	 * List of permissions the current user has for the News entity
	 * @type {Array<string>}
	 * @memberof NewsResponse
	 */
	permissions: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum NewsResponseSourceEnum {
	Internal = "internal",
	Rss = "rss",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum NewsTargetModel {
	Schools = "schools",
	Courses = "courses",
	Teams = "teams",
}

/**
 *
 * @export
 * @interface OAuthTokenDto
 */
export interface OAuthTokenDto {
	/**
	 *
	 * @type {string}
	 * @memberof OAuthTokenDto
	 */
	idToken: string;
	/**
	 *
	 * @type {string}
	 * @memberof OAuthTokenDto
	 */
	refreshToken: string;
	/**
	 *
	 * @type {string}
	 * @memberof OAuthTokenDto
	 */
	accessToken: string;
}
/**
 *
 * @export
 * @interface Oauth2AuthorizationBodyParams
 */
export interface Oauth2AuthorizationBodyParams {
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2AuthorizationBodyParams
	 */
	redirectUri: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2AuthorizationBodyParams
	 */
	code: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2AuthorizationBodyParams
	 */
	systemId: string;
}
/**
 *
 * @export
 * @interface Oauth2MigrationParams
 */
export interface Oauth2MigrationParams {
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2MigrationParams
	 */
	redirectUri: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2MigrationParams
	 */
	code: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2MigrationParams
	 */
	systemId: string;
}
/**
 *
 * @export
 * @interface Oauth2ToolConfigCreateParams
 */
export interface Oauth2ToolConfigCreateParams {
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	type: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	baseUrl: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	clientId: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	clientSecret: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	skipConsent: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	frontchannelLogoutUri?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	scope?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	redirectUris: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigCreateParams
	 */
	tokenEndpointAuthMethod: string;
}
/**
 *
 * @export
 * @interface Oauth2ToolConfigUpdateParams
 */
export interface Oauth2ToolConfigUpdateParams {
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	type: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	baseUrl: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	clientId: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	clientSecret?: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	skipConsent: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	frontchannelLogoutUri?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	scope?: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	redirectUris: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof Oauth2ToolConfigUpdateParams
	 */
	tokenEndpointAuthMethod: string;
}
/**
 *
 * @export
 * @interface OauthClientBody
 */
export interface OauthClientBody {
	/**
	 * The Oauth2 client id.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	client_id?: string;
	/**
	 * The Oauth2 client name.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	client_name?: string;
	/**
	 * The Oauth2 client secret.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	client_secret?: string;
	/**
	 * The allowed redirect urls of the Oauth2 client.
	 * @type {Array<string>}
	 * @memberof OauthClientBody
	 */
	redirect_uris?: Array<string>;
	/**
	 * Requested Client Authentication method for the Token Endpoint. The options are client_secret_post, client_secret_basic, private_key_jwt, and none.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	token_endpoint_auth_method?: string;
	/**
	 * SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	subject_type?: string;
	/**
	 * Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	scope?: string;
	/**
	 * Thr frontchannel logout uri.
	 * @type {string}
	 * @memberof OauthClientBody
	 */
	frontchannel_logout_uri?: string;
	/**
	 * The grant types of the Oauth2 client.
	 * @type {Array<string>}
	 * @memberof OauthClientBody
	 */
	grant_types?: Array<string>;
	/**
	 * The response types of the Oauth2 client.
	 * @type {Array<string>}
	 * @memberof OauthClientBody
	 */
	response_types?: Array<string>;
}
/**
 *
 * @export
 * @interface OauthClientResponse
 */
export interface OauthClientResponse {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	allowed_cors_origins?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	audience: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	authorization_code_grant_access_token_lifespan: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	authorization_code_grant_id_token_lifespan: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	authorization_code_grant_refresh_token_lifespan: string;
	/**
	 * Boolean value specifying whether the RP requires that a sid (session ID) Claim.
	 * @type {boolean}
	 * @memberof OauthClientResponse
	 */
	backchannel_logout_session_required: boolean;
	/**
	 * RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	backchannel_logout_uri: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	client_credentials_grant_access_token_lifespan: string;
	/**
	 * Id of the client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	client_id: string;
	/**
	 * Human-readable string name of the client presented to the end-user.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	client_name: string;
	/**
	 * SecretExpiresAt is an integer holding the time at which the client secret will expire or 0 if it will not expire.
	 * @type {number}
	 * @memberof OauthClientResponse
	 */
	client_secret_expires_at: number;
	/**
	 * ClientUri is an URL string of a web page providing information about the client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	client_uri: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	contacts?: Array<string>;
	/**
	 * CreatedAt returns the timestamp of the clients creation.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	created_at: string;
	/**
	 * Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters.
	 * @type {boolean}
	 * @memberof OauthClientResponse
	 */
	frontchannel_logout_session_required: boolean;
	/**
	 * RP URL that will cause the RP to log itself out when rendered in an iframe by the OP.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	frontchannel_logout_uri: string;
	/**
	 * The grant types of the Oauth2 client.
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	grant_types?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	implicit_grant_access_token_lifespan: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	implicit_grant_id_token_lifespan: string;
	/**
	 *
	 * @type {object}
	 * @memberof OauthClientResponse
	 */
	jwks: object;
	/**
	 * URL for the clients JSON Web Key Set [JWK] document
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	jwks_uri: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	jwt_bearer_grant_access_token_lifespan: string;
	/**
	 * LogoUri is an URL string that references a logo for the client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	logo_uri: string;
	/**
	 *
	 * @type {object}
	 * @memberof OauthClientResponse
	 */
	metadata: object;
	/**
	 * Owner is a string identifying the owner of the OAuth 2.0 Client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	owner: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	password_grant_access_token_lifespan: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	password_grant_refresh_token_lifespan: string;
	/**
	 * PolicyUri is a URL string that points to a human-readable privacy policy document
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	policy_uri: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	post_logout_redirect_uris?: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	redirect_uris?: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	refresh_token_grant_access_token_lifespan: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	refresh_token_grant_id_token_lifespan: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	refresh_token_grant_refresh_token_lifespan: string;
	/**
	 * RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	registration_access_token: string;
	/**
	 * RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	registration_client_uri: string;
	/**
	 * JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	request_object_signing_alg: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	request_uris?: Array<string>;
	/**
	 * The response types of the Oauth2 client.
	 * @type {Array<string>}
	 * @memberof OauthClientResponse
	 */
	response_types?: Array<string>;
	/**
	 * Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	scope: string;
	/**
	 * URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	sector_identifier_uri: string;
	/**
	 * SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	subject_type: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	token_endpoint_auth_method: string;
	/**
	 *
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	token_endpoint_auth_signing_alg: string;
	/**
	 * TermsOfServiceUri is a URL string that points to a human-readable terms of service document for the client.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	tos_uri: string;
	/**
	 * UpdatedAt returns the timestamp of the last update.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	updated_at: string;
	/**
	 * JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses.
	 * @type {string}
	 * @memberof OauthClientResponse
	 */
	userinfo_signed_response_alg: string;
}
/**
 *
 * @export
 * @interface OauthConfigResponse
 */
export interface OauthConfigResponse {
	/**
	 * Client id
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	clientId: string;
	/**
	 * Hint for idp redirects (optional)
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	idpHint?: string | null;
	/**
	 * Redirect uri
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	redirectUri: string;
	/**
	 * Grant type
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	grantType: string;
	/**
	 * Token endpoint
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	tokenEndpoint: string;
	/**
	 * Auth endpoint
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	authEndpoint: string;
	/**
	 * Response type
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	responseType: string;
	/**
	 * Scope
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	scope: string;
	/**
	 * Provider
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	provider: string;
	/**
	 * Logout endpoint
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	logoutEndpoint: string;
	/**
	 * Issuer
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	issuer: string;
	/**
	 * Jwks endpoint
	 * @type {string}
	 * @memberof OauthConfigResponse
	 */
	jwksEndpoint: string;
}
/**
 *
 * @export
 * @interface OidcContextResponse
 */
export interface OidcContextResponse {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OidcContextResponse
	 */
	acr_values: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof OidcContextResponse
	 */
	display: string;
	/**
	 *
	 * @type {object}
	 * @memberof OidcContextResponse
	 */
	id_token_hint_claims: object;
	/**
	 *
	 * @type {string}
	 * @memberof OidcContextResponse
	 */
	login_hint: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof OidcContextResponse
	 */
	ui_locales: Array<string>;
}
/**
 *
 * @export
 * @interface PageContentResponse
 */
export interface PageContentResponse {
	/**
	 * The URL for the proceed button
	 * @type {string}
	 * @memberof PageContentResponse
	 */
	proceedButtonUrl: string;
	/**
	 * The URL for the cancel button
	 * @type {string}
	 * @memberof PageContentResponse
	 */
	cancelButtonUrl: string;
}
/**
 *
 * @export
 * @interface PatchGroupParams
 */
export interface PatchGroupParams {
	/**
	 * Title of the Group grid element
	 * @type {string}
	 * @memberof PatchGroupParams
	 */
	title: string;
}
/**
 *
 * @export
 * @interface PatchMyAccountParams
 */
export interface PatchMyAccountParams {
	/**
	 * The current user password to authorize the update action.
	 * @type {string}
	 * @memberof PatchMyAccountParams
	 */
	passwordOld: string;
	/**
	 * The new password for the current user.
	 * @type {string}
	 * @memberof PatchMyAccountParams
	 */
	passwordNew?: string | null;
	/**
	 * The new email address for the current user.
	 * @type {string}
	 * @memberof PatchMyAccountParams
	 */
	email?: string | null;
	/**
	 * The new first name for the current user.
	 * @type {string}
	 * @memberof PatchMyAccountParams
	 */
	firstName?: string | null;
	/**
	 * The new last name for the current user.
	 * @type {string}
	 * @memberof PatchMyAccountParams
	 */
	lastName?: string | null;
}
/**
 *
 * @export
 * @interface PatchMyPasswordParams
 */
export interface PatchMyPasswordParams {
	/**
	 * The new user password.
	 * @type {string}
	 * @memberof PatchMyPasswordParams
	 */
	password: string;
	/**
	 * The confirmed new user password. Must match the password field.
	 * @type {string}
	 * @memberof PatchMyPasswordParams
	 */
	confirmPassword: string;
}
/**
 *
 * @export
 * @interface PatchOrderParams
 */
export interface PatchOrderParams {
	/**
	 * Array ids determining the new order
	 * @type {Array<string>}
	 * @memberof PatchOrderParams
	 */
	elements: Array<string>;
}
/**
 *
 * @export
 * @interface PatchVisibilityParams
 */
export interface PatchVisibilityParams {
	/**
	 * true to publish the element, false to unpublish
	 * @type {boolean}
	 * @memberof PatchVisibilityParams
	 */
	visibility: boolean;
}
/**
 *
 * @export
 * @interface PublicSystemListResponse
 */
export interface PublicSystemListResponse {
	/**
	 *
	 * @type {Array<PublicSystemResponse>}
	 * @memberof PublicSystemListResponse
	 */
	data: Array<PublicSystemResponse>;
}
/**
 *
 * @export
 * @interface PublicSystemResponse
 */
export interface PublicSystemResponse {
	/**
	 * Id of the system.
	 * @type {string}
	 * @memberof PublicSystemResponse
	 */
	id: string;
	/**
	 * Flag to request only systems with oauth-config.
	 * @type {string}
	 * @memberof PublicSystemResponse
	 */
	type?: string | null;
	/**
	 * Alias of the system.
	 * @type {string}
	 * @memberof PublicSystemResponse
	 */
	alias?: string | null;
	/**
	 * Display name of the system.
	 * @type {string}
	 * @memberof PublicSystemResponse
	 */
	displayName?: string | null;
	/**
	 * Oauth config of the system.
	 * @type {OauthConfigResponse}
	 * @memberof PublicSystemResponse
	 */
	oauthConfig?: OauthConfigResponse | null;
}
/**
 *
 * @export
 * @interface RedirectResponse
 */
export interface RedirectResponse {
	/**
	 * RedirectURL is the URL which you should redirect the user to once the authentication process is completed.
	 * @type {string}
	 * @memberof RedirectResponse
	 */
	redirect_to: string;
}
/**
 *
 * @export
 * @interface RenameBodyParams
 */
export interface RenameBodyParams {
	/**
	 *
	 * @type {string}
	 * @memberof RenameBodyParams
	 */
	title: string;
}
/**
 *
 * @export
 * @interface ResolvedUserResponse
 */
export interface ResolvedUserResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ResolvedUserResponse
	 */
	firstName: string;
	/**
	 *
	 * @type {string}
	 * @memberof ResolvedUserResponse
	 */
	lastName: string;
	/**
	 *
	 * @type {string}
	 * @memberof ResolvedUserResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ResolvedUserResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof ResolvedUserResponse
	 */
	updatedAt: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ResolvedUserResponse
	 */
	roles: Array<string>;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof ResolvedUserResponse
	 */
	permissions: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof ResolvedUserResponse
	 */
	schoolId: string;
}
/**
 *
 * @export
 * @interface RichText
 */
export interface RichText {
	/**
	 * Content of the rich text element
	 * @type {string}
	 * @memberof RichText
	 */
	content: string;
	/**
	 * Input format of the rich text element
	 * @type {string}
	 * @memberof RichText
	 */
	type: RichTextTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum RichTextTypeEnum {
	PlainText = "plainText",
	RichText = "richText",
	Inline = "inline",
	RichTextCk4 = "richTextCk4",
	RichTextCk5 = "richTextCk5",
	RichTextCk5Inline = "richTextCk5Inline",
}

/**
 *
 * @export
 * @interface RichTextCardElementParam
 */
export interface RichTextCardElementParam {
	/**
	 * Type of card element, i.e. richText (needed for discriminator)
	 * @type {string}
	 * @memberof RichTextCardElementParam
	 */
	type: string;
	/**
	 * Content of the rich text card element
	 * @type {string}
	 * @memberof RichTextCardElementParam
	 */
	value: string;
	/**
	 * Input format of card element content
	 * @type {string}
	 * @memberof RichTextCardElementParam
	 */
	inputFormat: RichTextCardElementParamInputFormatEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum RichTextCardElementParamInputFormatEnum {
	PlainText = "plainText",
	RichText = "richText",
	Inline = "inline",
	RichTextCk4 = "richTextCk4",
	RichTextCk5 = "richTextCk5",
	RichTextCk5Inline = "richTextCk5Inline",
}

/**
 *
 * @export
 * @interface RichTextContentBody
 */
export interface RichTextContentBody {
	/**
	 *
	 * @type {string}
	 * @memberof RichTextContentBody
	 */
	text: string;
	/**
	 *
	 * @type {string}
	 * @memberof RichTextContentBody
	 */
	inputFormat: string;
}
/**
 *
 * @export
 * @interface RichTextElementContent
 */
export interface RichTextElementContent {
	/**
	 *
	 * @type {string}
	 * @memberof RichTextElementContent
	 */
	text: string;
	/**
	 *
	 * @type {string}
	 * @memberof RichTextElementContent
	 */
	inputFormat: string;
}
/**
 *
 * @export
 * @interface RichTextElementContentBody
 */
export interface RichTextElementContentBody {
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof RichTextElementContentBody
	 */
	type: ContentElementType;
	/**
	 *
	 * @type {RichTextContentBody}
	 * @memberof RichTextElementContentBody
	 */
	content: RichTextContentBody;
}
/**
 *
 * @export
 * @interface RichTextElementResponse
 */
export interface RichTextElementResponse {
	/**
	 *
	 * @type {string}
	 * @memberof RichTextElementResponse
	 */
	id: string;
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof RichTextElementResponse
	 */
	type: ContentElementType;
	/**
	 *
	 * @type {RichTextElementContent}
	 * @memberof RichTextElementResponse
	 */
	content: RichTextElementContent;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof RichTextElementResponse
	 */
	timestamps: TimestampsResponse;
}
/**
 *
 * @export
 * @interface SchoolExternalToolPostParams
 */
export interface SchoolExternalToolPostParams {
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolPostParams
	 */
	toolId: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolPostParams
	 */
	schoolId: string;
	/**
	 *
	 * @type {Array<CustomParameterEntryParam>}
	 * @memberof SchoolExternalToolPostParams
	 */
	parameters?: Array<CustomParameterEntryParam>;
	/**
	 *
	 * @type {number}
	 * @memberof SchoolExternalToolPostParams
	 */
	version: number;
}
/**
 *
 * @export
 * @interface SchoolExternalToolResponse
 */
export interface SchoolExternalToolResponse {
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolResponse
	 */
	toolId: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolResponse
	 */
	schoolId: string;
	/**
	 *
	 * @type {Array<CustomParameterEntryResponse>}
	 * @memberof SchoolExternalToolResponse
	 */
	parameters: Array<CustomParameterEntryResponse>;
	/**
	 *
	 * @type {number}
	 * @memberof SchoolExternalToolResponse
	 */
	toolVersion: number;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolExternalToolResponse
	 */
	status: SchoolExternalToolResponseStatusEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum SchoolExternalToolResponseStatusEnum {
	Latest = "Latest",
	Outdated = "Outdated",
	Unknown = "Unknown",
}

/**
 *
 * @export
 * @interface SchoolExternalToolSearchListResponse
 */
export interface SchoolExternalToolSearchListResponse {
	/**
	 *
	 * @type {Array<SchoolExternalToolResponse>}
	 * @memberof SchoolExternalToolSearchListResponse
	 */
	data: Array<SchoolExternalToolResponse>;
}
/**
 *
 * @export
 * @interface SchoolInfoResponse
 */
export interface SchoolInfoResponse {
	/**
	 * The id of the School entity
	 * @type {string}
	 * @memberof SchoolInfoResponse
	 */
	id: string;
	/**
	 * The name of the School entity
	 * @type {string}
	 * @memberof SchoolInfoResponse
	 */
	name: string;
}
/**
 *
 * @export
 * @interface SchoolToolConfigurationEntryResponse
 */
export interface SchoolToolConfigurationEntryResponse {
	/**
	 *
	 * @type {string}
	 * @memberof SchoolToolConfigurationEntryResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolToolConfigurationEntryResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolToolConfigurationEntryResponse
	 */
	logoUrl?: string;
	/**
	 *
	 * @type {string}
	 * @memberof SchoolToolConfigurationEntryResponse
	 */
	schoolToolId: string;
}
/**
 *
 * @export
 * @interface SchoolToolConfigurationListResponse
 */
export interface SchoolToolConfigurationListResponse {
	/**
	 *
	 * @type {Array<SchoolToolConfigurationEntryResponse>}
	 * @memberof SchoolToolConfigurationListResponse
	 */
	data: Array<SchoolToolConfigurationEntryResponse>;
}
/**
 *
 * @export
 * @interface SetHeightBodyParams
 */
export interface SetHeightBodyParams {
	/**
	 *
	 * @type {number}
	 * @memberof SetHeightBodyParams
	 */
	height: number;
}
/**
 *
 * @export
 * @interface ShareTokenBodyParams
 */
export interface ShareTokenBodyParams {
	/**
	 * the type of the object being shared
	 * @type {string}
	 * @memberof ShareTokenBodyParams
	 */
	parentType: ShareTokenBodyParamsParentTypeEnum;
	/**
	 * the id of the object being shared.
	 * @type {string}
	 * @memberof ShareTokenBodyParams
	 */
	parentId: string;
	/**
	 * when defined, the sharetoken will expire after the given number of days.
	 * @type {number}
	 * @memberof ShareTokenBodyParams
	 */
	expiresInDays?: number | null;
	/**
	 * when defined, the sharetoken will be usable exclusively by members of the users school.
	 * @type {boolean}
	 * @memberof ShareTokenBodyParams
	 */
	schoolExclusive?: boolean | null;
}

/**
 * @export
 * @enum {string}
 */
export enum ShareTokenBodyParamsParentTypeEnum {
	Courses = "courses",
	Tasks = "tasks",
	Lessons = "lessons",
}

/**
 *
 * @export
 * @interface ShareTokenImportBodyParams
 */
export interface ShareTokenImportBodyParams {
	/**
	 * the new name of the imported object.
	 * @type {string}
	 * @memberof ShareTokenImportBodyParams
	 */
	newName: string;
	/**
	 * Id of the course to which the lesson/task will be added
	 * @type {string}
	 * @memberof ShareTokenImportBodyParams
	 */
	destinationCourseId?: string | null;
}
/**
 *
 * @export
 * @interface ShareTokenInfoResponse
 */
export interface ShareTokenInfoResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenInfoResponse
	 */
	token: string;
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenInfoResponse
	 */
	parentType: ShareTokenInfoResponseParentTypeEnum;
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenInfoResponse
	 */
	parentName: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ShareTokenInfoResponseParentTypeEnum {
	Courses = "courses",
	Tasks = "tasks",
	Lessons = "lessons",
}

/**
 *
 * @export
 * @interface ShareTokenPayloadResponse
 */
export interface ShareTokenPayloadResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenPayloadResponse
	 */
	parentType: ShareTokenPayloadResponseParentTypeEnum;
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenPayloadResponse
	 */
	parentId: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ShareTokenPayloadResponseParentTypeEnum {
	Courses = "courses",
	Tasks = "tasks",
	Lessons = "lessons",
}

/**
 *
 * @export
 * @interface ShareTokenResponse
 */
export interface ShareTokenResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenResponse
	 */
	token: string;
	/**
	 *
	 * @type {ShareTokenPayloadResponse}
	 * @memberof ShareTokenResponse
	 */
	payload: ShareTokenPayloadResponse;
	/**
	 *
	 * @type {string}
	 * @memberof ShareTokenResponse
	 */
	expiresAt?: string;
}
/**
 *
 * @export
 * @interface SingleColumnBoardResponse
 */
export interface SingleColumnBoardResponse {
	/**
	 * The id of the room this board belongs to
	 * @type {string}
	 * @memberof SingleColumnBoardResponse
	 */
	roomId: string;
	/**
	 * Title of the Board
	 * @type {string}
	 * @memberof SingleColumnBoardResponse
	 */
	title: string;
	/**
	 * Color of the Board
	 * @type {string}
	 * @memberof SingleColumnBoardResponse
	 */
	displayColor: string;
	/**
	 * Array of board specific tasks or lessons with matching type property
	 * @type {Array<BoardElementResponse>}
	 * @memberof SingleColumnBoardResponse
	 */
	elements: Array<BoardElementResponse>;
}
/**
 *
 * @export
 * @interface SubmissionContainerContentBody
 */
export interface SubmissionContainerContentBody {
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionContainerContentBody
	 */
	dueDate: string;
}
/**
 *
 * @export
 * @interface SubmissionContainerElementContent
 */
export interface SubmissionContainerElementContent {
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionContainerElementContent
	 */
	dueDate: string;
}
/**
 *
 * @export
 * @interface SubmissionContainerElementContentBody
 */
export interface SubmissionContainerElementContentBody {
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof SubmissionContainerElementContentBody
	 */
	type: ContentElementType;
	/**
	 *
	 * @type {SubmissionContainerContentBody}
	 * @memberof SubmissionContainerElementContentBody
	 */
	content: SubmissionContainerContentBody;
}
/**
 *
 * @export
 * @interface SubmissionContainerElementResponse
 */
export interface SubmissionContainerElementResponse {
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionContainerElementResponse
	 */
	id: string;
	/**
	 *
	 * @type {ContentElementType}
	 * @memberof SubmissionContainerElementResponse
	 */
	type: ContentElementType;
	/**
	 *
	 * @type {SubmissionContainerElementContent}
	 * @memberof SubmissionContainerElementResponse
	 */
	content: SubmissionContainerElementContent;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof SubmissionContainerElementResponse
	 */
	timestamps: TimestampsResponse;
}
/**
 *
 * @export
 * @interface SubmissionItemResponse
 */
export interface SubmissionItemResponse {
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionItemResponse
	 */
	id: string;
	/**
	 *
	 * @type {TimestampsResponse}
	 * @memberof SubmissionItemResponse
	 */
	timestamps: TimestampsResponse;
	/**
	 *
	 * @type {boolean}
	 * @memberof SubmissionItemResponse
	 */
	completed: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionItemResponse
	 */
	userId: string;
}
/**
 *
 * @export
 * @interface SubmissionStatusListResponse
 */
export interface SubmissionStatusListResponse {
	/**
	 *
	 * @type {Array<SubmissionStatusResponse>}
	 * @memberof SubmissionStatusListResponse
	 */
	data: Array<SubmissionStatusResponse>;
}
/**
 *
 * @export
 * @interface SubmissionStatusResponse
 */
export interface SubmissionStatusResponse {
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionStatusResponse
	 */
	id: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof SubmissionStatusResponse
	 */
	submitters: Array<string>;
	/**
	 *
	 * @type {boolean}
	 * @memberof SubmissionStatusResponse
	 */
	isSubmitted: boolean;
	/**
	 *
	 * @type {number}
	 * @memberof SubmissionStatusResponse
	 */
	grade?: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof SubmissionStatusResponse
	 */
	isGraded: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof SubmissionStatusResponse
	 */
	submittingCourseGroupName?: string;
}
/**
 *
 * @export
 * @interface SuccessfulResponse
 */
export interface SuccessfulResponse {
	/**
	 *
	 * @type {boolean}
	 * @memberof SuccessfulResponse
	 */
	successful: boolean;
}
/**
 *
 * @export
 * @interface TargetInfoResponse
 */
export interface TargetInfoResponse {
	/**
	 * The id of the Target entity
	 * @type {string}
	 * @memberof TargetInfoResponse
	 */
	id: string;
	/**
	 * The name of the Target entity
	 * @type {string}
	 * @memberof TargetInfoResponse
	 */
	name: string;
}
/**
 *
 * @export
 * @interface TaskCardParams
 */
export interface TaskCardParams {
	/**
	 * The id of an course object.
	 * @type {string}
	 * @memberof TaskCardParams
	 */
	courseId: string;
	/**
	 * The title of the card
	 * @type {string}
	 * @memberof TaskCardParams
	 */
	title: string;
	/**
	 * Visible at date of the card
	 * @type {string}
	 * @memberof TaskCardParams
	 */
	visibleAtDate?: string;
	/**
	 * Due date of the card
	 * @type {string}
	 * @memberof TaskCardParams
	 */
	dueDate: string;
	/**
	 * Card elements array
	 * @type {Array<CardElementParams>}
	 * @memberof TaskCardParams
	 */
	cardElements?: Array<CardElementParams>;
}
/**
 *
 * @export
 * @interface TaskCardResponse
 */
export interface TaskCardResponse {
	/**
	 * The id of the task card
	 * @type {string}
	 * @memberof TaskCardResponse
	 */
	id: string;
	/**
	 * The title of the task card
	 * @type {string}
	 * @memberof TaskCardResponse
	 */
	title: string;
	/**
	 * Array of card elements
	 * @type {Array<CardElementResponse>}
	 * @memberof TaskCardResponse
	 */
	cardElements?: Array<CardElementResponse>;
	/**
	 *
	 * @type {string}
	 * @memberof TaskCardResponse
	 */
	courseName: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskCardResponse
	 */
	courseId: string;
	/**
	 * Are the card elements draggable?
	 * @type {boolean}
	 * @memberof TaskCardResponse
	 */
	draggable: boolean;
	/**
	 * The task attached to the card
	 * @type {TaskResponse}
	 * @memberof TaskCardResponse
	 */
	task: TaskResponse;
	/**
	 * Visible at date of the task card
	 * @type {string}
	 * @memberof TaskCardResponse
	 */
	visibleAtDate: string;
	/**
	 * Due date of the task card
	 * @type {string}
	 * @memberof TaskCardResponse
	 */
	dueDate: string;
}
/**
 *
 * @export
 * @interface TaskCopyApiParams
 */
export interface TaskCopyApiParams {
	/**
	 * Destination course parent Id the task is copied to
	 * @type {string}
	 * @memberof TaskCopyApiParams
	 */
	courseId?: string;
	/**
	 * Destination lesson parent Id the task is copied to
	 * @type {string}
	 * @memberof TaskCopyApiParams
	 */
	lessonId?: string;
}
/**
 *
 * @export
 * @interface TaskCreateParams
 */
export interface TaskCreateParams {
	/**
	 * The id of an course object.
	 * @type {string}
	 * @memberof TaskCreateParams
	 */
	courseId?: string;
	/**
	 * List of users ids, which belong to course. This restricts access to the task.
	 * @type {Array<string>}
	 * @memberof TaskCreateParams
	 */
	usersIds?: Array<string> | null;
	/**
	 * The id of an lesson object.
	 * @type {string}
	 * @memberof TaskCreateParams
	 */
	lessonId?: string;
	/**
	 * The title of the task
	 * @type {string}
	 * @memberof TaskCreateParams
	 */
	name: string;
	/**
	 * The description of the task
	 * @type {string}
	 * @memberof TaskCreateParams
	 */
	description?: string;
	/**
	 * Date since the task is published
	 * @type {string}
	 * @memberof TaskCreateParams
	 */
	availableDate?: string;
	/**
	 * Date until the task submissions can be sent
	 * @type {string}
	 * @memberof TaskCreateParams
	 */
	dueDate?: string;
}
/**
 *
 * @export
 * @interface TaskListResponse
 */
export interface TaskListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<TaskResponse>}
	 * @memberof TaskListResponse
	 */
	data: Array<TaskResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof TaskListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof TaskListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof TaskListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	id: string;
	/**
	 *
	 * @type {Array<UsersList>}
	 * @memberof TaskResponse
	 */
	users: Array<UsersList>;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	availableDate?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	dueDate?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	courseName: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	lessonName?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	courseId: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	taskCardId?: string;
	/**
	 * Task description object, with props content: string and type: input format types
	 * @type {RichText}
	 * @memberof TaskResponse
	 */
	description?: RichText;
	/**
	 *
	 * @type {boolean}
	 * @memberof TaskResponse
	 */
	lessonHidden: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	displayColor?: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof TaskResponse
	 */
	updatedAt: string;
	/**
	 *
	 * @type {TaskStatusResponse}
	 * @memberof TaskResponse
	 */
	status: TaskStatusResponse;
}
/**
 *
 * @export
 * @interface TaskStatusResponse
 */
export interface TaskStatusResponse {
	/**
	 *
	 * @type {number}
	 * @memberof TaskStatusResponse
	 */
	submitted: number;
	/**
	 *
	 * @type {number}
	 * @memberof TaskStatusResponse
	 */
	maxSubmissions: number;
	/**
	 *
	 * @type {number}
	 * @memberof TaskStatusResponse
	 */
	graded: number;
	/**
	 *
	 * @type {boolean}
	 * @memberof TaskStatusResponse
	 */
	isDraft: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TaskStatusResponse
	 */
	isSubstitutionTeacher: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TaskStatusResponse
	 */
	isFinished: boolean;
}
/**
 *
 * @export
 * @interface TaskUpdateParams
 */
export interface TaskUpdateParams {
	/**
	 * The id of an course object.
	 * @type {string}
	 * @memberof TaskUpdateParams
	 */
	courseId?: string;
	/**
	 * List of users ids, which belong to course. This restricts access to the task.
	 * @type {Array<string>}
	 * @memberof TaskUpdateParams
	 */
	usersIds?: Array<string> | null;
	/**
	 * The id of an lesson object.
	 * @type {string}
	 * @memberof TaskUpdateParams
	 */
	lessonId?: string;
	/**
	 * The title of the task
	 * @type {string}
	 * @memberof TaskUpdateParams
	 */
	name: string;
	/**
	 * The description of the task
	 * @type {string}
	 * @memberof TaskUpdateParams
	 */
	description?: string;
	/**
	 * Date since the task is published
	 * @type {string}
	 * @memberof TaskUpdateParams
	 */
	availableDate?: string;
	/**
	 * Date until the task submissions can be sent
	 * @type {string}
	 * @memberof TaskUpdateParams
	 */
	dueDate?: string;
}
/**
 *
 * @export
 * @interface TeamPermissionsBody
 */
export interface TeamPermissionsBody {
	/**
	 *
	 * @type {boolean}
	 * @memberof TeamPermissionsBody
	 */
	read: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TeamPermissionsBody
	 */
	write: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TeamPermissionsBody
	 */
	create: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TeamPermissionsBody
	 */
	_delete: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof TeamPermissionsBody
	 */
	share: boolean;
}
/**
 *
 * @export
 * @interface TimestampsResponse
 */
export interface TimestampsResponse {
	/**
	 *
	 * @type {string}
	 * @memberof TimestampsResponse
	 */
	lastUpdatedAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof TimestampsResponse
	 */
	createdAt: string;
	/**
	 *
	 * @type {string}
	 * @memberof TimestampsResponse
	 */
	deletedAt?: string;
}
/**
 *
 * @export
 * @interface ToolConfigurationEntryResponse
 */
export interface ToolConfigurationEntryResponse {
	/**
	 *
	 * @type {string}
	 * @memberof ToolConfigurationEntryResponse
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ToolConfigurationEntryResponse
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ToolConfigurationEntryResponse
	 */
	logoUrl?: string;
}
/**
 *
 * @export
 * @interface ToolConfigurationListResponse
 */
export interface ToolConfigurationListResponse {
	/**
	 *
	 * @type {Array<ToolConfigurationEntryResponse>}
	 * @memberof ToolConfigurationListResponse
	 */
	data: Array<ToolConfigurationEntryResponse>;
}
/**
 *
 * @export
 * @interface ToolLaunchRequestResponse
 */
export interface ToolLaunchRequestResponse {
	/**
	 * The Launch Request method (GET or POST)
	 * @type {string}
	 * @memberof ToolLaunchRequestResponse
	 */
	method: ToolLaunchRequestResponseMethodEnum;
	/**
	 * The URL for the Tool Launch Request
	 * @type {string}
	 * @memberof ToolLaunchRequestResponse
	 */
	url: string;
	/**
	 * The payload for the Tool Launch Request (optional)
	 * @type {string}
	 * @memberof ToolLaunchRequestResponse
	 */
	payload?: string;
	/**
	 * Specifies whether the Tool should be launched in a new tab
	 * @type {boolean}
	 * @memberof ToolLaunchRequestResponse
	 */
	openNewTab?: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum ToolLaunchRequestResponseMethodEnum {
	Get = "GET",
	Post = "POST",
}

/**
 *
 * @export
 * @interface ToolReferenceListResponse
 */
export interface ToolReferenceListResponse {
	/**
	 *
	 * @type {Array<ToolReferenceResponse>}
	 * @memberof ToolReferenceListResponse
	 */
	data: Array<ToolReferenceResponse>;
}
/**
 *
 * @export
 * @interface ToolReferenceResponse
 */
export interface ToolReferenceResponse {
	/**
	 * The id of the tool in the context
	 * @type {string}
	 * @memberof ToolReferenceResponse
	 */
	contextToolId: string;
	/**
	 * The url of the logo of the tool
	 * @type {string}
	 * @memberof ToolReferenceResponse
	 */
	logoUrl?: string;
	/**
	 * The display name of the tool
	 * @type {string}
	 * @memberof ToolReferenceResponse
	 */
	displayName: string;
	/**
	 * Whether the tool should be opened in a new tab
	 * @type {boolean}
	 * @memberof ToolReferenceResponse
	 */
	openInNewTab: boolean;
	/**
	 * The status of the tool
	 * @type {string}
	 * @memberof ToolReferenceResponse
	 */
	status: ToolReferenceResponseStatusEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ToolReferenceResponseStatusEnum {
	Latest = "Latest",
	Outdated = "Outdated",
	Unknown = "Unknown",
}

/**
 *
 * @export
 * @interface UpdateElementContentBodyParams
 */
export interface UpdateElementContentBodyParams {
	/**
	 *
	 * @type {FileElementContentBody | RichTextElementContentBody | SubmissionContainerElementContentBody}
	 * @memberof UpdateElementContentBodyParams
	 */
	data:
		| FileElementContentBody
		| RichTextElementContentBody
		| SubmissionContainerElementContentBody;
}
/**
 *
 * @export
 * @interface UpdateFlagParams
 */
export interface UpdateFlagParams {
	/**
	 * updates flag for an import user
	 * @type {boolean}
	 * @memberof UpdateFlagParams
	 */
	flagged: boolean;
}
/**
 *
 * @export
 * @interface UpdateMatchParams
 */
export interface UpdateMatchParams {
	/**
	 * updates local user reference for an import user
	 * @type {string}
	 * @memberof UpdateMatchParams
	 */
	userId: string;
}
/**
 *
 * @export
 * @interface UpdateNewsParams
 */
export interface UpdateNewsParams {
	/**
	 * Title of the News entity
	 * @type {string}
	 * @memberof UpdateNewsParams
	 */
	title?: string;
	/**
	 * Content of the News entity
	 * @type {string}
	 * @memberof UpdateNewsParams
	 */
	content?: string;
	/**
	 * The point in time from when the News entity schould be displayed
	 * @type {string}
	 * @memberof UpdateNewsParams
	 */
	displayAt?: string;
}
/**
 *
 * @export
 * @interface UserInfoResponse
 */
export interface UserInfoResponse {
	/**
	 * The id of the User entity
	 * @type {string}
	 * @memberof UserInfoResponse
	 */
	id: string;
	/**
	 * First name of the user
	 * @type {string}
	 * @memberof UserInfoResponse
	 */
	firstName?: string;
	/**
	 * Last name of the user
	 * @type {string}
	 * @memberof UserInfoResponse
	 */
	lastName?: string;
}
/**
 *
 * @export
 * @interface UserLoginMigrationMandatoryParams
 */
export interface UserLoginMigrationMandatoryParams {
	/**
	 *
	 * @type {boolean}
	 * @memberof UserLoginMigrationMandatoryParams
	 */
	mandatory: boolean;
}
/**
 *
 * @export
 * @interface UserLoginMigrationResponse
 */
export interface UserLoginMigrationResponse {
	/**
	 * Id of the system which is the origin of the migration
	 * @type {string}
	 * @memberof UserLoginMigrationResponse
	 */
	sourceSystemId?: string;
	/**
	 * Id of the system which is the target of the migration
	 * @type {string}
	 * @memberof UserLoginMigrationResponse
	 */
	targetSystemId: string;
	/**
	 * Date when the migration was marked as required
	 * @type {string}
	 * @memberof UserLoginMigrationResponse
	 */
	mandatorySince?: string;
	/**
	 * Date when the migration was started
	 * @type {string}
	 * @memberof UserLoginMigrationResponse
	 */
	startedAt: string;
	/**
	 * Date when the migration was completed
	 * @type {string}
	 * @memberof UserLoginMigrationResponse
	 */
	closedAt?: string;
	/**
	 * Date when the migration was completed including the grace period
	 * @type {string}
	 * @memberof UserLoginMigrationResponse
	 */
	finishedAt?: string;
}
/**
 *
 * @export
 * @interface UserLoginMigrationSearchListResponse
 */
export interface UserLoginMigrationSearchListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<UserLoginMigrationResponse>}
	 * @memberof UserLoginMigrationSearchListResponse
	 */
	data: Array<UserLoginMigrationResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof UserLoginMigrationSearchListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof UserLoginMigrationSearchListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof UserLoginMigrationSearchListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface UserMatchListResponse
 */
export interface UserMatchListResponse {
	/**
	 * The items for the current page.
	 * @type {Array<UserMatchResponse>}
	 * @memberof UserMatchListResponse
	 */
	data: Array<UserMatchResponse>;
	/**
	 * The total amount of items.
	 * @type {number}
	 * @memberof UserMatchListResponse
	 */
	total: number;
	/**
	 * The amount of items skipped from the start.
	 * @type {number}
	 * @memberof UserMatchListResponse
	 */
	skip: number;
	/**
	 * The page size of the response.
	 * @type {number}
	 * @memberof UserMatchListResponse
	 */
	limit: number;
}
/**
 *
 * @export
 * @interface UserMatchResponse
 */
export interface UserMatchResponse {
	/**
	 * local user id
	 * @type {string}
	 * @memberof UserMatchResponse
	 */
	userId: string;
	/**
	 * login name of local user
	 * @type {string}
	 * @memberof UserMatchResponse
	 */
	loginName: string;
	/**
	 * firstname of local user
	 * @type {string}
	 * @memberof UserMatchResponse
	 */
	firstName: string;
	/**
	 * lastname of local user
	 * @type {string}
	 * @memberof UserMatchResponse
	 */
	lastName: string;
	/**
	 * list of user roles from external system: student, teacher, admin
	 * @type {Array<string>}
	 * @memberof UserMatchResponse
	 */
	roleNames: Array<UserMatchResponseRoleNamesEnum>;
	/**
	 * match type: admin (manual) or auto (set, when names match exactly for a single user
	 * @type {string}
	 * @memberof UserMatchResponse
	 */
	matchedBy?: UserMatchResponseMatchedByEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum UserMatchResponseRoleNamesEnum {
	Student = "student",
	Teacher = "teacher",
	Admin = "admin",
}
/**
 * @export
 * @enum {string}
 */
export enum UserMatchResponseMatchedByEnum {
	Auto = "auto",
	Admin = "admin",
}

/**
 *
 * @export
 * @interface UsersList
 */
export interface UsersList {
	/**
	 *
	 * @type {string}
	 * @memberof UsersList
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof UsersList
	 */
	firstName: string;
	/**
	 *
	 * @type {string}
	 * @memberof UsersList
	 */
	lastName: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 * The response status code.
	 * @type {number}
	 * @memberof ValidationError
	 */
	code: number;
	/**
	 * The error type.
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string;
	/**
	 * The error title.
	 * @type {string}
	 * @memberof ValidationError
	 */
	title: string;
	/**
	 * The error message.
	 * @type {string}
	 * @memberof ValidationError
	 */
	message: string;
	/**
	 * The error details.
	 * @type {object}
	 * @memberof ValidationError
	 */
	details?: object;
}
/**
 *
 * @export
 * @interface VideoConferenceCreateParams
 */
export interface VideoConferenceCreateParams {
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoConferenceCreateParams
	 */
	everyAttendeeJoinsMuted: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoConferenceCreateParams
	 */
	everybodyJoinsAsModerator: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof VideoConferenceCreateParams
	 */
	moderatorMustApproveJoinRequests: boolean;
}
/**
 *
 * @export
 * @interface VideoConferenceJoinResponse
 */
export interface VideoConferenceJoinResponse {
	/**
	 * The URL to join the video conference.
	 * @type {string}
	 * @memberof VideoConferenceJoinResponse
	 */
	url: string;
}
/**
 *
 * @export
 * @interface VideoConferenceOptionsResponse
 */
export interface VideoConferenceOptionsResponse {
	/**
	 * Every attendee joins muted
	 * @type {boolean}
	 * @memberof VideoConferenceOptionsResponse
	 */
	everyAttendeeJoinsMuted: boolean;
	/**
	 * Every attendee joins as a moderator
	 * @type {boolean}
	 * @memberof VideoConferenceOptionsResponse
	 */
	everybodyJoinsAsModerator: boolean;
	/**
	 * Moderator must approve join requests
	 * @type {boolean}
	 * @memberof VideoConferenceOptionsResponse
	 */
	moderatorMustApproveJoinRequests: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum VideoConferenceScope {
	Course = "course",
	Event = "event",
}

/**
 *
 * @export
 * @enum {string}
 */
export enum VideoConferenceStateResponse {
	NotStarted = "NOT_STARTED",
	Running = "RUNNING",
	Finished = "FINISHED",
}

/**
 *
 * @export
 * @interface VisibilitySettingsResponse
 */
export interface VisibilitySettingsResponse {
	/**
	 *
	 * @type {string}
	 * @memberof VisibilitySettingsResponse
	 */
	publishedAt?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Deletes an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerDeleteAccountById: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("accountControllerDeleteAccountById", "id", id);
			const localVarPath = `/account/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Returns an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerFindAccountById: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("accountControllerFindAccountById", "id", id);
			const localVarPath = `/account/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Updates the the temporary account password for the authenticated user.
		 * @param {PatchMyPasswordParams} patchMyPasswordParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerReplaceMyPassword: async (
			patchMyPasswordParams: PatchMyPasswordParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'patchMyPasswordParams' is not null or undefined
			assertParamExists(
				"accountControllerReplaceMyPassword",
				"patchMyPasswordParams",
				patchMyPasswordParams
			);
			const localVarPath = `/account/me/password`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchMyPasswordParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
		 * @param {'userId' | 'username'} type The search criteria.
		 * @param {string} value The search value.
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerSearchAccounts: async (
			type: "userId" | "username",
			value: string,
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'type' is not null or undefined
			assertParamExists("accountControllerSearchAccounts", "type", type);
			// verify required parameter 'value' is not null or undefined
			assertParamExists("accountControllerSearchAccounts", "value", value);
			const localVarPath = `/account`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			if (type !== undefined) {
				localVarQueryParameter["type"] = type;
			}

			if (value !== undefined) {
				localVarQueryParameter["value"] = value;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Updates an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {AccountByIdBodyParams} accountByIdBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerUpdateAccountById: async (
			id: string,
			accountByIdBodyParams: AccountByIdBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("accountControllerUpdateAccountById", "id", id);
			// verify required parameter 'accountByIdBodyParams' is not null or undefined
			assertParamExists(
				"accountControllerUpdateAccountById",
				"accountByIdBodyParams",
				accountByIdBodyParams
			);
			const localVarPath = `/account/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				accountByIdBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Updates an account for the authenticated user.
		 * @param {PatchMyAccountParams} patchMyAccountParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerUpdateMyAccount: async (
			patchMyAccountParams: PatchMyAccountParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'patchMyAccountParams' is not null or undefined
			assertParamExists(
				"accountControllerUpdateMyAccount",
				"patchMyAccountParams",
				patchMyAccountParams
			);
			const localVarPath = `/account/me`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchMyAccountParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Deletes an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountControllerDeleteAccountById(
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<AccountResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.accountControllerDeleteAccountById(
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Returns an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountControllerFindAccountById(
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<AccountResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.accountControllerFindAccountById(
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Updates the the temporary account password for the authenticated user.
		 * @param {PatchMyPasswordParams} patchMyPasswordParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountControllerReplaceMyPassword(
			patchMyPasswordParams: PatchMyPasswordParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.accountControllerReplaceMyPassword(
					patchMyPasswordParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
		 * @param {'userId' | 'username'} type The search criteria.
		 * @param {string} value The search value.
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountControllerSearchAccounts(
			type: "userId" | "username",
			value: string,
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<AccountSearchListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.accountControllerSearchAccounts(
					type,
					value,
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Updates an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {AccountByIdBodyParams} accountByIdBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountControllerUpdateAccountById(
			id: string,
			accountByIdBodyParams: AccountByIdBodyParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<AccountResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.accountControllerUpdateAccountById(
					id,
					accountByIdBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Updates an account for the authenticated user.
		 * @param {PatchMyAccountParams} patchMyAccountParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async accountControllerUpdateMyAccount(
			patchMyAccountParams: PatchMyAccountParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.accountControllerUpdateMyAccount(
					patchMyAccountParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = AccountApiFp(configuration);
	return {
		/**
		 *
		 * @summary Deletes an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerDeleteAccountById(
			id: string,
			options?: any
		): AxiosPromise<AccountResponse> {
			return localVarFp
				.accountControllerDeleteAccountById(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Returns an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerFindAccountById(
			id: string,
			options?: any
		): AxiosPromise<AccountResponse> {
			return localVarFp
				.accountControllerFindAccountById(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Updates the the temporary account password for the authenticated user.
		 * @param {PatchMyPasswordParams} patchMyPasswordParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerReplaceMyPassword(
			patchMyPasswordParams: PatchMyPasswordParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.accountControllerReplaceMyPassword(patchMyPasswordParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
		 * @param {'userId' | 'username'} type The search criteria.
		 * @param {string} value The search value.
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerSearchAccounts(
			type: "userId" | "username",
			value: string,
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<AccountSearchListResponse> {
			return localVarFp
				.accountControllerSearchAccounts(type, value, skip, limit, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Updates an account with given id. Superhero role is REQUIRED.
		 * @param {string} id The id for the account as MongoDB id.
		 * @param {AccountByIdBodyParams} accountByIdBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerUpdateAccountById(
			id: string,
			accountByIdBodyParams: AccountByIdBodyParams,
			options?: any
		): AxiosPromise<AccountResponse> {
			return localVarFp
				.accountControllerUpdateAccountById(id, accountByIdBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Updates an account for the authenticated user.
		 * @param {PatchMyAccountParams} patchMyAccountParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		accountControllerUpdateMyAccount(
			patchMyAccountParams: PatchMyAccountParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.accountControllerUpdateMyAccount(patchMyAccountParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
	/**
	 *
	 * @summary Deletes an account with given id. Superhero role is REQUIRED.
	 * @param {string} id The id for the account as MongoDB id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApiInterface
	 */
	accountControllerDeleteAccountById(
		id: string,
		options?: any
	): AxiosPromise<AccountResponse>;

	/**
	 *
	 * @summary Returns an account with given id. Superhero role is REQUIRED.
	 * @param {string} id The id for the account as MongoDB id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApiInterface
	 */
	accountControllerFindAccountById(
		id: string,
		options?: any
	): AxiosPromise<AccountResponse>;

	/**
	 *
	 * @summary Updates the the temporary account password for the authenticated user.
	 * @param {PatchMyPasswordParams} patchMyPasswordParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApiInterface
	 */
	accountControllerReplaceMyPassword(
		patchMyPasswordParams: PatchMyPasswordParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
	 * @param {'userId' | 'username'} type The search criteria.
	 * @param {string} value The search value.
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApiInterface
	 */
	accountControllerSearchAccounts(
		type: "userId" | "username",
		value: string,
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<AccountSearchListResponse>;

	/**
	 *
	 * @summary Updates an account with given id. Superhero role is REQUIRED.
	 * @param {string} id The id for the account as MongoDB id.
	 * @param {AccountByIdBodyParams} accountByIdBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApiInterface
	 */
	accountControllerUpdateAccountById(
		id: string,
		accountByIdBodyParams: AccountByIdBodyParams,
		options?: any
	): AxiosPromise<AccountResponse>;

	/**
	 *
	 * @summary Updates an account for the authenticated user.
	 * @param {PatchMyAccountParams} patchMyAccountParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApiInterface
	 */
	accountControllerUpdateMyAccount(
		patchMyAccountParams: PatchMyAccountParams,
		options?: any
	): AxiosPromise<void>;
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
	/**
	 *
	 * @summary Deletes an account with given id. Superhero role is REQUIRED.
	 * @param {string} id The id for the account as MongoDB id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountControllerDeleteAccountById(id: string, options?: any) {
		return AccountApiFp(this.configuration)
			.accountControllerDeleteAccountById(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Returns an account with given id. Superhero role is REQUIRED.
	 * @param {string} id The id for the account as MongoDB id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountControllerFindAccountById(id: string, options?: any) {
		return AccountApiFp(this.configuration)
			.accountControllerFindAccountById(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Updates the the temporary account password for the authenticated user.
	 * @param {PatchMyPasswordParams} patchMyPasswordParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountControllerReplaceMyPassword(
		patchMyPasswordParams: PatchMyPasswordParams,
		options?: any
	) {
		return AccountApiFp(this.configuration)
			.accountControllerReplaceMyPassword(patchMyPasswordParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
	 * @param {'userId' | 'username'} type The search criteria.
	 * @param {string} value The search value.
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountControllerSearchAccounts(
		type: "userId" | "username",
		value: string,
		skip?: number,
		limit?: number,
		options?: any
	) {
		return AccountApiFp(this.configuration)
			.accountControllerSearchAccounts(type, value, skip, limit, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Updates an account with given id. Superhero role is REQUIRED.
	 * @param {string} id The id for the account as MongoDB id.
	 * @param {AccountByIdBodyParams} accountByIdBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountControllerUpdateAccountById(
		id: string,
		accountByIdBodyParams: AccountByIdBodyParams,
		options?: any
	) {
		return AccountApiFp(this.configuration)
			.accountControllerUpdateAccountById(id, accountByIdBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Updates an account for the authenticated user.
	 * @param {PatchMyAccountParams} patchMyAccountParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AccountApi
	 */
	public accountControllerUpdateMyAccount(
		patchMyAccountParams: PatchMyAccountParams,
		options?: any
	) {
		return AccountApiFp(this.configuration)
			.accountControllerUpdateMyAccount(patchMyAccountParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Starts the login process for users which are authenticated via LDAP
		 * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginControllerLoginLdap: async (
			ldapAuthorizationBodyParams: LdapAuthorizationBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'ldapAuthorizationBodyParams' is not null or undefined
			assertParamExists(
				"loginControllerLoginLdap",
				"ldapAuthorizationBodyParams",
				ldapAuthorizationBodyParams
			);
			const localVarPath = `/authentication/ldap`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				ldapAuthorizationBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Starts the login process for users which are locally managed.
		 * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginControllerLoginLocal: async (
			localAuthorizationBodyParams: LocalAuthorizationBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'localAuthorizationBodyParams' is not null or undefined
			assertParamExists(
				"loginControllerLoginLocal",
				"localAuthorizationBodyParams",
				localAuthorizationBodyParams
			);
			const localVarPath = `/authentication/local`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				localAuthorizationBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Starts the login process for users which are authenticated via OAuth 2.
		 * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginControllerLoginOauth2: async (
			oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'oauth2AuthorizationBodyParams' is not null or undefined
			assertParamExists(
				"loginControllerLoginOauth2",
				"oauth2AuthorizationBodyParams",
				oauth2AuthorizationBodyParams
			);
			const localVarPath = `/authentication/oauth2`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				oauth2AuthorizationBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		AuthenticationApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Starts the login process for users which are authenticated via LDAP
		 * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async loginControllerLoginLdap(
			ldapAuthorizationBodyParams: LdapAuthorizationBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.loginControllerLoginLdap(
					ldapAuthorizationBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Starts the login process for users which are locally managed.
		 * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async loginControllerLoginLocal(
			localAuthorizationBodyParams: LocalAuthorizationBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.loginControllerLoginLocal(
					localAuthorizationBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Starts the login process for users which are authenticated via OAuth 2.
		 * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async loginControllerLoginOauth2(
			oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.loginControllerLoginOauth2(
					oauth2AuthorizationBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = AuthenticationApiFp(configuration);
	return {
		/**
		 *
		 * @summary Starts the login process for users which are authenticated via LDAP
		 * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginControllerLoginLdap(
			ldapAuthorizationBodyParams: LdapAuthorizationBodyParams,
			options?: any
		): AxiosPromise<LoginResponse> {
			return localVarFp
				.loginControllerLoginLdap(ldapAuthorizationBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Starts the login process for users which are locally managed.
		 * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginControllerLoginLocal(
			localAuthorizationBodyParams: LocalAuthorizationBodyParams,
			options?: any
		): AxiosPromise<LoginResponse> {
			return localVarFp
				.loginControllerLoginLocal(localAuthorizationBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Starts the login process for users which are authenticated via OAuth 2.
		 * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginControllerLoginOauth2(
			oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams,
			options?: any
		): AxiosPromise<LoginResponse> {
			return localVarFp
				.loginControllerLoginOauth2(oauth2AuthorizationBodyParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
	/**
	 *
	 * @summary Starts the login process for users which are authenticated via LDAP
	 * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthenticationApiInterface
	 */
	loginControllerLoginLdap(
		ldapAuthorizationBodyParams: LdapAuthorizationBodyParams,
		options?: any
	): AxiosPromise<LoginResponse>;

	/**
	 *
	 * @summary Starts the login process for users which are locally managed.
	 * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthenticationApiInterface
	 */
	loginControllerLoginLocal(
		localAuthorizationBodyParams: LocalAuthorizationBodyParams,
		options?: any
	): AxiosPromise<LoginResponse>;

	/**
	 *
	 * @summary Starts the login process for users which are authenticated via OAuth 2.
	 * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthenticationApiInterface
	 */
	loginControllerLoginOauth2(
		oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams,
		options?: any
	): AxiosPromise<LoginResponse>;
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi
	extends BaseAPI
	implements AuthenticationApiInterface
{
	/**
	 *
	 * @summary Starts the login process for users which are authenticated via LDAP
	 * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthenticationApi
	 */
	public loginControllerLoginLdap(
		ldapAuthorizationBodyParams: LdapAuthorizationBodyParams,
		options?: any
	) {
		return AuthenticationApiFp(this.configuration)
			.loginControllerLoginLdap(ldapAuthorizationBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Starts the login process for users which are locally managed.
	 * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthenticationApi
	 */
	public loginControllerLoginLocal(
		localAuthorizationBodyParams: LocalAuthorizationBodyParams,
		options?: any
	) {
		return AuthenticationApiFp(this.configuration)
			.loginControllerLoginLocal(localAuthorizationBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Starts the login process for users which are authenticated via OAuth 2.
	 * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthenticationApi
	 */
	public loginControllerLoginOauth2(
		oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams,
		options?: any
	) {
		return AuthenticationApiFp(this.configuration)
			.loginControllerLoginOauth2(oauth2AuthorizationBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * BoardApi - axios parameter creator
 * @export
 */
export const BoardApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Create a new column on a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerCreateColumn: async (
			boardId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'boardId' is not null or undefined
			assertParamExists("boardControllerCreateColumn", "boardId", boardId);
			const localVarPath = `/boards/{boardId}/columns`.replace(
				`{${"boardId"}}`,
				encodeURIComponent(String(boardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerDeleteBoard: async (
			boardId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'boardId' is not null or undefined
			assertParamExists("boardControllerDeleteBoard", "boardId", boardId);
			const localVarPath = `/boards/{boardId}`.replace(
				`{${"boardId"}}`,
				encodeURIComponent(String(boardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get the context of a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerGetBoardContext: async (
			boardId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'boardId' is not null or undefined
			assertParamExists("boardControllerGetBoardContext", "boardId", boardId);
			const localVarPath = `/boards/{boardId}/context`.replace(
				`{${"boardId"}}`,
				encodeURIComponent(String(boardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get the skeleton of a a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerGetBoardSkeleton: async (
			boardId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'boardId' is not null or undefined
			assertParamExists("boardControllerGetBoardSkeleton", "boardId", boardId);
			const localVarPath = `/boards/{boardId}`.replace(
				`{${"boardId"}}`,
				encodeURIComponent(String(boardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update the title of a board.
		 * @param {string} boardId The id of the board.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerUpdateBoardTitle: async (
			boardId: string,
			renameBodyParams: RenameBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'boardId' is not null or undefined
			assertParamExists("boardControllerUpdateBoardTitle", "boardId", boardId);
			// verify required parameter 'renameBodyParams' is not null or undefined
			assertParamExists(
				"boardControllerUpdateBoardTitle",
				"renameBodyParams",
				renameBodyParams
			);
			const localVarPath = `/boards/{boardId}/title`.replace(
				`{${"boardId"}}`,
				encodeURIComponent(String(boardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				renameBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BoardApi - functional programming interface
 * @export
 */
export const BoardApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = BoardApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create a new column on a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async boardControllerCreateColumn(
			boardId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ColumnResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.boardControllerCreateColumn(
					boardId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Delete a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async boardControllerDeleteBoard(
			boardId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.boardControllerDeleteBoard(
					boardId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Get the context of a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async boardControllerGetBoardContext(
			boardId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<BoardContextResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.boardControllerGetBoardContext(
					boardId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Get the skeleton of a a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async boardControllerGetBoardSkeleton(
			boardId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.boardControllerGetBoardSkeleton(
					boardId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Update the title of a board.
		 * @param {string} boardId The id of the board.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async boardControllerUpdateBoardTitle(
			boardId: string,
			renameBodyParams: RenameBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.boardControllerUpdateBoardTitle(
					boardId,
					renameBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * BoardApi - factory interface
 * @export
 */
export const BoardApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = BoardApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create a new column on a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerCreateColumn(
			boardId: string,
			options?: any
		): AxiosPromise<ColumnResponse> {
			return localVarFp
				.boardControllerCreateColumn(boardId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerDeleteBoard(
			boardId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.boardControllerDeleteBoard(boardId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get the context of a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerGetBoardContext(
			boardId: string,
			options?: any
		): AxiosPromise<BoardContextResponse> {
			return localVarFp
				.boardControllerGetBoardContext(boardId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get the skeleton of a a board.
		 * @param {string} boardId The id of the board.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerGetBoardSkeleton(
			boardId: string,
			options?: any
		): AxiosPromise<BoardResponse> {
			return localVarFp
				.boardControllerGetBoardSkeleton(boardId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update the title of a board.
		 * @param {string} boardId The id of the board.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		boardControllerUpdateBoardTitle(
			boardId: string,
			renameBodyParams: RenameBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.boardControllerUpdateBoardTitle(boardId, renameBodyParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BoardApi - interface
 * @export
 * @interface BoardApi
 */
export interface BoardApiInterface {
	/**
	 *
	 * @summary Create a new column on a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApiInterface
	 */
	boardControllerCreateColumn(
		boardId: string,
		options?: any
	): AxiosPromise<ColumnResponse>;

	/**
	 *
	 * @summary Delete a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApiInterface
	 */
	boardControllerDeleteBoard(
		boardId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Get the context of a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApiInterface
	 */
	boardControllerGetBoardContext(
		boardId: string,
		options?: any
	): AxiosPromise<BoardContextResponse>;

	/**
	 *
	 * @summary Get the skeleton of a a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApiInterface
	 */
	boardControllerGetBoardSkeleton(
		boardId: string,
		options?: any
	): AxiosPromise<BoardResponse>;

	/**
	 *
	 * @summary Update the title of a board.
	 * @param {string} boardId The id of the board.
	 * @param {RenameBodyParams} renameBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApiInterface
	 */
	boardControllerUpdateBoardTitle(
		boardId: string,
		renameBodyParams: RenameBodyParams,
		options?: any
	): AxiosPromise<void>;
}

/**
 * BoardApi - object-oriented interface
 * @export
 * @class BoardApi
 * @extends {BaseAPI}
 */
export class BoardApi extends BaseAPI implements BoardApiInterface {
	/**
	 *
	 * @summary Create a new column on a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApi
	 */
	public boardControllerCreateColumn(boardId: string, options?: any) {
		return BoardApiFp(this.configuration)
			.boardControllerCreateColumn(boardId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApi
	 */
	public boardControllerDeleteBoard(boardId: string, options?: any) {
		return BoardApiFp(this.configuration)
			.boardControllerDeleteBoard(boardId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get the context of a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApi
	 */
	public boardControllerGetBoardContext(boardId: string, options?: any) {
		return BoardApiFp(this.configuration)
			.boardControllerGetBoardContext(boardId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get the skeleton of a a board.
	 * @param {string} boardId The id of the board.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApi
	 */
	public boardControllerGetBoardSkeleton(boardId: string, options?: any) {
		return BoardApiFp(this.configuration)
			.boardControllerGetBoardSkeleton(boardId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update the title of a board.
	 * @param {string} boardId The id of the board.
	 * @param {RenameBodyParams} renameBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardApi
	 */
	public boardControllerUpdateBoardTitle(
		boardId: string,
		renameBodyParams: RenameBodyParams,
		options?: any
	) {
		return BoardApiFp(this.configuration)
			.boardControllerUpdateBoardTitle(boardId, renameBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * BoardCardApi - axios parameter creator
 * @export
 */
export const BoardCardApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Create a new element on a card.
		 * @param {string} cardId The id of the card.
		 * @param {CreateContentElementBodyParams} createContentElementBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerCreateElement: async (
			cardId: string,
			createContentElementBodyParams: CreateContentElementBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cardId' is not null or undefined
			assertParamExists("cardControllerCreateElement", "cardId", cardId);
			// verify required parameter 'createContentElementBodyParams' is not null or undefined
			assertParamExists(
				"cardControllerCreateElement",
				"createContentElementBodyParams",
				createContentElementBodyParams
			);
			const localVarPath = `/cards/{cardId}/elements`.replace(
				`{${"cardId"}}`,
				encodeURIComponent(String(cardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createContentElementBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete a single card.
		 * @param {string} cardId The id of the card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerDeleteCard: async (
			cardId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cardId' is not null or undefined
			assertParamExists("cardControllerDeleteCard", "cardId", cardId);
			const localVarPath = `/cards/{cardId}`.replace(
				`{${"cardId"}}`,
				encodeURIComponent(String(cardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get a list of cards by their ids.
		 * @param {Array<string>} ids Array of Ids to be loaded
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerGetCards: async (
			ids: Array<string>,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'ids' is not null or undefined
			assertParamExists("cardControllerGetCards", "ids", ids);
			const localVarPath = `/cards`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (ids) {
				localVarQueryParameter["ids"] = ids;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Move a single card.
		 * @param {string} cardId The id of the card.
		 * @param {MoveCardBodyParams} moveCardBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerMoveCard: async (
			cardId: string,
			moveCardBodyParams: MoveCardBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cardId' is not null or undefined
			assertParamExists("cardControllerMoveCard", "cardId", cardId);
			// verify required parameter 'moveCardBodyParams' is not null or undefined
			assertParamExists(
				"cardControllerMoveCard",
				"moveCardBodyParams",
				moveCardBodyParams
			);
			const localVarPath = `/cards/{cardId}/position`.replace(
				`{${"cardId"}}`,
				encodeURIComponent(String(cardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				moveCardBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update the height of a single card.
		 * @param {string} cardId The id of the card.
		 * @param {SetHeightBodyParams} setHeightBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerUpdateCardHeight: async (
			cardId: string,
			setHeightBodyParams: SetHeightBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cardId' is not null or undefined
			assertParamExists("cardControllerUpdateCardHeight", "cardId", cardId);
			// verify required parameter 'setHeightBodyParams' is not null or undefined
			assertParamExists(
				"cardControllerUpdateCardHeight",
				"setHeightBodyParams",
				setHeightBodyParams
			);
			const localVarPath = `/cards/{cardId}/height`.replace(
				`{${"cardId"}}`,
				encodeURIComponent(String(cardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				setHeightBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update the title of a single card.
		 * @param {string} cardId The id of the card.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerUpdateCardTitle: async (
			cardId: string,
			renameBodyParams: RenameBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cardId' is not null or undefined
			assertParamExists("cardControllerUpdateCardTitle", "cardId", cardId);
			// verify required parameter 'renameBodyParams' is not null or undefined
			assertParamExists(
				"cardControllerUpdateCardTitle",
				"renameBodyParams",
				renameBodyParams
			);
			const localVarPath = `/cards/{cardId}/title`.replace(
				`{${"cardId"}}`,
				encodeURIComponent(String(cardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				renameBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BoardCardApi - functional programming interface
 * @export
 */
export const BoardCardApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		BoardCardApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create a new element on a card.
		 * @param {string} cardId The id of the card.
		 * @param {CreateContentElementBodyParams} createContentElementBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cardControllerCreateElement(
			cardId: string,
			createContentElementBodyParams: CreateContentElementBodyParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<
				| RichTextElementResponse
				| FileElementResponse
				| SubmissionContainerElementResponse
			>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cardControllerCreateElement(
					cardId,
					createContentElementBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Delete a single card.
		 * @param {string} cardId The id of the card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cardControllerDeleteCard(
			cardId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cardControllerDeleteCard(
					cardId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Get a list of cards by their ids.
		 * @param {Array<string>} ids Array of Ids to be loaded
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cardControllerGetCards(
			ids: Array<string>,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CardListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cardControllerGetCards(ids, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Move a single card.
		 * @param {string} cardId The id of the card.
		 * @param {MoveCardBodyParams} moveCardBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cardControllerMoveCard(
			cardId: string,
			moveCardBodyParams: MoveCardBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cardControllerMoveCard(
					cardId,
					moveCardBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Update the height of a single card.
		 * @param {string} cardId The id of the card.
		 * @param {SetHeightBodyParams} setHeightBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cardControllerUpdateCardHeight(
			cardId: string,
			setHeightBodyParams: SetHeightBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cardControllerUpdateCardHeight(
					cardId,
					setHeightBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Update the title of a single card.
		 * @param {string} cardId The id of the card.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cardControllerUpdateCardTitle(
			cardId: string,
			renameBodyParams: RenameBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cardControllerUpdateCardTitle(
					cardId,
					renameBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * BoardCardApi - factory interface
 * @export
 */
export const BoardCardApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = BoardCardApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create a new element on a card.
		 * @param {string} cardId The id of the card.
		 * @param {CreateContentElementBodyParams} createContentElementBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerCreateElement(
			cardId: string,
			createContentElementBodyParams: CreateContentElementBodyParams,
			options?: any
		): AxiosPromise<
			| RichTextElementResponse
			| FileElementResponse
			| SubmissionContainerElementResponse
		> {
			return localVarFp
				.cardControllerCreateElement(
					cardId,
					createContentElementBodyParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete a single card.
		 * @param {string} cardId The id of the card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerDeleteCard(
			cardId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.cardControllerDeleteCard(cardId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get a list of cards by their ids.
		 * @param {Array<string>} ids Array of Ids to be loaded
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerGetCards(
			ids: Array<string>,
			options?: any
		): AxiosPromise<CardListResponse> {
			return localVarFp
				.cardControllerGetCards(ids, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Move a single card.
		 * @param {string} cardId The id of the card.
		 * @param {MoveCardBodyParams} moveCardBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerMoveCard(
			cardId: string,
			moveCardBodyParams: MoveCardBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.cardControllerMoveCard(cardId, moveCardBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update the height of a single card.
		 * @param {string} cardId The id of the card.
		 * @param {SetHeightBodyParams} setHeightBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerUpdateCardHeight(
			cardId: string,
			setHeightBodyParams: SetHeightBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.cardControllerUpdateCardHeight(cardId, setHeightBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update the title of a single card.
		 * @param {string} cardId The id of the card.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cardControllerUpdateCardTitle(
			cardId: string,
			renameBodyParams: RenameBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.cardControllerUpdateCardTitle(cardId, renameBodyParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BoardCardApi - interface
 * @export
 * @interface BoardCardApi
 */
export interface BoardCardApiInterface {
	/**
	 *
	 * @summary Create a new element on a card.
	 * @param {string} cardId The id of the card.
	 * @param {CreateContentElementBodyParams} createContentElementBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApiInterface
	 */
	cardControllerCreateElement(
		cardId: string,
		createContentElementBodyParams: CreateContentElementBodyParams,
		options?: any
	): AxiosPromise<
		| RichTextElementResponse
		| FileElementResponse
		| SubmissionContainerElementResponse
	>;

	/**
	 *
	 * @summary Delete a single card.
	 * @param {string} cardId The id of the card.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApiInterface
	 */
	cardControllerDeleteCard(cardId: string, options?: any): AxiosPromise<void>;

	/**
	 *
	 * @summary Get a list of cards by their ids.
	 * @param {Array<string>} ids Array of Ids to be loaded
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApiInterface
	 */
	cardControllerGetCards(
		ids: Array<string>,
		options?: any
	): AxiosPromise<CardListResponse>;

	/**
	 *
	 * @summary Move a single card.
	 * @param {string} cardId The id of the card.
	 * @param {MoveCardBodyParams} moveCardBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApiInterface
	 */
	cardControllerMoveCard(
		cardId: string,
		moveCardBodyParams: MoveCardBodyParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Update the height of a single card.
	 * @param {string} cardId The id of the card.
	 * @param {SetHeightBodyParams} setHeightBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApiInterface
	 */
	cardControllerUpdateCardHeight(
		cardId: string,
		setHeightBodyParams: SetHeightBodyParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Update the title of a single card.
	 * @param {string} cardId The id of the card.
	 * @param {RenameBodyParams} renameBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApiInterface
	 */
	cardControllerUpdateCardTitle(
		cardId: string,
		renameBodyParams: RenameBodyParams,
		options?: any
	): AxiosPromise<void>;
}

/**
 * BoardCardApi - object-oriented interface
 * @export
 * @class BoardCardApi
 * @extends {BaseAPI}
 */
export class BoardCardApi extends BaseAPI implements BoardCardApiInterface {
	/**
	 *
	 * @summary Create a new element on a card.
	 * @param {string} cardId The id of the card.
	 * @param {CreateContentElementBodyParams} createContentElementBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApi
	 */
	public cardControllerCreateElement(
		cardId: string,
		createContentElementBodyParams: CreateContentElementBodyParams,
		options?: any
	) {
		return BoardCardApiFp(this.configuration)
			.cardControllerCreateElement(
				cardId,
				createContentElementBodyParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete a single card.
	 * @param {string} cardId The id of the card.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApi
	 */
	public cardControllerDeleteCard(cardId: string, options?: any) {
		return BoardCardApiFp(this.configuration)
			.cardControllerDeleteCard(cardId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get a list of cards by their ids.
	 * @param {Array<string>} ids Array of Ids to be loaded
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApi
	 */
	public cardControllerGetCards(ids: Array<string>, options?: any) {
		return BoardCardApiFp(this.configuration)
			.cardControllerGetCards(ids, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Move a single card.
	 * @param {string} cardId The id of the card.
	 * @param {MoveCardBodyParams} moveCardBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApi
	 */
	public cardControllerMoveCard(
		cardId: string,
		moveCardBodyParams: MoveCardBodyParams,
		options?: any
	) {
		return BoardCardApiFp(this.configuration)
			.cardControllerMoveCard(cardId, moveCardBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update the height of a single card.
	 * @param {string} cardId The id of the card.
	 * @param {SetHeightBodyParams} setHeightBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApi
	 */
	public cardControllerUpdateCardHeight(
		cardId: string,
		setHeightBodyParams: SetHeightBodyParams,
		options?: any
	) {
		return BoardCardApiFp(this.configuration)
			.cardControllerUpdateCardHeight(cardId, setHeightBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update the title of a single card.
	 * @param {string} cardId The id of the card.
	 * @param {RenameBodyParams} renameBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardCardApi
	 */
	public cardControllerUpdateCardTitle(
		cardId: string,
		renameBodyParams: RenameBodyParams,
		options?: any
	) {
		return BoardCardApiFp(this.configuration)
			.cardControllerUpdateCardTitle(cardId, renameBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * BoardColumnApi - axios parameter creator
 * @export
 */
export const BoardColumnApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Create a new card on a column.
		 * @param {string} columnId The id of the column.
		 * @param {CreateCardBodyParams} [createCardBodyParams]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerCreateCard: async (
			columnId: string,
			createCardBodyParams?: CreateCardBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'columnId' is not null or undefined
			assertParamExists("columnControllerCreateCard", "columnId", columnId);
			const localVarPath = `/columns/{columnId}/cards`.replace(
				`{${"columnId"}}`,
				encodeURIComponent(String(columnId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createCardBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete a single column.
		 * @param {string} columnId The id of the column.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerDeleteColumn: async (
			columnId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'columnId' is not null or undefined
			assertParamExists("columnControllerDeleteColumn", "columnId", columnId);
			const localVarPath = `/columns/{columnId}`.replace(
				`{${"columnId"}}`,
				encodeURIComponent(String(columnId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Move a single column.
		 * @param {string} columnId The id of the column.
		 * @param {MoveColumnBodyParams} moveColumnBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerMoveColumn: async (
			columnId: string,
			moveColumnBodyParams: MoveColumnBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'columnId' is not null or undefined
			assertParamExists("columnControllerMoveColumn", "columnId", columnId);
			// verify required parameter 'moveColumnBodyParams' is not null or undefined
			assertParamExists(
				"columnControllerMoveColumn",
				"moveColumnBodyParams",
				moveColumnBodyParams
			);
			const localVarPath = `/columns/{columnId}/position`.replace(
				`{${"columnId"}}`,
				encodeURIComponent(String(columnId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				moveColumnBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update the title of a single column.
		 * @param {string} columnId The id of the column.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerUpdateColumnTitle: async (
			columnId: string,
			renameBodyParams: RenameBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'columnId' is not null or undefined
			assertParamExists(
				"columnControllerUpdateColumnTitle",
				"columnId",
				columnId
			);
			// verify required parameter 'renameBodyParams' is not null or undefined
			assertParamExists(
				"columnControllerUpdateColumnTitle",
				"renameBodyParams",
				renameBodyParams
			);
			const localVarPath = `/columns/{columnId}/title`.replace(
				`{${"columnId"}}`,
				encodeURIComponent(String(columnId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				renameBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BoardColumnApi - functional programming interface
 * @export
 */
export const BoardColumnApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		BoardColumnApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create a new card on a column.
		 * @param {string} columnId The id of the column.
		 * @param {CreateCardBodyParams} [createCardBodyParams]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async columnControllerCreateCard(
			columnId: string,
			createCardBodyParams?: CreateCardBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.columnControllerCreateCard(
					columnId,
					createCardBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Delete a single column.
		 * @param {string} columnId The id of the column.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async columnControllerDeleteColumn(
			columnId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.columnControllerDeleteColumn(
					columnId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Move a single column.
		 * @param {string} columnId The id of the column.
		 * @param {MoveColumnBodyParams} moveColumnBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async columnControllerMoveColumn(
			columnId: string,
			moveColumnBodyParams: MoveColumnBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.columnControllerMoveColumn(
					columnId,
					moveColumnBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Update the title of a single column.
		 * @param {string} columnId The id of the column.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async columnControllerUpdateColumnTitle(
			columnId: string,
			renameBodyParams: RenameBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.columnControllerUpdateColumnTitle(
					columnId,
					renameBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * BoardColumnApi - factory interface
 * @export
 */
export const BoardColumnApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = BoardColumnApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create a new card on a column.
		 * @param {string} columnId The id of the column.
		 * @param {CreateCardBodyParams} [createCardBodyParams]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerCreateCard(
			columnId: string,
			createCardBodyParams?: CreateCardBodyParams,
			options?: any
		): AxiosPromise<CardResponse> {
			return localVarFp
				.columnControllerCreateCard(columnId, createCardBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete a single column.
		 * @param {string} columnId The id of the column.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerDeleteColumn(
			columnId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.columnControllerDeleteColumn(columnId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Move a single column.
		 * @param {string} columnId The id of the column.
		 * @param {MoveColumnBodyParams} moveColumnBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerMoveColumn(
			columnId: string,
			moveColumnBodyParams: MoveColumnBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.columnControllerMoveColumn(columnId, moveColumnBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update the title of a single column.
		 * @param {string} columnId The id of the column.
		 * @param {RenameBodyParams} renameBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		columnControllerUpdateColumnTitle(
			columnId: string,
			renameBodyParams: RenameBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.columnControllerUpdateColumnTitle(columnId, renameBodyParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BoardColumnApi - interface
 * @export
 * @interface BoardColumnApi
 */
export interface BoardColumnApiInterface {
	/**
	 *
	 * @summary Create a new card on a column.
	 * @param {string} columnId The id of the column.
	 * @param {CreateCardBodyParams} [createCardBodyParams]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApiInterface
	 */
	columnControllerCreateCard(
		columnId: string,
		createCardBodyParams?: CreateCardBodyParams,
		options?: any
	): AxiosPromise<CardResponse>;

	/**
	 *
	 * @summary Delete a single column.
	 * @param {string} columnId The id of the column.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApiInterface
	 */
	columnControllerDeleteColumn(
		columnId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Move a single column.
	 * @param {string} columnId The id of the column.
	 * @param {MoveColumnBodyParams} moveColumnBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApiInterface
	 */
	columnControllerMoveColumn(
		columnId: string,
		moveColumnBodyParams: MoveColumnBodyParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Update the title of a single column.
	 * @param {string} columnId The id of the column.
	 * @param {RenameBodyParams} renameBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApiInterface
	 */
	columnControllerUpdateColumnTitle(
		columnId: string,
		renameBodyParams: RenameBodyParams,
		options?: any
	): AxiosPromise<void>;
}

/**
 * BoardColumnApi - object-oriented interface
 * @export
 * @class BoardColumnApi
 * @extends {BaseAPI}
 */
export class BoardColumnApi extends BaseAPI implements BoardColumnApiInterface {
	/**
	 *
	 * @summary Create a new card on a column.
	 * @param {string} columnId The id of the column.
	 * @param {CreateCardBodyParams} [createCardBodyParams]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApi
	 */
	public columnControllerCreateCard(
		columnId: string,
		createCardBodyParams?: CreateCardBodyParams,
		options?: any
	) {
		return BoardColumnApiFp(this.configuration)
			.columnControllerCreateCard(columnId, createCardBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete a single column.
	 * @param {string} columnId The id of the column.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApi
	 */
	public columnControllerDeleteColumn(columnId: string, options?: any) {
		return BoardColumnApiFp(this.configuration)
			.columnControllerDeleteColumn(columnId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Move a single column.
	 * @param {string} columnId The id of the column.
	 * @param {MoveColumnBodyParams} moveColumnBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApi
	 */
	public columnControllerMoveColumn(
		columnId: string,
		moveColumnBodyParams: MoveColumnBodyParams,
		options?: any
	) {
		return BoardColumnApiFp(this.configuration)
			.columnControllerMoveColumn(columnId, moveColumnBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update the title of a single column.
	 * @param {string} columnId The id of the column.
	 * @param {RenameBodyParams} renameBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardColumnApi
	 */
	public columnControllerUpdateColumnTitle(
		columnId: string,
		renameBodyParams: RenameBodyParams,
		options?: any
	) {
		return BoardColumnApiFp(this.configuration)
			.columnControllerUpdateColumnTitle(columnId, renameBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * BoardElementApi - axios parameter creator
 * @export
 */
export const BoardElementApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Create a new submission item in a submission container element.
		 * @param {string} contentElementId The id of the element.
		 * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerCreateSubmission: async (
			contentElementId: string,
			createSubmissionItemBodyParams: CreateSubmissionItemBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contentElementId' is not null or undefined
			assertParamExists(
				'elementControllerCreateSubmission',
				'contentElementId',
				contentElementId
			);
			// verify required parameter 'createSubmissionItemBodyParams' is not null or undefined
			assertParamExists(
				'elementControllerCreateSubmission',
				'createSubmissionItemBodyParams',
				createSubmissionItemBodyParams
			);
			const localVarPath = `/elements/{contentElementId}/submissions`.replace(
				`{${"contentElementId"}}`,
				encodeURIComponent(String(contentElementId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createSubmissionItemBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerDeleteElement: async (
			contentElementId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contentElementId' is not null or undefined
			assertParamExists(
				'elementControllerDeleteElement',
				'contentElementId',
				contentElementId
			);
			const localVarPath = `/elements/{contentElementId}`.replace(
				`{${"contentElementId"}}`,
				encodeURIComponent(String(contentElementId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Move a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {MoveContentElementBody} moveContentElementBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerMoveElement: async (
			contentElementId: string,
			moveContentElementBody: MoveContentElementBody,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contentElementId' is not null or undefined
			assertParamExists(
				"elementControllerMoveElement",
				"contentElementId",
				contentElementId
			);
			// verify required parameter 'moveContentElementBody' is not null or undefined
			assertParamExists(
				"elementControllerMoveElement",
				"moveContentElementBody",
				moveContentElementBody
			);
			const localVarPath = `/elements/{contentElementId}/position`.replace(
				`{${"contentElementId"}}`,
				encodeURIComponent(String(contentElementId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				moveContentElementBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {UpdateElementContentBodyParams} updateElementContentBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerUpdateElement: async (
			contentElementId: string,
			updateElementContentBodyParams: UpdateElementContentBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contentElementId' is not null or undefined
			assertParamExists(
				"elementControllerUpdateElement",
				"contentElementId",
				contentElementId
			);
			// verify required parameter 'updateElementContentBodyParams' is not null or undefined
			assertParamExists(
				"elementControllerUpdateElement",
				"updateElementContentBodyParams",
				updateElementContentBodyParams
			);
			const localVarPath = `/elements/{contentElementId}/content`.replace(
				`{${"contentElementId"}}`,
				encodeURIComponent(String(contentElementId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateElementContentBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BoardElementApi - functional programming interface
 * @export
 */
export const BoardElementApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		BoardElementApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create a new submission item in a submission container element.
		 * @param {string} contentElementId The id of the element.
		 * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async elementControllerCreateSubmission(
			contentElementId: string,
			createSubmissionItemBodyParams: CreateSubmissionItemBodyParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SubmissionItemResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.elementControllerCreateSubmission(
					contentElementId,
					createSubmissionItemBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Delete a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async elementControllerDeleteElement(
			contentElementId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.elementControllerDeleteElement(
					contentElementId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Move a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {MoveContentElementBody} moveContentElementBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async elementControllerMoveElement(
			contentElementId: string,
			moveContentElementBody: MoveContentElementBody,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.elementControllerMoveElement(
					contentElementId,
					moveContentElementBody,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Update a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {UpdateElementContentBodyParams} updateElementContentBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async elementControllerUpdateElement(
			contentElementId: string,
			updateElementContentBodyParams: UpdateElementContentBodyParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.elementControllerUpdateElement(
					contentElementId,
					updateElementContentBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * BoardElementApi - factory interface
 * @export
 */
export const BoardElementApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = BoardElementApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create a new submission item in a submission container element.
		 * @param {string} contentElementId The id of the element.
		 * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerCreateSubmission(
			contentElementId: string,
			createSubmissionItemBodyParams: CreateSubmissionItemBodyParams,
			options?: any
		): AxiosPromise<SubmissionItemResponse> {
			return localVarFp
				.elementControllerCreateSubmission(
					contentElementId,
					createSubmissionItemBodyParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerDeleteElement(
			contentElementId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.elementControllerDeleteElement(contentElementId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Move a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {MoveContentElementBody} moveContentElementBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerMoveElement(
			contentElementId: string,
			moveContentElementBody: MoveContentElementBody,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.elementControllerMoveElement(
					contentElementId,
					moveContentElementBody,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update a single content element.
		 * @param {string} contentElementId The id of the element.
		 * @param {UpdateElementContentBodyParams} updateElementContentBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		elementControllerUpdateElement(
			contentElementId: string,
			updateElementContentBodyParams: UpdateElementContentBodyParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.elementControllerUpdateElement(
					contentElementId,
					updateElementContentBodyParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BoardElementApi - interface
 * @export
 * @interface BoardElementApi
 */
export interface BoardElementApiInterface {
	/**
	 *
	 * @summary Create a new submission item in a submission container element.
	 * @param {string} contentElementId The id of the element.
	 * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApiInterface
	 */
	elementControllerCreateSubmission(
		contentElementId: string,
		createSubmissionItemBodyParams: CreateSubmissionItemBodyParams,
		options?: any
	): AxiosPromise<SubmissionItemResponse>;

	/**
	 *
	 * @summary Delete a single content element.
	 * @param {string} contentElementId The id of the element.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApiInterface
	 */
	elementControllerDeleteElement(
		contentElementId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Move a single content element.
	 * @param {string} contentElementId The id of the element.
	 * @param {MoveContentElementBody} moveContentElementBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApiInterface
	 */
	elementControllerMoveElement(
		contentElementId: string,
		moveContentElementBody: MoveContentElementBody,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Update a single content element.
	 * @param {string} contentElementId The id of the element.
	 * @param {UpdateElementContentBodyParams} updateElementContentBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApiInterface
	 */
	elementControllerUpdateElement(
		contentElementId: string,
		updateElementContentBodyParams: UpdateElementContentBodyParams,
		options?: any
	): AxiosPromise<void>;
}

/**
 * BoardElementApi - object-oriented interface
 * @export
 * @class BoardElementApi
 * @extends {BaseAPI}
 */
export class BoardElementApi
	extends BaseAPI
	implements BoardElementApiInterface
{
	/**
	 *
	 * @summary Create a new submission item in a submission container element.
	 * @param {string} contentElementId The id of the element.
	 * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApi
	 */
	public elementControllerCreateSubmission(
		contentElementId: string,
		createSubmissionItemBodyParams: CreateSubmissionItemBodyParams,
		options?: any
	) {
		return BoardElementApiFp(this.configuration)
			.elementControllerCreateSubmission(
				contentElementId,
				createSubmissionItemBodyParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete a single content element.
	 * @param {string} contentElementId The id of the element.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApi
	 */
	public elementControllerDeleteElement(
		contentElementId: string,
		options?: any
	) {
		return BoardElementApiFp(this.configuration)
			.elementControllerDeleteElement(contentElementId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Move a single content element.
	 * @param {string} contentElementId The id of the element.
	 * @param {MoveContentElementBody} moveContentElementBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApi
	 */
	public elementControllerMoveElement(
		contentElementId: string,
		moveContentElementBody: MoveContentElementBody,
		options?: any
	) {
		return BoardElementApiFp(this.configuration)
			.elementControllerMoveElement(
				contentElementId,
				moveContentElementBody,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update a single content element.
	 * @param {string} contentElementId The id of the element.
	 * @param {UpdateElementContentBodyParams} updateElementContentBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BoardElementApi
	 */
	public elementControllerUpdateElement(
		contentElementId: string,
		updateElementContentBodyParams: UpdateElementContentBodyParams,
		options?: any
	) {
		return BoardElementApiFp(this.configuration)
			.elementControllerUpdateElement(
				contentElementId,
				updateElementContentBodyParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * CardsApi - axios parameter creator
 * @export
 */
export const CardsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {TaskCardParams} taskCardParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerCreate: async (
			taskCardParams: TaskCardParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskCardParams' is not null or undefined
			assertParamExists(
				"taskCardControllerCreate",
				"taskCardParams",
				taskCardParams
			);
			const localVarPath = `/cards/task`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				taskCardParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerDelete: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("taskCardControllerDelete", "id", id);
			const localVarPath = `/cards/task/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerFindOne: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("taskCardControllerFindOne", "id", id);
			const localVarPath = `/cards/task/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {TaskCardParams} taskCardParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerUpdate: async (
			id: string,
			taskCardParams: TaskCardParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("taskCardControllerUpdate", "id", id);
			// verify required parameter 'taskCardParams' is not null or undefined
			assertParamExists(
				"taskCardControllerUpdate",
				"taskCardParams",
				taskCardParams
			);
			const localVarPath = `/cards/task/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				taskCardParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CardsApi - functional programming interface
 * @export
 */
export const CardsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CardsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {TaskCardParams} taskCardParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskCardControllerCreate(
			taskCardParams: TaskCardParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<TaskCardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskCardControllerCreate(
					taskCardParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskCardControllerDelete(
			id: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskCardControllerDelete(id, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskCardControllerFindOne(
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<TaskCardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskCardControllerFindOne(id, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {TaskCardParams} taskCardParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskCardControllerUpdate(
			id: string,
			taskCardParams: TaskCardParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<TaskCardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskCardControllerUpdate(
					id,
					taskCardParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * CardsApi - factory interface
 * @export
 */
export const CardsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CardsApiFp(configuration);
	return {
		/**
		 *
		 * @param {TaskCardParams} taskCardParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerCreate(
			taskCardParams: TaskCardParams,
			options?: any
		): AxiosPromise<TaskCardResponse> {
			return localVarFp
				.taskCardControllerCreate(taskCardParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerDelete(id: string, options?: any): AxiosPromise<boolean> {
			return localVarFp
				.taskCardControllerDelete(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerFindOne(
			id: string,
			options?: any
		): AxiosPromise<TaskCardResponse> {
			return localVarFp
				.taskCardControllerFindOne(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id The id of the task card.
		 * @param {TaskCardParams} taskCardParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskCardControllerUpdate(
			id: string,
			taskCardParams: TaskCardParams,
			options?: any
		): AxiosPromise<TaskCardResponse> {
			return localVarFp
				.taskCardControllerUpdate(id, taskCardParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CardsApi - interface
 * @export
 * @interface CardsApi
 */
export interface CardsApiInterface {
	/**
	 *
	 * @param {TaskCardParams} taskCardParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApiInterface
	 */
	taskCardControllerCreate(
		taskCardParams: TaskCardParams,
		options?: any
	): AxiosPromise<TaskCardResponse>;

	/**
	 *
	 * @param {string} id The id of the task card.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApiInterface
	 */
	taskCardControllerDelete(id: string, options?: any): AxiosPromise<boolean>;

	/**
	 *
	 * @param {string} id The id of the task card.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApiInterface
	 */
	taskCardControllerFindOne(
		id: string,
		options?: any
	): AxiosPromise<TaskCardResponse>;

	/**
	 *
	 * @param {string} id The id of the task card.
	 * @param {TaskCardParams} taskCardParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApiInterface
	 */
	taskCardControllerUpdate(
		id: string,
		taskCardParams: TaskCardParams,
		options?: any
	): AxiosPromise<TaskCardResponse>;
}

/**
 * CardsApi - object-oriented interface
 * @export
 * @class CardsApi
 * @extends {BaseAPI}
 */
export class CardsApi extends BaseAPI implements CardsApiInterface {
	/**
	 *
	 * @param {TaskCardParams} taskCardParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApi
	 */
	public taskCardControllerCreate(
		taskCardParams: TaskCardParams,
		options?: any
	) {
		return CardsApiFp(this.configuration)
			.taskCardControllerCreate(taskCardParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id The id of the task card.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApi
	 */
	public taskCardControllerDelete(id: string, options?: any) {
		return CardsApiFp(this.configuration)
			.taskCardControllerDelete(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id The id of the task card.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApi
	 */
	public taskCardControllerFindOne(id: string, options?: any) {
		return CardsApiFp(this.configuration)
			.taskCardControllerFindOne(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id The id of the task card.
	 * @param {TaskCardParams} taskCardParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CardsApi
	 */
	public taskCardControllerUpdate(
		id: string,
		taskCardParams: TaskCardParams,
		options?: any
	) {
		return CardsApiFp(this.configuration)
			.taskCardControllerUpdate(id, taskCardParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * CollaborativeStorageApi - axios parameter creator
 * @export
 */
export const CollaborativeStorageApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Updates the CRUD Permissions(+Share) for a specific Role in a Team
		 * @param {string} teamId
		 * @param {string} roleId
		 * @param {TeamPermissionsBody} teamPermissionsBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		collaborativeStorageControllerUpdateTeamPermissionsForRole: async (
			teamId: string,
			roleId: string,
			teamPermissionsBody: TeamPermissionsBody,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamId' is not null or undefined
			assertParamExists(
				"collaborativeStorageControllerUpdateTeamPermissionsForRole",
				"teamId",
				teamId
			);
			// verify required parameter 'roleId' is not null or undefined
			assertParamExists(
				"collaborativeStorageControllerUpdateTeamPermissionsForRole",
				"roleId",
				roleId
			);
			// verify required parameter 'teamPermissionsBody' is not null or undefined
			assertParamExists(
				"collaborativeStorageControllerUpdateTeamPermissionsForRole",
				"teamPermissionsBody",
				teamPermissionsBody
			);
			const localVarPath =
				`/collaborative-storage/team/{teamId}/role/{roleId}/permissions`
					.replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
					.replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				teamPermissionsBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CollaborativeStorageApi - functional programming interface
 * @export
 */
export const CollaborativeStorageApiFp = function (
	configuration?: Configuration
) {
	const localVarAxiosParamCreator =
		CollaborativeStorageApiAxiosParamCreator(configuration);
	return {
		/**
		 * Updates the CRUD Permissions(+Share) for a specific Role in a Team
		 * @param {string} teamId
		 * @param {string} roleId
		 * @param {TeamPermissionsBody} teamPermissionsBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async collaborativeStorageControllerUpdateTeamPermissionsForRole(
			teamId: string,
			roleId: string,
			teamPermissionsBody: TeamPermissionsBody,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.collaborativeStorageControllerUpdateTeamPermissionsForRole(
					teamId,
					roleId,
					teamPermissionsBody,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * CollaborativeStorageApi - factory interface
 * @export
 */
export const CollaborativeStorageApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CollaborativeStorageApiFp(configuration);
	return {
		/**
		 * Updates the CRUD Permissions(+Share) for a specific Role in a Team
		 * @param {string} teamId
		 * @param {string} roleId
		 * @param {TeamPermissionsBody} teamPermissionsBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		collaborativeStorageControllerUpdateTeamPermissionsForRole(
			teamId: string,
			roleId: string,
			teamPermissionsBody: TeamPermissionsBody,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.collaborativeStorageControllerUpdateTeamPermissionsForRole(
					teamId,
					roleId,
					teamPermissionsBody,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CollaborativeStorageApi - interface
 * @export
 * @interface CollaborativeStorageApi
 */
export interface CollaborativeStorageApiInterface {
	/**
	 * Updates the CRUD Permissions(+Share) for a specific Role in a Team
	 * @param {string} teamId
	 * @param {string} roleId
	 * @param {TeamPermissionsBody} teamPermissionsBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CollaborativeStorageApiInterface
	 */
	collaborativeStorageControllerUpdateTeamPermissionsForRole(
		teamId: string,
		roleId: string,
		teamPermissionsBody: TeamPermissionsBody,
		options?: any
	): AxiosPromise<void>;
}

/**
 * CollaborativeStorageApi - object-oriented interface
 * @export
 * @class CollaborativeStorageApi
 * @extends {BaseAPI}
 */
export class CollaborativeStorageApi
	extends BaseAPI
	implements CollaborativeStorageApiInterface
{
	/**
	 * Updates the CRUD Permissions(+Share) for a specific Role in a Team
	 * @param {string} teamId
	 * @param {string} roleId
	 * @param {TeamPermissionsBody} teamPermissionsBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CollaborativeStorageApi
	 */
	public collaborativeStorageControllerUpdateTeamPermissionsForRole(
		teamId: string,
		roleId: string,
		teamPermissionsBody: TeamPermissionsBody,
		options?: any
	) {
		return CollaborativeStorageApiFp(this.configuration)
			.collaborativeStorageControllerUpdateTeamPermissionsForRole(
				teamId,
				roleId,
				teamPermissionsBody,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} courseId The id of the course
		 * @param {'1.1.0' | '1.3.0'} version The version of CC export
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseControllerExportCourse: async (
			courseId: string,
			version: "1.1.0" | "1.3.0",
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'courseId' is not null or undefined
			assertParamExists("courseControllerExportCourse", "courseId", courseId);
			// verify required parameter 'version' is not null or undefined
			assertParamExists("courseControllerExportCourse", "version", version);
			const localVarPath = `/courses/{courseId}/export`.replace(
				`{${"courseId"}}`,
				encodeURIComponent(String(courseId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (version !== undefined) {
				localVarQueryParameter["version"] = version;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseControllerFindForUser: async (
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/courses`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} courseId The id of the course
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseControllerGetCourse: async (
			courseId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'courseId' is not null or undefined
			assertParamExists("courseControllerGetCourse", "courseId", courseId);
			const localVarPath = `/courses/{courseId}`.replace(
				`{${"courseId"}}`,
				encodeURIComponent(String(courseId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} courseId The id of the course
		 * @param {'1.1.0' | '1.3.0'} version The version of CC export
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseControllerExportCourse(
			courseId: string,
			version: "1.1.0" | "1.3.0",
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.courseControllerExportCourse(
					courseId,
					version,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseControllerFindForUser(
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CourseMetadataListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.courseControllerFindForUser(
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} courseId The id of the course
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async courseControllerGetCourse(
			courseId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.courseControllerGetCourse(
					courseId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CoursesApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} courseId The id of the course
		 * @param {'1.1.0' | '1.3.0'} version The version of CC export
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseControllerExportCourse(
			courseId: string,
			version: "1.1.0" | "1.3.0",
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.courseControllerExportCourse(courseId, version, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseControllerFindForUser(
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<CourseMetadataListResponse> {
			return localVarFp
				.courseControllerFindForUser(skip, limit, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} courseId The id of the course
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		courseControllerGetCourse(
			courseId: string,
			options?: any
		): AxiosPromise<CourseResponse> {
			return localVarFp
				.courseControllerGetCourse(courseId, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CoursesApi - interface
 * @export
 * @interface CoursesApi
 */
export interface CoursesApiInterface {
	/**
	 *
	 * @param {string} courseId The id of the course
	 * @param {'1.1.0' | '1.3.0'} version The version of CC export
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoursesApiInterface
	 */
	courseControllerExportCourse(
		courseId: string,
		version: "1.1.0" | "1.3.0",
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoursesApiInterface
	 */
	courseControllerFindForUser(
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<CourseMetadataListResponse>;

	/**
	 *
	 * @param {string} courseId The id of the course
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoursesApiInterface
	 */
	courseControllerGetCourse(
		courseId: string,
		options?: any
	): AxiosPromise<CourseResponse>;
}

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI implements CoursesApiInterface {
	/**
	 *
	 * @param {string} courseId The id of the course
	 * @param {'1.1.0' | '1.3.0'} version The version of CC export
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoursesApi
	 */
	public courseControllerExportCourse(
		courseId: string,
		version: "1.1.0" | "1.3.0",
		options?: any
	) {
		return CoursesApiFp(this.configuration)
			.courseControllerExportCourse(courseId, version, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoursesApi
	 */
	public courseControllerFindForUser(
		skip?: number,
		limit?: number,
		options?: any
	) {
		return CoursesApiFp(this.configuration)
			.courseControllerFindForUser(skip, limit, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} courseId The id of the course
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoursesApi
	 */
	public courseControllerGetCourse(courseId: string, options?: any) {
		return CoursesApiFp(this.configuration)
			.courseControllerGetCourse(courseId, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		dashboardControllerFindForUser: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/dashboard`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} dashboardId The id of the dashboard.
		 * @param {MoveElementParams} moveElementParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		dashboardControllerMoveElement: async (
			dashboardId: string,
			moveElementParams: MoveElementParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'dashboardId' is not null or undefined
			assertParamExists(
				"dashboardControllerMoveElement",
				"dashboardId",
				dashboardId
			);
			// verify required parameter 'moveElementParams' is not null or undefined
			assertParamExists(
				"dashboardControllerMoveElement",
				"moveElementParams",
				moveElementParams
			);
			const localVarPath = `/dashboard/{dashboardId}/moveElement`.replace(
				`{${"dashboardId"}}`,
				encodeURIComponent(String(dashboardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				moveElementParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} dashboardId The id of the dashboard.
		 * @param {number} x
		 * @param {number} y
		 * @param {PatchGroupParams} patchGroupParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		dashboardControllerPatchGroup: async (
			dashboardId: string,
			x: number,
			y: number,
			patchGroupParams: PatchGroupParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'dashboardId' is not null or undefined
			assertParamExists(
				"dashboardControllerPatchGroup",
				"dashboardId",
				dashboardId
			);
			// verify required parameter 'x' is not null or undefined
			assertParamExists("dashboardControllerPatchGroup", "x", x);
			// verify required parameter 'y' is not null or undefined
			assertParamExists("dashboardControllerPatchGroup", "y", y);
			// verify required parameter 'patchGroupParams' is not null or undefined
			assertParamExists(
				"dashboardControllerPatchGroup",
				"patchGroupParams",
				patchGroupParams
			);
			const localVarPath = `/dashboard/{dashboardId}/element`.replace(
				`{${"dashboardId"}}`,
				encodeURIComponent(String(dashboardId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (x !== undefined) {
				localVarQueryParameter["x"] = x;
			}

			if (y !== undefined) {
				localVarQueryParameter["y"] = y;
			}

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchGroupParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		DashboardApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async dashboardControllerFindForUser(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<DashboardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.dashboardControllerFindForUser(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} dashboardId The id of the dashboard.
		 * @param {MoveElementParams} moveElementParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async dashboardControllerMoveElement(
			dashboardId: string,
			moveElementParams: MoveElementParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<DashboardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.dashboardControllerMoveElement(
					dashboardId,
					moveElementParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} dashboardId The id of the dashboard.
		 * @param {number} x
		 * @param {number} y
		 * @param {PatchGroupParams} patchGroupParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async dashboardControllerPatchGroup(
			dashboardId: string,
			x: number,
			y: number,
			patchGroupParams: PatchGroupParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<DashboardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.dashboardControllerPatchGroup(
					dashboardId,
					x,
					y,
					patchGroupParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = DashboardApiFp(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		dashboardControllerFindForUser(
			options?: any
		): AxiosPromise<DashboardResponse> {
			return localVarFp
				.dashboardControllerFindForUser(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} dashboardId The id of the dashboard.
		 * @param {MoveElementParams} moveElementParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		dashboardControllerMoveElement(
			dashboardId: string,
			moveElementParams: MoveElementParams,
			options?: any
		): AxiosPromise<DashboardResponse> {
			return localVarFp
				.dashboardControllerMoveElement(dashboardId, moveElementParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} dashboardId The id of the dashboard.
		 * @param {number} x
		 * @param {number} y
		 * @param {PatchGroupParams} patchGroupParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		dashboardControllerPatchGroup(
			dashboardId: string,
			x: number,
			y: number,
			patchGroupParams: PatchGroupParams,
			options?: any
		): AxiosPromise<DashboardResponse> {
			return localVarFp
				.dashboardControllerPatchGroup(
					dashboardId,
					x,
					y,
					patchGroupParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * DashboardApi - interface
 * @export
 * @interface DashboardApi
 */
export interface DashboardApiInterface {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DashboardApiInterface
	 */
	dashboardControllerFindForUser(
		options?: any
	): AxiosPromise<DashboardResponse>;

	/**
	 *
	 * @param {string} dashboardId The id of the dashboard.
	 * @param {MoveElementParams} moveElementParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DashboardApiInterface
	 */
	dashboardControllerMoveElement(
		dashboardId: string,
		moveElementParams: MoveElementParams,
		options?: any
	): AxiosPromise<DashboardResponse>;

	/**
	 *
	 * @param {string} dashboardId The id of the dashboard.
	 * @param {number} x
	 * @param {number} y
	 * @param {PatchGroupParams} patchGroupParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DashboardApiInterface
	 */
	dashboardControllerPatchGroup(
		dashboardId: string,
		x: number,
		y: number,
		patchGroupParams: PatchGroupParams,
		options?: any
	): AxiosPromise<DashboardResponse>;
}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI implements DashboardApiInterface {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DashboardApi
	 */
	public dashboardControllerFindForUser(options?: any) {
		return DashboardApiFp(this.configuration)
			.dashboardControllerFindForUser(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} dashboardId The id of the dashboard.
	 * @param {MoveElementParams} moveElementParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DashboardApi
	 */
	public dashboardControllerMoveElement(
		dashboardId: string,
		moveElementParams: MoveElementParams,
		options?: any
	) {
		return DashboardApiFp(this.configuration)
			.dashboardControllerMoveElement(dashboardId, moveElementParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} dashboardId The id of the dashboard.
	 * @param {number} x
	 * @param {number} y
	 * @param {PatchGroupParams} patchGroupParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DashboardApi
	 */
	public dashboardControllerPatchGroup(
		dashboardId: string,
		x: number,
		y: number,
		patchGroupParams: PatchGroupParams,
		options?: any
	) {
		return DashboardApiFp(this.configuration)
			.dashboardControllerPatchGroup(
				dashboardId,
				x,
				y,
				patchGroupParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * default route to test public access
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		serverControllerGetHello: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
	return {
		/**
		 * default route to test public access
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async serverControllerGetHello(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.serverControllerGetHello(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = DefaultApiFp(configuration);
	return {
		/**
		 * default route to test public access
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		serverControllerGetHello(options?: any): AxiosPromise<string> {
			return localVarFp
				.serverControllerGetHello(options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
	/**
	 * default route to test public access
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApiInterface
	 */
	serverControllerGetHello(options?: any): AxiosPromise<string>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
	/**
	 * default route to test public access
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public serverControllerGetHello(options?: any) {
		return DefaultApiFp(this.configuration)
			.serverControllerGetHello(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * LessonApi - axios parameter creator
 * @export
 */
export const LessonApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} lessonId The id of the lesson.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		lessonControllerDelete: async (
			lessonId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'lessonId' is not null or undefined
			assertParamExists("lessonControllerDelete", "lessonId", lessonId);
			const localVarPath = `/lessons/{lessonId}`.replace(
				`{${"lessonId"}}`,
				encodeURIComponent(String(lessonId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * LessonApi - functional programming interface
 * @export
 */
export const LessonApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = LessonApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} lessonId The id of the lesson.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async lessonControllerDelete(
			lessonId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.lessonControllerDelete(
					lessonId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * LessonApi - factory interface
 * @export
 */
export const LessonApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = LessonApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} lessonId The id of the lesson.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		lessonControllerDelete(
			lessonId: string,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.lessonControllerDelete(lessonId, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * LessonApi - interface
 * @export
 * @interface LessonApi
 */
export interface LessonApiInterface {
	/**
	 *
	 * @param {string} lessonId The id of the lesson.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LessonApiInterface
	 */
	lessonControllerDelete(
		lessonId: string,
		options?: any
	): AxiosPromise<boolean>;
}

/**
 * LessonApi - object-oriented interface
 * @export
 * @class LessonApi
 * @extends {BaseAPI}
 */
export class LessonApi extends BaseAPI implements LessonApiInterface {
	/**
	 *
	 * @param {string} lessonId The id of the lesson.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LessonApi
	 */
	public lessonControllerDelete(lessonId: string, options?: any) {
		return LessonApiFp(this.configuration)
			.lessonControllerDelete(lessonId, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * NewsApi - axios parameter creator
 * @export
 */
export const NewsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Create a news by a user in a given scope (school or team).
		 * @param {CreateNewsParams} createNewsParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerCreate: async (
			createNewsParams: CreateNewsParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createNewsParams' is not null or undefined
			assertParamExists(
				"newsControllerCreate",
				"createNewsParams",
				createNewsParams
			);
			const localVarPath = `/news`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				createNewsParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Delete a news.
		 * @param {string} newsId The id of the news.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerDelete: async (
			newsId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'newsId' is not null or undefined
			assertParamExists("newsControllerDelete", "newsId", newsId);
			const localVarPath = `/news/{newsId}`.replace(
				`{${"newsId"}}`,
				encodeURIComponent(String(newsId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Responds with all news for a user.
		 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
		 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
		 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerFindAll: async (
			targetModel?: "schools" | "courses" | "teams",
			targetId?: string,
			unpublished?: boolean,
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/news`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (targetModel !== undefined) {
				localVarQueryParameter["targetModel"] = targetModel;
			}

			if (targetId !== undefined) {
				localVarQueryParameter["targetId"] = targetId;
			}

			if (unpublished !== undefined) {
				localVarQueryParameter["unpublished"] = unpublished;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
		 * @param {string} newsId The id of the news.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerFindOne: async (
			newsId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'newsId' is not null or undefined
			assertParamExists("newsControllerFindOne", "newsId", newsId);
			const localVarPath = `/news/{newsId}`.replace(
				`{${"newsId"}}`,
				encodeURIComponent(String(newsId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Update properties of a news.
		 * @param {string} newsId The id of the news.
		 * @param {UpdateNewsParams} updateNewsParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerUpdate: async (
			newsId: string,
			updateNewsParams: UpdateNewsParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'newsId' is not null or undefined
			assertParamExists("newsControllerUpdate", "newsId", newsId);
			// verify required parameter 'updateNewsParams' is not null or undefined
			assertParamExists(
				"newsControllerUpdate",
				"updateNewsParams",
				updateNewsParams
			);
			const localVarPath = `/news/{newsId}`.replace(
				`{${"newsId"}}`,
				encodeURIComponent(String(newsId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateNewsParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Responds with news of a given team for a user.
		 * @param {string} teamId The id of the team.
		 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
		 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
		 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		teamNewsControllerFindAllForTeam: async (
			teamId: string,
			targetModel?: "schools" | "courses" | "teams",
			targetId?: string,
			unpublished?: boolean,
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamId' is not null or undefined
			assertParamExists("teamNewsControllerFindAllForTeam", "teamId", teamId);
			const localVarPath = `/team/{teamId}/news`.replace(
				`{${"teamId"}}`,
				encodeURIComponent(String(teamId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (targetModel !== undefined) {
				localVarQueryParameter["targetModel"] = targetModel;
			}

			if (targetId !== undefined) {
				localVarQueryParameter["targetId"] = targetId;
			}

			if (unpublished !== undefined) {
				localVarQueryParameter["unpublished"] = unpublished;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * NewsApi - functional programming interface
 * @export
 */
export const NewsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = NewsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Create a news by a user in a given scope (school or team).
		 * @param {CreateNewsParams} createNewsParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async newsControllerCreate(
			createNewsParams: CreateNewsParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.newsControllerCreate(
					createNewsParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Delete a news.
		 * @param {string} newsId The id of the news.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async newsControllerDelete(
			newsId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.newsControllerDelete(newsId, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Responds with all news for a user.
		 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
		 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
		 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async newsControllerFindAll(
			targetModel?: "schools" | "courses" | "teams",
			targetId?: string,
			unpublished?: boolean,
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<NewsListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.newsControllerFindAll(
					targetModel,
					targetId,
					unpublished,
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
		 * @param {string} newsId The id of the news.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async newsControllerFindOne(
			newsId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.newsControllerFindOne(newsId, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Update properties of a news.
		 * @param {string} newsId The id of the news.
		 * @param {UpdateNewsParams} updateNewsParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async newsControllerUpdate(
			newsId: string,
			updateNewsParams: UpdateNewsParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.newsControllerUpdate(
					newsId,
					updateNewsParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Responds with news of a given team for a user.
		 * @param {string} teamId The id of the team.
		 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
		 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
		 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async teamNewsControllerFindAllForTeam(
			teamId: string,
			targetModel?: "schools" | "courses" | "teams",
			targetId?: string,
			unpublished?: boolean,
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<NewsListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.teamNewsControllerFindAllForTeam(
					teamId,
					targetModel,
					targetId,
					unpublished,
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * NewsApi - factory interface
 * @export
 */
export const NewsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = NewsApiFp(configuration);
	return {
		/**
		 * Create a news by a user in a given scope (school or team).
		 * @param {CreateNewsParams} createNewsParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerCreate(
			createNewsParams: CreateNewsParams,
			options?: any
		): AxiosPromise<NewsResponse> {
			return localVarFp
				.newsControllerCreate(createNewsParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Delete a news.
		 * @param {string} newsId The id of the news.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerDelete(newsId: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.newsControllerDelete(newsId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Responds with all news for a user.
		 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
		 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
		 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerFindAll(
			targetModel?: "schools" | "courses" | "teams",
			targetId?: string,
			unpublished?: boolean,
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<NewsListResponse> {
			return localVarFp
				.newsControllerFindAll(
					targetModel,
					targetId,
					unpublished,
					skip,
					limit,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
		 * @param {string} newsId The id of the news.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerFindOne(
			newsId: string,
			options?: any
		): AxiosPromise<NewsResponse> {
			return localVarFp
				.newsControllerFindOne(newsId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Update properties of a news.
		 * @param {string} newsId The id of the news.
		 * @param {UpdateNewsParams} updateNewsParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newsControllerUpdate(
			newsId: string,
			updateNewsParams: UpdateNewsParams,
			options?: any
		): AxiosPromise<NewsResponse> {
			return localVarFp
				.newsControllerUpdate(newsId, updateNewsParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Responds with news of a given team for a user.
		 * @param {string} teamId The id of the team.
		 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
		 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
		 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		teamNewsControllerFindAllForTeam(
			teamId: string,
			targetModel?: "schools" | "courses" | "teams",
			targetId?: string,
			unpublished?: boolean,
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<NewsListResponse> {
			return localVarFp
				.teamNewsControllerFindAllForTeam(
					teamId,
					targetModel,
					targetId,
					unpublished,
					skip,
					limit,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * NewsApi - interface
 * @export
 * @interface NewsApi
 */
export interface NewsApiInterface {
	/**
	 * Create a news by a user in a given scope (school or team).
	 * @param {CreateNewsParams} createNewsParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApiInterface
	 */
	newsControllerCreate(
		createNewsParams: CreateNewsParams,
		options?: any
	): AxiosPromise<NewsResponse>;

	/**
	 * Delete a news.
	 * @param {string} newsId The id of the news.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApiInterface
	 */
	newsControllerDelete(newsId: string, options?: any): AxiosPromise<string>;

	/**
	 * Responds with all news for a user.
	 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
	 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
	 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApiInterface
	 */
	newsControllerFindAll(
		targetModel?: "schools" | "courses" | "teams",
		targetId?: string,
		unpublished?: boolean,
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<NewsListResponse>;

	/**
	 * Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
	 * @param {string} newsId The id of the news.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApiInterface
	 */
	newsControllerFindOne(
		newsId: string,
		options?: any
	): AxiosPromise<NewsResponse>;

	/**
	 * Update properties of a news.
	 * @param {string} newsId The id of the news.
	 * @param {UpdateNewsParams} updateNewsParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApiInterface
	 */
	newsControllerUpdate(
		newsId: string,
		updateNewsParams: UpdateNewsParams,
		options?: any
	): AxiosPromise<NewsResponse>;

	/**
	 * Responds with news of a given team for a user.
	 * @param {string} teamId The id of the team.
	 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
	 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
	 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApiInterface
	 */
	teamNewsControllerFindAllForTeam(
		teamId: string,
		targetModel?: "schools" | "courses" | "teams",
		targetId?: string,
		unpublished?: boolean,
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<NewsListResponse>;
}

/**
 * NewsApi - object-oriented interface
 * @export
 * @class NewsApi
 * @extends {BaseAPI}
 */
export class NewsApi extends BaseAPI implements NewsApiInterface {
	/**
	 * Create a news by a user in a given scope (school or team).
	 * @param {CreateNewsParams} createNewsParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApi
	 */
	public newsControllerCreate(
		createNewsParams: CreateNewsParams,
		options?: any
	) {
		return NewsApiFp(this.configuration)
			.newsControllerCreate(createNewsParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Delete a news.
	 * @param {string} newsId The id of the news.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApi
	 */
	public newsControllerDelete(newsId: string, options?: any) {
		return NewsApiFp(this.configuration)
			.newsControllerDelete(newsId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Responds with all news for a user.
	 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
	 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
	 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApi
	 */
	public newsControllerFindAll(
		targetModel?: "schools" | "courses" | "teams",
		targetId?: string,
		unpublished?: boolean,
		skip?: number,
		limit?: number,
		options?: any
	) {
		return NewsApiFp(this.configuration)
			.newsControllerFindAll(
				targetModel,
				targetId,
				unpublished,
				skip,
				limit,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
	 * @param {string} newsId The id of the news.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApi
	 */
	public newsControllerFindOne(newsId: string, options?: any) {
		return NewsApiFp(this.configuration)
			.newsControllerFindOne(newsId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Update properties of a news.
	 * @param {string} newsId The id of the news.
	 * @param {UpdateNewsParams} updateNewsParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApi
	 */
	public newsControllerUpdate(
		newsId: string,
		updateNewsParams: UpdateNewsParams,
		options?: any
	) {
		return NewsApiFp(this.configuration)
			.newsControllerUpdate(newsId, updateNewsParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Responds with news of a given team for a user.
	 * @param {string} teamId The id of the team.
	 * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
	 * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
	 * @param {boolean} [unpublished] Flag that filters if the news should be published or not
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof NewsApi
	 */
	public teamNewsControllerFindAllForTeam(
		teamId: string,
		targetModel?: "schools" | "courses" | "teams",
		targetId?: string,
		unpublished?: boolean,
		skip?: number,
		limit?: number,
		options?: any
	) {
		return NewsApiFp(this.configuration)
			.teamNewsControllerFindAllForTeam(
				teamId,
				targetModel,
				targetId,
				unpublished,
				skip,
				limit,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * Oauth2Api - axios parameter creator
 * @export
 */
export const Oauth2ApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerAcceptLogoutRequest: async (
			challenge: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'challenge' is not null or undefined
			assertParamExists(
				"oauthProviderControllerAcceptLogoutRequest",
				"challenge",
				challenge
			);
			const localVarPath = `/oauth2/logoutRequest/{challenge}`.replace(
				`{${"challenge"}}`,
				encodeURIComponent(String(challenge))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {OauthClientBody} oauthClientBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerCreateOAuth2Client: async (
			oauthClientBody: OauthClientBody,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'oauthClientBody' is not null or undefined
			assertParamExists(
				"oauthProviderControllerCreateOAuth2Client",
				"oauthClientBody",
				oauthClientBody
			);
			const localVarPath = `/oauth2/clients`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				oauthClientBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerDeleteOAuth2Client: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("oauthProviderControllerDeleteOAuth2Client", "id", id);
			const localVarPath = `/oauth2/clients/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetConsentRequest: async (
			challenge: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'challenge' is not null or undefined
			assertParamExists(
				"oauthProviderControllerGetConsentRequest",
				"challenge",
				challenge
			);
			const localVarPath = `/oauth2/consentRequest/{challenge}`.replace(
				`{${"challenge"}}`,
				encodeURIComponent(String(challenge))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetLoginRequest: async (
			challenge: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'challenge' is not null or undefined
			assertParamExists(
				"oauthProviderControllerGetLoginRequest",
				"challenge",
				challenge
			);
			const localVarPath = `/oauth2/loginRequest/{challenge}`.replace(
				`{${"challenge"}}`,
				encodeURIComponent(String(challenge))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetOAuth2Client: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("oauthProviderControllerGetOAuth2Client", "id", id);
			const localVarPath = `/oauth2/clients/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetUrl: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/oauth2/baseUrl`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerListConsentSessions: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/oauth2/auth/sessions/consent`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
		 * @param {number} offset The offset from where to start looking.
		 * @param {string} clientName The name of the clients to filter by.
		 * @param {string} owner The owner of the clients to filter by.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerListOAuth2Clients: async (
			limit: number,
			offset: number,
			clientName: string,
			owner: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'limit' is not null or undefined
			assertParamExists(
				"oauthProviderControllerListOAuth2Clients",
				"limit",
				limit
			);
			// verify required parameter 'offset' is not null or undefined
			assertParamExists(
				"oauthProviderControllerListOAuth2Clients",
				"offset",
				offset
			);
			// verify required parameter 'clientName' is not null or undefined
			assertParamExists(
				"oauthProviderControllerListOAuth2Clients",
				"clientName",
				clientName
			);
			// verify required parameter 'owner' is not null or undefined
			assertParamExists(
				"oauthProviderControllerListOAuth2Clients",
				"owner",
				owner
			);
			const localVarPath = `/oauth2/clients`
				.replace(`{${"limit"}}`, encodeURIComponent(String(limit)))
				.replace(`{${"offset"}}`, encodeURIComponent(String(offset)))
				.replace(`{${"client_name"}}`, encodeURIComponent(String(clientName)))
				.replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {ConsentRequestBody} consentRequestBody
		 * @param {boolean} [accept] Accepts the login request.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerPatchConsentRequest: async (
			challenge: string,
			consentRequestBody: ConsentRequestBody,
			accept?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'challenge' is not null or undefined
			assertParamExists(
				"oauthProviderControllerPatchConsentRequest",
				"challenge",
				challenge
			);
			// verify required parameter 'consentRequestBody' is not null or undefined
			assertParamExists(
				"oauthProviderControllerPatchConsentRequest",
				"consentRequestBody",
				consentRequestBody
			);
			const localVarPath = `/oauth2/consentRequest/{challenge}`.replace(
				`{${"challenge"}}`,
				encodeURIComponent(String(challenge))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (accept !== undefined) {
				localVarQueryParameter["accept"] = accept;
			}

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				consentRequestBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {LoginRequestBody} loginRequestBody
		 * @param {boolean} [accept] Accepts the login request.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerPatchLoginRequest: async (
			challenge: string,
			loginRequestBody: LoginRequestBody,
			accept?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'challenge' is not null or undefined
			assertParamExists(
				"oauthProviderControllerPatchLoginRequest",
				"challenge",
				challenge
			);
			// verify required parameter 'loginRequestBody' is not null or undefined
			assertParamExists(
				"oauthProviderControllerPatchLoginRequest",
				"loginRequestBody",
				loginRequestBody
			);
			const localVarPath = `/oauth2/loginRequest/{challenge}`.replace(
				`{${"challenge"}}`,
				encodeURIComponent(String(challenge))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (accept !== undefined) {
				localVarQueryParameter["accept"] = accept;
			}

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				loginRequestBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} client The Oauth2 client id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerRevokeConsentSession: async (
			client: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'client' is not null or undefined
			assertParamExists(
				"oauthProviderControllerRevokeConsentSession",
				"client",
				client
			);
			const localVarPath = `/oauth2/auth/sessions/consent`.replace(
				`{${"client"}}`,
				encodeURIComponent(String(client))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {OauthClientBody} oauthClientBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerUpdateOAuth2Client: async (
			id: string,
			oauthClientBody: OauthClientBody,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists("oauthProviderControllerUpdateOAuth2Client", "id", id);
			// verify required parameter 'oauthClientBody' is not null or undefined
			assertParamExists(
				"oauthProviderControllerUpdateOAuth2Client",
				"oauthClientBody",
				oauthClientBody
			);
			const localVarPath = `/oauth2/clients/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				oauthClientBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * Oauth2Api - functional programming interface
 * @export
 */
export const Oauth2ApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = Oauth2ApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerAcceptLogoutRequest(
			challenge: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<RedirectResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerAcceptLogoutRequest(
					challenge,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {OauthClientBody} oauthClientBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerCreateOAuth2Client(
			oauthClientBody: OauthClientBody,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<OauthClientResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerCreateOAuth2Client(
					oauthClientBody,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerDeleteOAuth2Client(
			id: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerDeleteOAuth2Client(
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerGetConsentRequest(
			challenge: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ConsentResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerGetConsentRequest(
					challenge,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerGetLoginRequest(
			challenge: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerGetLoginRequest(
					challenge,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerGetOAuth2Client(
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<OauthClientResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerGetOAuth2Client(
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerGetUrl(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerGetUrl(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerListConsentSessions(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<ConsentSessionResponse>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerListConsentSessions(
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
		 * @param {number} offset The offset from where to start looking.
		 * @param {string} clientName The name of the clients to filter by.
		 * @param {string} owner The owner of the clients to filter by.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerListOAuth2Clients(
			limit: number,
			offset: number,
			clientName: string,
			owner: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<OauthClientResponse>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerListOAuth2Clients(
					limit,
					offset,
					clientName,
					owner,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {ConsentRequestBody} consentRequestBody
		 * @param {boolean} [accept] Accepts the login request.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerPatchConsentRequest(
			challenge: string,
			consentRequestBody: ConsentRequestBody,
			accept?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<RedirectResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerPatchConsentRequest(
					challenge,
					consentRequestBody,
					accept,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {LoginRequestBody} loginRequestBody
		 * @param {boolean} [accept] Accepts the login request.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerPatchLoginRequest(
			challenge: string,
			loginRequestBody: LoginRequestBody,
			accept?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<RedirectResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerPatchLoginRequest(
					challenge,
					loginRequestBody,
					accept,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} client The Oauth2 client id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerRevokeConsentSession(
			client: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerRevokeConsentSession(
					client,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {OauthClientBody} oauthClientBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthProviderControllerUpdateOAuth2Client(
			id: string,
			oauthClientBody: OauthClientBody,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<OauthClientResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthProviderControllerUpdateOAuth2Client(
					id,
					oauthClientBody,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * Oauth2Api - factory interface
 * @export
 */
export const Oauth2ApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = Oauth2ApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerAcceptLogoutRequest(
			challenge: string,
			options?: any
		): AxiosPromise<RedirectResponse> {
			return localVarFp
				.oauthProviderControllerAcceptLogoutRequest(challenge, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {OauthClientBody} oauthClientBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerCreateOAuth2Client(
			oauthClientBody: OauthClientBody,
			options?: any
		): AxiosPromise<OauthClientResponse> {
			return localVarFp
				.oauthProviderControllerCreateOAuth2Client(oauthClientBody, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerDeleteOAuth2Client(
			id: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.oauthProviderControllerDeleteOAuth2Client(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetConsentRequest(
			challenge: string,
			options?: any
		): AxiosPromise<ConsentResponse> {
			return localVarFp
				.oauthProviderControllerGetConsentRequest(challenge, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetLoginRequest(
			challenge: string,
			options?: any
		): AxiosPromise<LoginResponse> {
			return localVarFp
				.oauthProviderControllerGetLoginRequest(challenge, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetOAuth2Client(
			id: string,
			options?: any
		): AxiosPromise<OauthClientResponse> {
			return localVarFp
				.oauthProviderControllerGetOAuth2Client(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerGetUrl(options?: any): AxiosPromise<string> {
			return localVarFp
				.oauthProviderControllerGetUrl(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerListConsentSessions(
			options?: any
		): AxiosPromise<Array<ConsentSessionResponse>> {
			return localVarFp
				.oauthProviderControllerListConsentSessions(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
		 * @param {number} offset The offset from where to start looking.
		 * @param {string} clientName The name of the clients to filter by.
		 * @param {string} owner The owner of the clients to filter by.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerListOAuth2Clients(
			limit: number,
			offset: number,
			clientName: string,
			owner: string,
			options?: any
		): AxiosPromise<Array<OauthClientResponse>> {
			return localVarFp
				.oauthProviderControllerListOAuth2Clients(
					limit,
					offset,
					clientName,
					owner,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {ConsentRequestBody} consentRequestBody
		 * @param {boolean} [accept] Accepts the login request.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerPatchConsentRequest(
			challenge: string,
			consentRequestBody: ConsentRequestBody,
			accept?: boolean,
			options?: any
		): AxiosPromise<RedirectResponse> {
			return localVarFp
				.oauthProviderControllerPatchConsentRequest(
					challenge,
					consentRequestBody,
					accept,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} challenge The login challenge.
		 * @param {LoginRequestBody} loginRequestBody
		 * @param {boolean} [accept] Accepts the login request.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerPatchLoginRequest(
			challenge: string,
			loginRequestBody: LoginRequestBody,
			accept?: boolean,
			options?: any
		): AxiosPromise<RedirectResponse> {
			return localVarFp
				.oauthProviderControllerPatchLoginRequest(
					challenge,
					loginRequestBody,
					accept,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} client The Oauth2 client id.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerRevokeConsentSession(
			client: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.oauthProviderControllerRevokeConsentSession(client, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id The Oauth Client Id.
		 * @param {OauthClientBody} oauthClientBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthProviderControllerUpdateOAuth2Client(
			id: string,
			oauthClientBody: OauthClientBody,
			options?: any
		): AxiosPromise<OauthClientResponse> {
			return localVarFp
				.oauthProviderControllerUpdateOAuth2Client(id, oauthClientBody, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * Oauth2Api - interface
 * @export
 * @interface Oauth2Api
 */
export interface Oauth2ApiInterface {
	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerAcceptLogoutRequest(
		challenge: string,
		options?: any
	): AxiosPromise<RedirectResponse>;

	/**
	 *
	 * @param {OauthClientBody} oauthClientBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerCreateOAuth2Client(
		oauthClientBody: OauthClientBody,
		options?: any
	): AxiosPromise<OauthClientResponse>;

	/**
	 *
	 * @param {string} id The Oauth Client Id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerDeleteOAuth2Client(
		id: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerGetConsentRequest(
		challenge: string,
		options?: any
	): AxiosPromise<ConsentResponse>;

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerGetLoginRequest(
		challenge: string,
		options?: any
	): AxiosPromise<LoginResponse>;

	/**
	 *
	 * @param {string} id The Oauth Client Id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerGetOAuth2Client(
		id: string,
		options?: any
	): AxiosPromise<OauthClientResponse>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerGetUrl(options?: any): AxiosPromise<string>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerListConsentSessions(
		options?: any
	): AxiosPromise<Array<ConsentSessionResponse>>;

	/**
	 *
	 * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
	 * @param {number} offset The offset from where to start looking.
	 * @param {string} clientName The name of the clients to filter by.
	 * @param {string} owner The owner of the clients to filter by.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerListOAuth2Clients(
		limit: number,
		offset: number,
		clientName: string,
		owner: string,
		options?: any
	): AxiosPromise<Array<OauthClientResponse>>;

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {ConsentRequestBody} consentRequestBody
	 * @param {boolean} [accept] Accepts the login request.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerPatchConsentRequest(
		challenge: string,
		consentRequestBody: ConsentRequestBody,
		accept?: boolean,
		options?: any
	): AxiosPromise<RedirectResponse>;

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {LoginRequestBody} loginRequestBody
	 * @param {boolean} [accept] Accepts the login request.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerPatchLoginRequest(
		challenge: string,
		loginRequestBody: LoginRequestBody,
		accept?: boolean,
		options?: any
	): AxiosPromise<RedirectResponse>;

	/**
	 *
	 * @param {string} client The Oauth2 client id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerRevokeConsentSession(
		client: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} id The Oauth Client Id.
	 * @param {OauthClientBody} oauthClientBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2ApiInterface
	 */
	oauthProviderControllerUpdateOAuth2Client(
		id: string,
		oauthClientBody: OauthClientBody,
		options?: any
	): AxiosPromise<OauthClientResponse>;
}

/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
export class Oauth2Api extends BaseAPI implements Oauth2ApiInterface {
	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerAcceptLogoutRequest(
		challenge: string,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerAcceptLogoutRequest(challenge, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {OauthClientBody} oauthClientBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerCreateOAuth2Client(
		oauthClientBody: OauthClientBody,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerCreateOAuth2Client(oauthClientBody, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id The Oauth Client Id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerDeleteOAuth2Client(id: string, options?: any) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerDeleteOAuth2Client(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerGetConsentRequest(
		challenge: string,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerGetConsentRequest(challenge, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerGetLoginRequest(
		challenge: string,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerGetLoginRequest(challenge, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id The Oauth Client Id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerGetOAuth2Client(id: string, options?: any) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerGetOAuth2Client(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerGetUrl(options?: any) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerGetUrl(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerListConsentSessions(options?: any) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerListConsentSessions(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
	 * @param {number} offset The offset from where to start looking.
	 * @param {string} clientName The name of the clients to filter by.
	 * @param {string} owner The owner of the clients to filter by.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerListOAuth2Clients(
		limit: number,
		offset: number,
		clientName: string,
		owner: string,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerListOAuth2Clients(
				limit,
				offset,
				clientName,
				owner,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {ConsentRequestBody} consentRequestBody
	 * @param {boolean} [accept] Accepts the login request.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerPatchConsentRequest(
		challenge: string,
		consentRequestBody: ConsentRequestBody,
		accept?: boolean,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerPatchConsentRequest(
				challenge,
				consentRequestBody,
				accept,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} challenge The login challenge.
	 * @param {LoginRequestBody} loginRequestBody
	 * @param {boolean} [accept] Accepts the login request.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerPatchLoginRequest(
		challenge: string,
		loginRequestBody: LoginRequestBody,
		accept?: boolean,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerPatchLoginRequest(
				challenge,
				loginRequestBody,
				accept,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} client The Oauth2 client id.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerRevokeConsentSession(
		client: string,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerRevokeConsentSession(client, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id The Oauth Client Id.
	 * @param {OauthClientBody} oauthClientBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof Oauth2Api
	 */
	public oauthProviderControllerUpdateOAuth2Client(
		id: string,
		oauthClientBody: OauthClientBody,
		options?: any
	) {
		return Oauth2ApiFp(this.configuration)
			.oauthProviderControllerUpdateOAuth2Client(id, oauthClientBody, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerCopyCourse: async (
			roomId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'roomId' is not null or undefined
			assertParamExists("roomsControllerCopyCourse", "roomId", roomId);
			const localVarPath = `/rooms/{roomId}/copy`.replace(
				`{${"roomId"}}`,
				encodeURIComponent(String(roomId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} lessonId The id of the lesson.
		 * @param {LessonCopyApiParams} lessonCopyApiParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerCopyLesson: async (
			lessonId: string,
			lessonCopyApiParams: LessonCopyApiParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'lessonId' is not null or undefined
			assertParamExists("roomsControllerCopyLesson", "lessonId", lessonId);
			// verify required parameter 'lessonCopyApiParams' is not null or undefined
			assertParamExists(
				"roomsControllerCopyLesson",
				"lessonCopyApiParams",
				lessonCopyApiParams
			);
			const localVarPath = `/rooms/lessons/{lessonId}/copy`.replace(
				`{${"lessonId"}}`,
				encodeURIComponent(String(lessonId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				lessonCopyApiParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerGetRoomBoard: async (
			roomId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'roomId' is not null or undefined
			assertParamExists("roomsControllerGetRoomBoard", "roomId", roomId);
			const localVarPath = `/rooms/{roomId}/board`.replace(
				`{${"roomId"}}`,
				encodeURIComponent(String(roomId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {string} elementId The id of the element within the room.
		 * @param {PatchVisibilityParams} patchVisibilityParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerPatchElementVisibility: async (
			roomId: string,
			elementId: string,
			patchVisibilityParams: PatchVisibilityParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'roomId' is not null or undefined
			assertParamExists(
				"roomsControllerPatchElementVisibility",
				"roomId",
				roomId
			);
			// verify required parameter 'elementId' is not null or undefined
			assertParamExists(
				"roomsControllerPatchElementVisibility",
				"elementId",
				elementId
			);
			// verify required parameter 'patchVisibilityParams' is not null or undefined
			assertParamExists(
				"roomsControllerPatchElementVisibility",
				"patchVisibilityParams",
				patchVisibilityParams
			);
			const localVarPath = `/rooms/{roomId}/elements/{elementId}/visibility`
				.replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
				.replace(`{${"elementId"}}`, encodeURIComponent(String(elementId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchVisibilityParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {PatchOrderParams} patchOrderParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerPatchOrderingOfElements: async (
			roomId: string,
			patchOrderParams: PatchOrderParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'roomId' is not null or undefined
			assertParamExists(
				"roomsControllerPatchOrderingOfElements",
				"roomId",
				roomId
			);
			// verify required parameter 'patchOrderParams' is not null or undefined
			assertParamExists(
				"roomsControllerPatchOrderingOfElements",
				"patchOrderParams",
				patchOrderParams
			);
			const localVarPath = `/rooms/{roomId}/board/order`.replace(
				`{${"roomId"}}`,
				encodeURIComponent(String(roomId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchOrderParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async roomsControllerCopyCourse(
			roomId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CopyApiResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.roomsControllerCopyCourse(
					roomId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} lessonId The id of the lesson.
		 * @param {LessonCopyApiParams} lessonCopyApiParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async roomsControllerCopyLesson(
			lessonId: string,
			lessonCopyApiParams: LessonCopyApiParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CopyApiResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.roomsControllerCopyLesson(
					lessonId,
					lessonCopyApiParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async roomsControllerGetRoomBoard(
			roomId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SingleColumnBoardResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.roomsControllerGetRoomBoard(
					roomId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {string} elementId The id of the element within the room.
		 * @param {PatchVisibilityParams} patchVisibilityParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async roomsControllerPatchElementVisibility(
			roomId: string,
			elementId: string,
			patchVisibilityParams: PatchVisibilityParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.roomsControllerPatchElementVisibility(
					roomId,
					elementId,
					patchVisibilityParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {PatchOrderParams} patchOrderParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async roomsControllerPatchOrderingOfElements(
			roomId: string,
			patchOrderParams: PatchOrderParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.roomsControllerPatchOrderingOfElements(
					roomId,
					patchOrderParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = RoomsApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerCopyCourse(
			roomId: string,
			options?: any
		): AxiosPromise<CopyApiResponse> {
			return localVarFp
				.roomsControllerCopyCourse(roomId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} lessonId The id of the lesson.
		 * @param {LessonCopyApiParams} lessonCopyApiParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerCopyLesson(
			lessonId: string,
			lessonCopyApiParams: LessonCopyApiParams,
			options?: any
		): AxiosPromise<CopyApiResponse> {
			return localVarFp
				.roomsControllerCopyLesson(lessonId, lessonCopyApiParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerGetRoomBoard(
			roomId: string,
			options?: any
		): AxiosPromise<SingleColumnBoardResponse> {
			return localVarFp
				.roomsControllerGetRoomBoard(roomId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {string} elementId The id of the element within the room.
		 * @param {PatchVisibilityParams} patchVisibilityParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerPatchElementVisibility(
			roomId: string,
			elementId: string,
			patchVisibilityParams: PatchVisibilityParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.roomsControllerPatchElementVisibility(
					roomId,
					elementId,
					patchVisibilityParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} roomId The id of the room.
		 * @param {PatchOrderParams} patchOrderParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		roomsControllerPatchOrderingOfElements(
			roomId: string,
			patchOrderParams: PatchOrderParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.roomsControllerPatchOrderingOfElements(
					roomId,
					patchOrderParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * RoomsApi - interface
 * @export
 * @interface RoomsApi
 */
export interface RoomsApiInterface {
	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApiInterface
	 */
	roomsControllerCopyCourse(
		roomId: string,
		options?: any
	): AxiosPromise<CopyApiResponse>;

	/**
	 *
	 * @param {string} lessonId The id of the lesson.
	 * @param {LessonCopyApiParams} lessonCopyApiParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApiInterface
	 */
	roomsControllerCopyLesson(
		lessonId: string,
		lessonCopyApiParams: LessonCopyApiParams,
		options?: any
	): AxiosPromise<CopyApiResponse>;

	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApiInterface
	 */
	roomsControllerGetRoomBoard(
		roomId: string,
		options?: any
	): AxiosPromise<SingleColumnBoardResponse>;

	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {string} elementId The id of the element within the room.
	 * @param {PatchVisibilityParams} patchVisibilityParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApiInterface
	 */
	roomsControllerPatchElementVisibility(
		roomId: string,
		elementId: string,
		patchVisibilityParams: PatchVisibilityParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {PatchOrderParams} patchOrderParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApiInterface
	 */
	roomsControllerPatchOrderingOfElements(
		roomId: string,
		patchOrderParams: PatchOrderParams,
		options?: any
	): AxiosPromise<void>;
}

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI implements RoomsApiInterface {
	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApi
	 */
	public roomsControllerCopyCourse(roomId: string, options?: any) {
		return RoomsApiFp(this.configuration)
			.roomsControllerCopyCourse(roomId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} lessonId The id of the lesson.
	 * @param {LessonCopyApiParams} lessonCopyApiParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApi
	 */
	public roomsControllerCopyLesson(
		lessonId: string,
		lessonCopyApiParams: LessonCopyApiParams,
		options?: any
	) {
		return RoomsApiFp(this.configuration)
			.roomsControllerCopyLesson(lessonId, lessonCopyApiParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApi
	 */
	public roomsControllerGetRoomBoard(roomId: string, options?: any) {
		return RoomsApiFp(this.configuration)
			.roomsControllerGetRoomBoard(roomId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {string} elementId The id of the element within the room.
	 * @param {PatchVisibilityParams} patchVisibilityParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApi
	 */
	public roomsControllerPatchElementVisibility(
		roomId: string,
		elementId: string,
		patchVisibilityParams: PatchVisibilityParams,
		options?: any
	) {
		return RoomsApiFp(this.configuration)
			.roomsControllerPatchElementVisibility(
				roomId,
				elementId,
				patchVisibilityParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} roomId The id of the room.
	 * @param {PatchOrderParams} patchOrderParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof RoomsApi
	 */
	public roomsControllerPatchOrderingOfElements(
		roomId: string,
		patchOrderParams: PatchOrderParams,
		options?: any
	) {
		return RoomsApiFp(this.configuration)
			.roomsControllerPatchOrderingOfElements(roomId, patchOrderParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * SSOApi - axios parameter creator
 * @export
 */
export const SSOApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} systemId The id of the system.
		 * @param {string} postLoginRedirect
		 * @param {boolean} migration
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerGetAuthenticationUrl: async (
			systemId: string,
			postLoginRedirect: string,
			migration: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'systemId' is not null or undefined
			assertParamExists(
				"oauthSSOControllerGetAuthenticationUrl",
				"systemId",
				systemId
			);
			// verify required parameter 'postLoginRedirect' is not null or undefined
			assertParamExists(
				"oauthSSOControllerGetAuthenticationUrl",
				"postLoginRedirect",
				postLoginRedirect
			);
			// verify required parameter 'migration' is not null or undefined
			assertParamExists(
				"oauthSSOControllerGetAuthenticationUrl",
				"migration",
				migration
			);
			const localVarPath = `/sso/login/{systemId}`.replace(
				`{${"systemId"}}`,
				encodeURIComponent(String(systemId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (postLoginRedirect !== undefined) {
				localVarQueryParameter["postLoginRedirect"] = postLoginRedirect;
			}

			if (migration !== undefined) {
				localVarQueryParameter["migration"] = migration;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} oauthClientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerGetHydraOauthToken: async (
			oauthClientId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'oauthClientId' is not null or undefined
			assertParamExists(
				"oauthSSOControllerGetHydraOauthToken",
				"oauthClientId",
				oauthClientId
			);
			const localVarPath = `/sso/hydra/{oauthClientId}`.replace(
				`{${"oauthClientId"}}`,
				encodeURIComponent(String(oauthClientId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerMigrateUser: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/sso/oauth/migration`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} oauthClientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerRequestAuthToken: async (
			oauthClientId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'oauthClientId' is not null or undefined
			assertParamExists(
				"oauthSSOControllerRequestAuthToken",
				"oauthClientId",
				oauthClientId
			);
			const localVarPath = `/sso/auth/{oauthClientId}`.replace(
				`{${"oauthClientId"}}`,
				encodeURIComponent(String(oauthClientId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerStartOauthAuthorizationCodeFlow: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/sso/oauth`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SSOApi - functional programming interface
 * @export
 */
export const SSOApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SSOApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} systemId The id of the system.
		 * @param {string} postLoginRedirect
		 * @param {boolean} migration
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthSSOControllerGetAuthenticationUrl(
			systemId: string,
			postLoginRedirect: string,
			migration: boolean,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthSSOControllerGetAuthenticationUrl(
					systemId,
					postLoginRedirect,
					migration,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} oauthClientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthSSOControllerGetHydraOauthToken(
			oauthClientId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthTokenDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthSSOControllerGetHydraOauthToken(
					oauthClientId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthSSOControllerMigrateUser(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthSSOControllerMigrateUser(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} oauthClientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthSSOControllerRequestAuthToken(
			oauthClientId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthSSOControllerRequestAuthToken(
					oauthClientId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async oauthSSOControllerStartOauthAuthorizationCodeFlow(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.oauthSSOControllerStartOauthAuthorizationCodeFlow(
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * SSOApi - factory interface
 * @export
 */
export const SSOApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SSOApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} systemId The id of the system.
		 * @param {string} postLoginRedirect
		 * @param {boolean} migration
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerGetAuthenticationUrl(
			systemId: string,
			postLoginRedirect: string,
			migration: boolean,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.oauthSSOControllerGetAuthenticationUrl(
					systemId,
					postLoginRedirect,
					migration,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} oauthClientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerGetHydraOauthToken(
			oauthClientId: string,
			options?: any
		): AxiosPromise<OAuthTokenDto> {
			return localVarFp
				.oauthSSOControllerGetHydraOauthToken(oauthClientId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerMigrateUser(options?: any): AxiosPromise<void> {
			return localVarFp
				.oauthSSOControllerMigrateUser(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} oauthClientId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerRequestAuthToken(
			oauthClientId: string,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.oauthSSOControllerRequestAuthToken(oauthClientId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		oauthSSOControllerStartOauthAuthorizationCodeFlow(
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.oauthSSOControllerStartOauthAuthorizationCodeFlow(options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * SSOApi - interface
 * @export
 * @interface SSOApi
 */
export interface SSOApiInterface {
	/**
	 *
	 * @param {string} systemId The id of the system.
	 * @param {string} postLoginRedirect
	 * @param {boolean} migration
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApiInterface
	 */
	oauthSSOControllerGetAuthenticationUrl(
		systemId: string,
		postLoginRedirect: string,
		migration: boolean,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} oauthClientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApiInterface
	 */
	oauthSSOControllerGetHydraOauthToken(
		oauthClientId: string,
		options?: any
	): AxiosPromise<OAuthTokenDto>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApiInterface
	 */
	oauthSSOControllerMigrateUser(options?: any): AxiosPromise<void>;

	/**
	 *
	 * @param {string} oauthClientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApiInterface
	 */
	oauthSSOControllerRequestAuthToken(
		oauthClientId: string,
		options?: any
	): AxiosPromise<object>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApiInterface
	 */
	oauthSSOControllerStartOauthAuthorizationCodeFlow(
		options?: any
	): AxiosPromise<void>;
}

/**
 * SSOApi - object-oriented interface
 * @export
 * @class SSOApi
 * @extends {BaseAPI}
 */
export class SSOApi extends BaseAPI implements SSOApiInterface {
	/**
	 *
	 * @param {string} systemId The id of the system.
	 * @param {string} postLoginRedirect
	 * @param {boolean} migration
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApi
	 */
	public oauthSSOControllerGetAuthenticationUrl(
		systemId: string,
		postLoginRedirect: string,
		migration: boolean,
		options?: any
	) {
		return SSOApiFp(this.configuration)
			.oauthSSOControllerGetAuthenticationUrl(
				systemId,
				postLoginRedirect,
				migration,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} oauthClientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApi
	 */
	public oauthSSOControllerGetHydraOauthToken(
		oauthClientId: string,
		options?: any
	) {
		return SSOApiFp(this.configuration)
			.oauthSSOControllerGetHydraOauthToken(oauthClientId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApi
	 */
	public oauthSSOControllerMigrateUser(options?: any) {
		return SSOApiFp(this.configuration)
			.oauthSSOControllerMigrateUser(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} oauthClientId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApi
	 */
	public oauthSSOControllerRequestAuthToken(
		oauthClientId: string,
		options?: any
	) {
		return SSOApiFp(this.configuration)
			.oauthSSOControllerRequestAuthToken(oauthClientId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SSOApi
	 */
	public oauthSSOControllerStartOauthAuthorizationCodeFlow(options?: any) {
		return SSOApiFp(this.configuration)
			.oauthSSOControllerStartOauthAuthorizationCodeFlow(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * SchoolApi - axios parameter creator
 * @export
 */
export const SchoolApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} schoolId The id of the school.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		schoolControllerGetMigration: async (
			schoolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolId' is not null or undefined
			assertParamExists("schoolControllerGetMigration", "schoolId", schoolId);
			const localVarPath = `/school/{schoolId}/migration`.replace(
				`{${"schoolId"}}`,
				encodeURIComponent(String(schoolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} schoolId The id of the school.
		 * @param {MigrationBody} migrationBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		schoolControllerSetMigration: async (
			schoolId: string,
			migrationBody: MigrationBody,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolId' is not null or undefined
			assertParamExists("schoolControllerSetMigration", "schoolId", schoolId);
			// verify required parameter 'migrationBody' is not null or undefined
			assertParamExists(
				"schoolControllerSetMigration",
				"migrationBody",
				migrationBody
			);
			const localVarPath = `/school/{schoolId}/migration`.replace(
				`{${"schoolId"}}`,
				encodeURIComponent(String(schoolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				migrationBody,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SchoolApi - functional programming interface
 * @export
 */
export const SchoolApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SchoolApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} schoolId The id of the school.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async schoolControllerGetMigration(
			schoolId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<MigrationResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.schoolControllerGetMigration(
					schoolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} schoolId The id of the school.
		 * @param {MigrationBody} migrationBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async schoolControllerSetMigration(
			schoolId: string,
			migrationBody: MigrationBody,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<MigrationResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.schoolControllerSetMigration(
					schoolId,
					migrationBody,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * SchoolApi - factory interface
 * @export
 */
export const SchoolApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SchoolApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} schoolId The id of the school.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		schoolControllerGetMigration(
			schoolId: string,
			options?: any
		): AxiosPromise<MigrationResponse> {
			return localVarFp
				.schoolControllerGetMigration(schoolId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} schoolId The id of the school.
		 * @param {MigrationBody} migrationBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		schoolControllerSetMigration(
			schoolId: string,
			migrationBody: MigrationBody,
			options?: any
		): AxiosPromise<MigrationResponse> {
			return localVarFp
				.schoolControllerSetMigration(schoolId, migrationBody, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * SchoolApi - interface
 * @export
 * @interface SchoolApi
 */
export interface SchoolApiInterface {
	/**
	 *
	 * @param {string} schoolId The id of the school.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SchoolApiInterface
	 */
	schoolControllerGetMigration(
		schoolId: string,
		options?: any
	): AxiosPromise<MigrationResponse>;

	/**
	 *
	 * @param {string} schoolId The id of the school.
	 * @param {MigrationBody} migrationBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SchoolApiInterface
	 */
	schoolControllerSetMigration(
		schoolId: string,
		migrationBody: MigrationBody,
		options?: any
	): AxiosPromise<MigrationResponse>;
}

/**
 * SchoolApi - object-oriented interface
 * @export
 * @class SchoolApi
 * @extends {BaseAPI}
 */
export class SchoolApi extends BaseAPI implements SchoolApiInterface {
	/**
	 *
	 * @param {string} schoolId The id of the school.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SchoolApi
	 */
	public schoolControllerGetMigration(schoolId: string, options?: any) {
		return SchoolApiFp(this.configuration)
			.schoolControllerGetMigration(schoolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} schoolId The id of the school.
	 * @param {MigrationBody} migrationBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SchoolApi
	 */
	public schoolControllerSetMigration(
		schoolId: string,
		migrationBody: MigrationBody,
		options?: any
	) {
		return SchoolApiFp(this.configuration)
			.schoolControllerSetMigration(schoolId, migrationBody, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ShareTokenApi - axios parameter creator
 * @export
 */
export const ShareTokenApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Create a share token.
		 * @param {ShareTokenBodyParams} shareTokenBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		shareTokenControllerCreateShareToken: async (
			shareTokenBodyParams: ShareTokenBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'shareTokenBodyParams' is not null or undefined
			assertParamExists(
				"shareTokenControllerCreateShareToken",
				"shareTokenBodyParams",
				shareTokenBodyParams
			);
			const localVarPath = `/sharetoken`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				shareTokenBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Import a share token payload.
		 * @param {string} token The token that identifies the shared object
		 * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		shareTokenControllerImportShareToken: async (
			token: string,
			shareTokenImportBodyParams: ShareTokenImportBodyParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'token' is not null or undefined
			assertParamExists("shareTokenControllerImportShareToken", "token", token);
			// verify required parameter 'shareTokenImportBodyParams' is not null or undefined
			assertParamExists(
				"shareTokenControllerImportShareToken",
				"shareTokenImportBodyParams",
				shareTokenImportBodyParams
			);
			const localVarPath = `/sharetoken/{token}/import`.replace(
				`{${"token"}}`,
				encodeURIComponent(String(token))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				shareTokenImportBodyParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Look up a share token.
		 * @param {string} token The token that identifies the shared object
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		shareTokenControllerLookupShareToken: async (
			token: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'token' is not null or undefined
			assertParamExists("shareTokenControllerLookupShareToken", "token", token);
			const localVarPath = `/sharetoken/{token}`.replace(
				`{${"token"}}`,
				encodeURIComponent(String(token))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ShareTokenApi - functional programming interface
 * @export
 */
export const ShareTokenApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		ShareTokenApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create a share token.
		 * @param {ShareTokenBodyParams} shareTokenBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async shareTokenControllerCreateShareToken(
			shareTokenBodyParams: ShareTokenBodyParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ShareTokenResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.shareTokenControllerCreateShareToken(
					shareTokenBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Import a share token payload.
		 * @param {string} token The token that identifies the shared object
		 * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async shareTokenControllerImportShareToken(
			token: string,
			shareTokenImportBodyParams: ShareTokenImportBodyParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CopyApiResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.shareTokenControllerImportShareToken(
					token,
					shareTokenImportBodyParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Look up a share token.
		 * @param {string} token The token that identifies the shared object
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async shareTokenControllerLookupShareToken(
			token: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ShareTokenInfoResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.shareTokenControllerLookupShareToken(
					token,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * ShareTokenApi - factory interface
 * @export
 */
export const ShareTokenApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ShareTokenApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create a share token.
		 * @param {ShareTokenBodyParams} shareTokenBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		shareTokenControllerCreateShareToken(
			shareTokenBodyParams: ShareTokenBodyParams,
			options?: any
		): AxiosPromise<ShareTokenResponse> {
			return localVarFp
				.shareTokenControllerCreateShareToken(shareTokenBodyParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Import a share token payload.
		 * @param {string} token The token that identifies the shared object
		 * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		shareTokenControllerImportShareToken(
			token: string,
			shareTokenImportBodyParams: ShareTokenImportBodyParams,
			options?: any
		): AxiosPromise<CopyApiResponse> {
			return localVarFp
				.shareTokenControllerImportShareToken(
					token,
					shareTokenImportBodyParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Look up a share token.
		 * @param {string} token The token that identifies the shared object
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		shareTokenControllerLookupShareToken(
			token: string,
			options?: any
		): AxiosPromise<ShareTokenInfoResponse> {
			return localVarFp
				.shareTokenControllerLookupShareToken(token, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ShareTokenApi - interface
 * @export
 * @interface ShareTokenApi
 */
export interface ShareTokenApiInterface {
	/**
	 *
	 * @summary Create a share token.
	 * @param {ShareTokenBodyParams} shareTokenBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ShareTokenApiInterface
	 */
	shareTokenControllerCreateShareToken(
		shareTokenBodyParams: ShareTokenBodyParams,
		options?: any
	): AxiosPromise<ShareTokenResponse>;

	/**
	 *
	 * @summary Import a share token payload.
	 * @param {string} token The token that identifies the shared object
	 * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ShareTokenApiInterface
	 */
	shareTokenControllerImportShareToken(
		token: string,
		shareTokenImportBodyParams: ShareTokenImportBodyParams,
		options?: any
	): AxiosPromise<CopyApiResponse>;

	/**
	 *
	 * @summary Look up a share token.
	 * @param {string} token The token that identifies the shared object
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ShareTokenApiInterface
	 */
	shareTokenControllerLookupShareToken(
		token: string,
		options?: any
	): AxiosPromise<ShareTokenInfoResponse>;
}

/**
 * ShareTokenApi - object-oriented interface
 * @export
 * @class ShareTokenApi
 * @extends {BaseAPI}
 */
export class ShareTokenApi extends BaseAPI implements ShareTokenApiInterface {
	/**
	 *
	 * @summary Create a share token.
	 * @param {ShareTokenBodyParams} shareTokenBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ShareTokenApi
	 */
	public shareTokenControllerCreateShareToken(
		shareTokenBodyParams: ShareTokenBodyParams,
		options?: any
	) {
		return ShareTokenApiFp(this.configuration)
			.shareTokenControllerCreateShareToken(shareTokenBodyParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Import a share token payload.
	 * @param {string} token The token that identifies the shared object
	 * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ShareTokenApi
	 */
	public shareTokenControllerImportShareToken(
		token: string,
		shareTokenImportBodyParams: ShareTokenImportBodyParams,
		options?: any
	) {
		return ShareTokenApiFp(this.configuration)
			.shareTokenControllerImportShareToken(
				token,
				shareTokenImportBodyParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Look up a share token.
	 * @param {string} token The token that identifies the shared object
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ShareTokenApi
	 */
	public shareTokenControllerLookupShareToken(token: string, options?: any) {
		return ShareTokenApiFp(this.configuration)
			.shareTokenControllerLookupShareToken(token, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * SubmissionApi - axios parameter creator
 * @export
 */
export const SubmissionApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} submissionId The id of the submission.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		submissionControllerDelete: async (
			submissionId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'submissionId' is not null or undefined
			assertParamExists(
				"submissionControllerDelete",
				"submissionId",
				submissionId
			);
			const localVarPath = `/submissions/{submissionId}`.replace(
				`{${"submissionId"}}`,
				encodeURIComponent(String(submissionId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		submissionControllerFindStatusesByTask: async (
			taskId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists(
				"submissionControllerFindStatusesByTask",
				"taskId",
				taskId
			);
			const localVarPath = `/submissions/status/task/{taskId}`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SubmissionApi - functional programming interface
 * @export
 */
export const SubmissionApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SubmissionApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} submissionId The id of the submission.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async submissionControllerDelete(
			submissionId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.submissionControllerDelete(
					submissionId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async submissionControllerFindStatusesByTask(
			taskId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SubmissionStatusListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.submissionControllerFindStatusesByTask(
					taskId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * SubmissionApi - factory interface
 * @export
 */
export const SubmissionApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SubmissionApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} submissionId The id of the submission.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		submissionControllerDelete(
			submissionId: string,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.submissionControllerDelete(submissionId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		submissionControllerFindStatusesByTask(
			taskId: string,
			options?: any
		): AxiosPromise<SubmissionStatusListResponse> {
			return localVarFp
				.submissionControllerFindStatusesByTask(taskId, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * SubmissionApi - interface
 * @export
 * @interface SubmissionApi
 */
export interface SubmissionApiInterface {
	/**
	 *
	 * @param {string} submissionId The id of the submission.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SubmissionApiInterface
	 */
	submissionControllerDelete(
		submissionId: string,
		options?: any
	): AxiosPromise<boolean>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SubmissionApiInterface
	 */
	submissionControllerFindStatusesByTask(
		taskId: string,
		options?: any
	): AxiosPromise<SubmissionStatusListResponse>;
}

/**
 * SubmissionApi - object-oriented interface
 * @export
 * @class SubmissionApi
 * @extends {BaseAPI}
 */
export class SubmissionApi extends BaseAPI implements SubmissionApiInterface {
	/**
	 *
	 * @param {string} submissionId The id of the submission.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SubmissionApi
	 */
	public submissionControllerDelete(submissionId: string, options?: any) {
		return SubmissionApiFp(this.configuration)
			.submissionControllerDelete(submissionId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SubmissionApi
	 */
	public submissionControllerFindStatusesByTask(taskId: string, options?: any) {
		return SubmissionApiFp(this.configuration)
			.submissionControllerFindStatusesByTask(taskId, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * This endpoint is used to show users the possible login systems that exist. No sensible data should be returned!
		 * @summary Finds all publicly available systems.
		 * @param {string} [type] The type of the system.
		 * @param {boolean} [onlyOauth] Flag to request only systems with oauth-config.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		systemControllerFind: async (
			type?: string,
			onlyOauth?: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/systems/public`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (type !== undefined) {
				localVarQueryParameter["type"] = type;
			}

			if (onlyOauth !== undefined) {
				localVarQueryParameter["onlyOauth"] = onlyOauth;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * This endpoint is used to get information about a possible login systems. No sensible data should be returned!
		 * @summary Finds a publicly available system.
		 * @param {string} systemId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		systemControllerGetSystem: async (
			systemId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'systemId' is not null or undefined
			assertParamExists("systemControllerGetSystem", "systemId", systemId);
			const localVarPath = `/systems/public/{systemId}`.replace(
				`{${"systemId"}}`,
				encodeURIComponent(String(systemId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration);
	return {
		/**
		 * This endpoint is used to show users the possible login systems that exist. No sensible data should be returned!
		 * @summary Finds all publicly available systems.
		 * @param {string} [type] The type of the system.
		 * @param {boolean} [onlyOauth] Flag to request only systems with oauth-config.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async systemControllerFind(
			type?: string,
			onlyOauth?: boolean,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PublicSystemListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.systemControllerFind(
					type,
					onlyOauth,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * This endpoint is used to get information about a possible login systems. No sensible data should be returned!
		 * @summary Finds a publicly available system.
		 * @param {string} systemId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async systemControllerGetSystem(
			systemId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PublicSystemResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.systemControllerGetSystem(
					systemId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SystemsApiFp(configuration);
	return {
		/**
		 * This endpoint is used to show users the possible login systems that exist. No sensible data should be returned!
		 * @summary Finds all publicly available systems.
		 * @param {string} [type] The type of the system.
		 * @param {boolean} [onlyOauth] Flag to request only systems with oauth-config.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		systemControllerFind(
			type?: string,
			onlyOauth?: boolean,
			options?: any
		): AxiosPromise<PublicSystemListResponse> {
			return localVarFp
				.systemControllerFind(type, onlyOauth, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * This endpoint is used to get information about a possible login systems. No sensible data should be returned!
		 * @summary Finds a publicly available system.
		 * @param {string} systemId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		systemControllerGetSystem(
			systemId: string,
			options?: any
		): AxiosPromise<PublicSystemResponse> {
			return localVarFp
				.systemControllerGetSystem(systemId, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * SystemsApi - interface
 * @export
 * @interface SystemsApi
 */
export interface SystemsApiInterface {
	/**
	 * This endpoint is used to show users the possible login systems that exist. No sensible data should be returned!
	 * @summary Finds all publicly available systems.
	 * @param {string} [type] The type of the system.
	 * @param {boolean} [onlyOauth] Flag to request only systems with oauth-config.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SystemsApiInterface
	 */
	systemControllerFind(
		type?: string,
		onlyOauth?: boolean,
		options?: any
	): AxiosPromise<PublicSystemListResponse>;

	/**
	 * This endpoint is used to get information about a possible login systems. No sensible data should be returned!
	 * @summary Finds a publicly available system.
	 * @param {string} systemId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SystemsApiInterface
	 */
	systemControllerGetSystem(
		systemId: string,
		options?: any
	): AxiosPromise<PublicSystemResponse>;
}

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI implements SystemsApiInterface {
	/**
	 * This endpoint is used to show users the possible login systems that exist. No sensible data should be returned!
	 * @summary Finds all publicly available systems.
	 * @param {string} [type] The type of the system.
	 * @param {boolean} [onlyOauth] Flag to request only systems with oauth-config.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SystemsApi
	 */
	public systemControllerFind(
		type?: string,
		onlyOauth?: boolean,
		options?: any
	) {
		return SystemsApiFp(this.configuration)
			.systemControllerFind(type, onlyOauth, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * This endpoint is used to get information about a possible login systems. No sensible data should be returned!
	 * @summary Finds a publicly available system.
	 * @param {string} systemId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SystemsApi
	 */
	public systemControllerGetSystem(systemId: string, options?: any) {
		return SystemsApiFp(this.configuration)
			.systemControllerGetSystem(systemId, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {TaskCopyApiParams} taskCopyApiParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerCopyTask: async (
			taskId: string,
			taskCopyApiParams: TaskCopyApiParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerCopyTask", "taskId", taskId);
			// verify required parameter 'taskCopyApiParams' is not null or undefined
			assertParamExists(
				"taskControllerCopyTask",
				"taskCopyApiParams",
				taskCopyApiParams
			);
			const localVarPath = `/tasks/{taskId}/copy`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				taskCopyApiParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {TaskCreateParams} taskCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerCreate: async (
			taskCreateParams: TaskCreateParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskCreateParams' is not null or undefined
			assertParamExists(
				"taskControllerCreate",
				"taskCreateParams",
				taskCreateParams
			);
			const localVarPath = `/tasks`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				taskCreateParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerDelete: async (
			taskId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerDelete", "taskId", taskId);
			const localVarPath = `/tasks/{taskId}`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFindAll: async (
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/tasks`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFindAllFinished: async (
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/tasks/finished`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFindTask: async (
			taskId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerFindTask", "taskId", taskId);
			const localVarPath = `/tasks/{taskId}`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFinish: async (
			taskId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerFinish", "taskId", taskId);
			const localVarPath = `/tasks/{taskId}/finish`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerRestore: async (
			taskId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerRestore", "taskId", taskId);
			const localVarPath = `/tasks/{taskId}/restore`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerRevertPublished: async (
			taskId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerRevertPublished", "taskId", taskId);
			const localVarPath = `/tasks/{taskId}/revertPublished`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {TaskUpdateParams} taskUpdateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerUpdate: async (
			taskId: string,
			taskUpdateParams: TaskUpdateParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'taskId' is not null or undefined
			assertParamExists("taskControllerUpdate", "taskId", taskId);
			// verify required parameter 'taskUpdateParams' is not null or undefined
			assertParamExists(
				"taskControllerUpdate",
				"taskUpdateParams",
				taskUpdateParams
			);
			const localVarPath = `/tasks/{taskId}`.replace(
				`{${"taskId"}}`,
				encodeURIComponent(String(taskId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				taskUpdateParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {TaskCopyApiParams} taskCopyApiParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerCopyTask(
			taskId: string,
			taskCopyApiParams: TaskCopyApiParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CopyApiResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerCopyTask(
					taskId,
					taskCopyApiParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {TaskCreateParams} taskCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerCreate(
			taskCreateParams: TaskCreateParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerCreate(
					taskCreateParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerDelete(
			taskId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerDelete(taskId, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerFindAll(
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<TaskListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerFindAll(
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerFindAllFinished(
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<TaskListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerFindAllFinished(
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerFindTask(
			taskId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerFindTask(taskId, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerFinish(
			taskId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerFinish(taskId, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerRestore(
			taskId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerRestore(taskId, options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerRevertPublished(
			taskId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerRevertPublished(
					taskId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {TaskUpdateParams} taskUpdateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async taskControllerUpdate(
			taskId: string,
			taskUpdateParams: TaskUpdateParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.taskControllerUpdate(
					taskId,
					taskUpdateParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TaskApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {TaskCopyApiParams} taskCopyApiParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerCopyTask(
			taskId: string,
			taskCopyApiParams: TaskCopyApiParams,
			options?: any
		): AxiosPromise<CopyApiResponse> {
			return localVarFp
				.taskControllerCopyTask(taskId, taskCopyApiParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {TaskCreateParams} taskCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerCreate(
			taskCreateParams: TaskCreateParams,
			options?: any
		): AxiosPromise<TaskResponse> {
			return localVarFp
				.taskControllerCreate(taskCreateParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerDelete(taskId: string, options?: any): AxiosPromise<boolean> {
			return localVarFp
				.taskControllerDelete(taskId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFindAll(
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<TaskListResponse> {
			return localVarFp
				.taskControllerFindAll(skip, limit, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFindAllFinished(
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<TaskListResponse> {
			return localVarFp
				.taskControllerFindAllFinished(skip, limit, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFindTask(
			taskId: string,
			options?: any
		): AxiosPromise<TaskResponse> {
			return localVarFp
				.taskControllerFindTask(taskId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerFinish(
			taskId: string,
			options?: any
		): AxiosPromise<TaskResponse> {
			return localVarFp
				.taskControllerFinish(taskId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerRestore(
			taskId: string,
			options?: any
		): AxiosPromise<TaskResponse> {
			return localVarFp
				.taskControllerRestore(taskId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerRevertPublished(
			taskId: string,
			options?: any
		): AxiosPromise<TaskResponse> {
			return localVarFp
				.taskControllerRevertPublished(taskId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} taskId The id of the task.
		 * @param {TaskUpdateParams} taskUpdateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		taskControllerUpdate(
			taskId: string,
			taskUpdateParams: TaskUpdateParams,
			options?: any
		): AxiosPromise<TaskResponse> {
			return localVarFp
				.taskControllerUpdate(taskId, taskUpdateParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * TaskApi - interface
 * @export
 * @interface TaskApi
 */
export interface TaskApiInterface {
	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {TaskCopyApiParams} taskCopyApiParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerCopyTask(
		taskId: string,
		taskCopyApiParams: TaskCopyApiParams,
		options?: any
	): AxiosPromise<CopyApiResponse>;

	/**
	 *
	 * @param {TaskCreateParams} taskCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerCreate(
		taskCreateParams: TaskCreateParams,
		options?: any
	): AxiosPromise<TaskResponse>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerDelete(taskId: string, options?: any): AxiosPromise<boolean>;

	/**
	 *
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerFindAll(
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<TaskListResponse>;

	/**
	 *
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerFindAllFinished(
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<TaskListResponse>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerFindTask(
		taskId: string,
		options?: any
	): AxiosPromise<TaskResponse>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerFinish(
		taskId: string,
		options?: any
	): AxiosPromise<TaskResponse>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerRestore(
		taskId: string,
		options?: any
	): AxiosPromise<TaskResponse>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerRevertPublished(
		taskId: string,
		options?: any
	): AxiosPromise<TaskResponse>;

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {TaskUpdateParams} taskUpdateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApiInterface
	 */
	taskControllerUpdate(
		taskId: string,
		taskUpdateParams: TaskUpdateParams,
		options?: any
	): AxiosPromise<TaskResponse>;
}

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI implements TaskApiInterface {
	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {TaskCopyApiParams} taskCopyApiParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerCopyTask(
		taskId: string,
		taskCopyApiParams: TaskCopyApiParams,
		options?: any
	) {
		return TaskApiFp(this.configuration)
			.taskControllerCopyTask(taskId, taskCopyApiParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {TaskCreateParams} taskCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerCreate(
		taskCreateParams: TaskCreateParams,
		options?: any
	) {
		return TaskApiFp(this.configuration)
			.taskControllerCreate(taskCreateParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerDelete(taskId: string, options?: any) {
		return TaskApiFp(this.configuration)
			.taskControllerDelete(taskId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerFindAll(skip?: number, limit?: number, options?: any) {
		return TaskApiFp(this.configuration)
			.taskControllerFindAll(skip, limit, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerFindAllFinished(
		skip?: number,
		limit?: number,
		options?: any
	) {
		return TaskApiFp(this.configuration)
			.taskControllerFindAllFinished(skip, limit, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerFindTask(taskId: string, options?: any) {
		return TaskApiFp(this.configuration)
			.taskControllerFindTask(taskId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerFinish(taskId: string, options?: any) {
		return TaskApiFp(this.configuration)
			.taskControllerFinish(taskId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerRestore(taskId: string, options?: any) {
		return TaskApiFp(this.configuration)
			.taskControllerRestore(taskId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerRevertPublished(taskId: string, options?: any) {
		return TaskApiFp(this.configuration)
			.taskControllerRevertPublished(taskId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} taskId The id of the task.
	 * @param {TaskUpdateParams} taskUpdateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TaskApi
	 */
	public taskControllerUpdate(
		taskId: string,
		taskUpdateParams: TaskUpdateParams,
		options?: any
	) {
		return TaskApiFp(this.configuration)
			.taskControllerUpdate(taskId, taskUpdateParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ToolApi - axios parameter creator
 * @export
 */
export const ToolApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @summary Lists all available tools that can be added for a given context
		 * @param {any} context
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetAvailableToolsForContext: async (
			context: any,
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'context' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetAvailableToolsForContext",
				"context",
				context
			);
			// verify required parameter 'id' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetAvailableToolsForContext",
				"id",
				id
			);
			const localVarPath = `/tools/available/{context}/{id}`
				.replace(`{${"context"}}`, encodeURIComponent(String(context)))
				.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetAvailableToolsForSchool: async (
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetAvailableToolsForSchool",
				"id",
				id
			);
			const localVarPath = `/tools/available/school/{id}`.replace(
				`{${"id"}}`,
				encodeURIComponent(String(id))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {any} context
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetExternalToolForContext: async (
			toolId: string,
			context: any,
			id: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'toolId' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetExternalToolForContext",
				"toolId",
				toolId
			);
			// verify required parameter 'context' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetExternalToolForContext",
				"context",
				context
			);
			// verify required parameter 'id' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetExternalToolForContext",
				"id",
				id
			);
			const localVarPath = `/tools/{toolId}/{context}/{id}/configuration`
				.replace(`{${"toolId"}}`, encodeURIComponent(String(toolId)))
				.replace(`{${"context"}}`, encodeURIComponent(String(context)))
				.replace(`{${"id"}}`, encodeURIComponent(String(id)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetExternalToolForScope: async (
			toolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'toolId' is not null or undefined
			assertParamExists(
				"toolConfigurationControllerGetExternalToolForScope",
				"toolId",
				toolId
			);
			const localVarPath = `/tools/{toolId}/configuration`.replace(
				`{${"toolId"}}`,
				encodeURIComponent(String(toolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Creates a ContextExternalTool
		 * @param {ContextExternalToolPostParams} contextExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolContextControllerCreateContextExternalTool: async (
			contextExternalToolPostParams: ContextExternalToolPostParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contextExternalToolPostParams' is not null or undefined
			assertParamExists(
				"toolContextControllerCreateContextExternalTool",
				"contextExternalToolPostParams",
				contextExternalToolPostParams
			);
			const localVarPath = `/tools/context`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				contextExternalToolPostParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Deletes a ContextExternalTool
		 * @param {string} contextExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolContextControllerDeleteContextExternalTool: async (
			contextExternalToolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contextExternalToolId' is not null or undefined
			assertParamExists(
				"toolContextControllerDeleteContextExternalTool",
				"contextExternalToolId",
				contextExternalToolId
			);
			const localVarPath = `/tools/context/{contextExternalToolId}`.replace(
				`{${"contextExternalToolId"}}`,
				encodeURIComponent(String(contextExternalToolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Returns a list of ContextExternalTools for the given context
		 * @param {string} contextId
		 * @param {string} contextType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolContextControllerGetContextExternalToolsForContext: async (
			contextId: string,
			contextType: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contextId' is not null or undefined
			assertParamExists(
				"toolContextControllerGetContextExternalToolsForContext",
				"contextId",
				contextId
			);
			// verify required parameter 'contextType' is not null or undefined
			assertParamExists(
				"toolContextControllerGetContextExternalToolsForContext",
				"contextType",
				contextType
			);
			const localVarPath = `/tools/context/{contextType}/{contextId}`
				.replace(`{${"contextId"}}`, encodeURIComponent(String(contextId)))
				.replace(`{${"contextType"}}`, encodeURIComponent(String(contextType)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {ExternalToolCreateParams} externalToolCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerCreateExternalTool: async (
			externalToolCreateParams: ExternalToolCreateParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'externalToolCreateParams' is not null or undefined
			assertParamExists(
				"toolControllerCreateExternalTool",
				"externalToolCreateParams",
				externalToolCreateParams
			);
			const localVarPath = `/tools`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				externalToolCreateParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerDeleteExternalTool: async (
			toolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'toolId' is not null or undefined
			assertParamExists("toolControllerDeleteExternalTool", "toolId", toolId);
			const localVarPath = `/tools/{toolId}`.replace(
				`{${"toolId"}}`,
				encodeURIComponent(String(toolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} [name] Name of the external tool
		 * @param {string} [clientId] OAuth2 client id of the external tool
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {'asc' | 'desc'} [sortOrder]
		 * @param {'id' | 'name'} [sortBy]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerFindExternalTool: async (
			name?: string,
			clientId?: string,
			skip?: number,
			limit?: number,
			sortOrder?: "asc" | "desc",
			sortBy?: "id" | "name",
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/tools`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (name !== undefined) {
				localVarQueryParameter["name"] = name;
			}

			if (clientId !== undefined) {
				localVarQueryParameter["clientId"] = clientId;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			if (sortOrder !== undefined) {
				localVarQueryParameter["sortOrder"] = sortOrder;
			}

			if (sortBy !== undefined) {
				localVarQueryParameter["sortBy"] = sortBy;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerGetExternalTool: async (
			toolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'toolId' is not null or undefined
			assertParamExists("toolControllerGetExternalTool", "toolId", toolId);
			const localVarPath = `/tools/{toolId}`.replace(
				`{${"toolId"}}`,
				encodeURIComponent(String(toolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Tool References
		 * @param {string} contextId
		 * @param {string} contextType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerGetToolReferences: async (
			contextId: string,
			contextType: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contextId' is not null or undefined
			assertParamExists(
				"toolControllerGetToolReferences",
				"contextId",
				contextId
			);
			// verify required parameter 'contextType' is not null or undefined
			assertParamExists(
				"toolControllerGetToolReferences",
				"contextType",
				contextType
			);
			const localVarPath = `/tools/references/{contextType}/{contextId}`
				.replace(`{${"contextId"}}`, encodeURIComponent(String(contextId)))
				.replace(`{${"contextType"}}`, encodeURIComponent(String(contextType)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {ExternalToolUpdateParams} externalToolUpdateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerUpdateExternalTool: async (
			toolId: string,
			externalToolUpdateParams: ExternalToolUpdateParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'toolId' is not null or undefined
			assertParamExists("toolControllerUpdateExternalTool", "toolId", toolId);
			// verify required parameter 'externalToolUpdateParams' is not null or undefined
			assertParamExists(
				"toolControllerUpdateExternalTool",
				"externalToolUpdateParams",
				externalToolUpdateParams
			);
			const localVarPath = `/tools/{toolId}`.replace(
				`{${"toolId"}}`,
				encodeURIComponent(String(toolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				externalToolUpdateParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get tool launch request for a context external tool id
		 * @param {string} contextExternalToolId The id of the context external tool
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolLaunchControllerGetToolLaunchRequest: async (
			contextExternalToolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'contextExternalToolId' is not null or undefined
			assertParamExists(
				"toolLaunchControllerGetToolLaunchRequest",
				"contextExternalToolId",
				contextExternalToolId
			);
			const localVarPath =
				`/tools/context/{contextExternalToolId}/launch`.replace(
					`{${"contextExternalToolId"}}`,
					encodeURIComponent(String(contextExternalToolId))
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerCreateSchoolExternalTool: async (
			schoolExternalToolPostParams: SchoolExternalToolPostParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolExternalToolPostParams' is not null or undefined
			assertParamExists(
				"toolSchoolControllerCreateSchoolExternalTool",
				"schoolExternalToolPostParams",
				schoolExternalToolPostParams
			);
			const localVarPath = `/tools/school`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				schoolExternalToolPostParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerDeleteSchoolExternalTool: async (
			schoolExternalToolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolExternalToolId' is not null or undefined
			assertParamExists(
				"toolSchoolControllerDeleteSchoolExternalTool",
				"schoolExternalToolId",
				schoolExternalToolId
			);
			const localVarPath = `/tools/school/{schoolExternalToolId}`.replace(
				`{${"schoolExternalToolId"}}`,
				encodeURIComponent(String(schoolExternalToolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerGetSchoolExternalTool: async (
			schoolExternalToolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolExternalToolId' is not null or undefined
			assertParamExists(
				"toolSchoolControllerGetSchoolExternalTool",
				"schoolExternalToolId",
				schoolExternalToolId
			);
			const localVarPath = `/tools/school/{schoolExternalToolId}`.replace(
				`{${"schoolExternalToolId"}}`,
				encodeURIComponent(String(schoolExternalToolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} schoolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerGetSchoolExternalTools: async (
			schoolId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolId' is not null or undefined
			assertParamExists(
				"toolSchoolControllerGetSchoolExternalTools",
				"schoolId",
				schoolId
			);
			const localVarPath = `/tools/school`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (schoolId !== undefined) {
				localVarQueryParameter["schoolId"] = schoolId;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerUpdateSchoolExternalTool: async (
			schoolExternalToolId: string,
			schoolExternalToolPostParams: SchoolExternalToolPostParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'schoolExternalToolId' is not null or undefined
			assertParamExists(
				"toolSchoolControllerUpdateSchoolExternalTool",
				"schoolExternalToolId",
				schoolExternalToolId
			);
			// verify required parameter 'schoolExternalToolPostParams' is not null or undefined
			assertParamExists(
				"toolSchoolControllerUpdateSchoolExternalTool",
				"schoolExternalToolPostParams",
				schoolExternalToolPostParams
			);
			const localVarPath = `/tools/school/{schoolExternalToolId}`.replace(
				`{${"schoolExternalToolId"}}`,
				encodeURIComponent(String(schoolExternalToolId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				schoolExternalToolPostParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ToolApi - functional programming interface
 * @export
 */
export const ToolApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ToolApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Lists all available tools that can be added for a given context
		 * @param {any} context
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolConfigurationControllerGetAvailableToolsForContext(
			context: any,
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SchoolToolConfigurationListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolConfigurationControllerGetAvailableToolsForContext(
					context,
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolConfigurationControllerGetAvailableToolsForSchool(
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ToolConfigurationListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolConfigurationControllerGetAvailableToolsForSchool(
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {any} context
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolConfigurationControllerGetExternalToolForContext(
			toolId: string,
			context: any,
			id: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ExternalToolConfigurationTemplateResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolConfigurationControllerGetExternalToolForContext(
					toolId,
					context,
					id,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolConfigurationControllerGetExternalToolForScope(
			toolId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ExternalToolConfigurationTemplateResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolConfigurationControllerGetExternalToolForScope(
					toolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Creates a ContextExternalTool
		 * @param {ContextExternalToolPostParams} contextExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolContextControllerCreateContextExternalTool(
			contextExternalToolPostParams: ContextExternalToolPostParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ContextExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolContextControllerCreateContextExternalTool(
					contextExternalToolPostParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Deletes a ContextExternalTool
		 * @param {string} contextExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolContextControllerDeleteContextExternalTool(
			contextExternalToolId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolContextControllerDeleteContextExternalTool(
					contextExternalToolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Returns a list of ContextExternalTools for the given context
		 * @param {string} contextId
		 * @param {string} contextType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolContextControllerGetContextExternalToolsForContext(
			contextId: string,
			contextType: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ContextExternalToolSearchListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolContextControllerGetContextExternalToolsForContext(
					contextId,
					contextType,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {ExternalToolCreateParams} externalToolCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolControllerCreateExternalTool(
			externalToolCreateParams: ExternalToolCreateParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolControllerCreateExternalTool(
					externalToolCreateParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolControllerDeleteExternalTool(
			toolId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolControllerDeleteExternalTool(
					toolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} [name] Name of the external tool
		 * @param {string} [clientId] OAuth2 client id of the external tool
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {'asc' | 'desc'} [sortOrder]
		 * @param {'id' | 'name'} [sortBy]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolControllerFindExternalTool(
			name?: string,
			clientId?: string,
			skip?: number,
			limit?: number,
			sortOrder?: "asc" | "desc",
			sortBy?: "id" | "name",
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ExternalToolSearchListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolControllerFindExternalTool(
					name,
					clientId,
					skip,
					limit,
					sortOrder,
					sortBy,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolControllerGetExternalTool(
			toolId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolControllerGetExternalTool(
					toolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Get Tool References
		 * @param {string} contextId
		 * @param {string} contextType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolControllerGetToolReferences(
			contextId: string,
			contextType: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ToolReferenceListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolControllerGetToolReferences(
					contextId,
					contextType,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {ExternalToolUpdateParams} externalToolUpdateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolControllerUpdateExternalTool(
			toolId: string,
			externalToolUpdateParams: ExternalToolUpdateParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolControllerUpdateExternalTool(
					toolId,
					externalToolUpdateParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Get tool launch request for a context external tool id
		 * @param {string} contextExternalToolId The id of the context external tool
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolLaunchControllerGetToolLaunchRequest(
			contextExternalToolId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ToolLaunchRequestResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolLaunchControllerGetToolLaunchRequest(
					contextExternalToolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolSchoolControllerCreateSchoolExternalTool(
			schoolExternalToolPostParams: SchoolExternalToolPostParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SchoolExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolSchoolControllerCreateSchoolExternalTool(
					schoolExternalToolPostParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolSchoolControllerDeleteSchoolExternalTool(
			schoolExternalToolId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolSchoolControllerDeleteSchoolExternalTool(
					schoolExternalToolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolSchoolControllerGetSchoolExternalTool(
			schoolExternalToolId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SchoolExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolSchoolControllerGetSchoolExternalTool(
					schoolExternalToolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} schoolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolSchoolControllerGetSchoolExternalTools(
			schoolId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SchoolExternalToolSearchListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolSchoolControllerGetSchoolExternalTools(
					schoolId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async toolSchoolControllerUpdateSchoolExternalTool(
			schoolExternalToolId: string,
			schoolExternalToolPostParams: SchoolExternalToolPostParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SchoolExternalToolResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.toolSchoolControllerUpdateSchoolExternalTool(
					schoolExternalToolId,
					schoolExternalToolPostParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * ToolApi - factory interface
 * @export
 */
export const ToolApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ToolApiFp(configuration);
	return {
		/**
		 *
		 * @summary Lists all available tools that can be added for a given context
		 * @param {any} context
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetAvailableToolsForContext(
			context: any,
			id: string,
			options?: any
		): AxiosPromise<SchoolToolConfigurationListResponse> {
			return localVarFp
				.toolConfigurationControllerGetAvailableToolsForContext(
					context,
					id,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetAvailableToolsForSchool(
			id: string,
			options?: any
		): AxiosPromise<ToolConfigurationListResponse> {
			return localVarFp
				.toolConfigurationControllerGetAvailableToolsForSchool(id, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {any} context
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetExternalToolForContext(
			toolId: string,
			context: any,
			id: string,
			options?: any
		): AxiosPromise<ExternalToolConfigurationTemplateResponse> {
			return localVarFp
				.toolConfigurationControllerGetExternalToolForContext(
					toolId,
					context,
					id,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolConfigurationControllerGetExternalToolForScope(
			toolId: string,
			options?: any
		): AxiosPromise<ExternalToolConfigurationTemplateResponse> {
			return localVarFp
				.toolConfigurationControllerGetExternalToolForScope(toolId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Creates a ContextExternalTool
		 * @param {ContextExternalToolPostParams} contextExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolContextControllerCreateContextExternalTool(
			contextExternalToolPostParams: ContextExternalToolPostParams,
			options?: any
		): AxiosPromise<ContextExternalToolResponse> {
			return localVarFp
				.toolContextControllerCreateContextExternalTool(
					contextExternalToolPostParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Deletes a ContextExternalTool
		 * @param {string} contextExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolContextControllerDeleteContextExternalTool(
			contextExternalToolId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.toolContextControllerDeleteContextExternalTool(
					contextExternalToolId,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Returns a list of ContextExternalTools for the given context
		 * @param {string} contextId
		 * @param {string} contextType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolContextControllerGetContextExternalToolsForContext(
			contextId: string,
			contextType: string,
			options?: any
		): AxiosPromise<ContextExternalToolSearchListResponse> {
			return localVarFp
				.toolContextControllerGetContextExternalToolsForContext(
					contextId,
					contextType,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {ExternalToolCreateParams} externalToolCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerCreateExternalTool(
			externalToolCreateParams: ExternalToolCreateParams,
			options?: any
		): AxiosPromise<ExternalToolResponse> {
			return localVarFp
				.toolControllerCreateExternalTool(externalToolCreateParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerDeleteExternalTool(
			toolId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.toolControllerDeleteExternalTool(toolId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [name] Name of the external tool
		 * @param {string} [clientId] OAuth2 client id of the external tool
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {'asc' | 'desc'} [sortOrder]
		 * @param {'id' | 'name'} [sortBy]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerFindExternalTool(
			name?: string,
			clientId?: string,
			skip?: number,
			limit?: number,
			sortOrder?: "asc" | "desc",
			sortBy?: "id" | "name",
			options?: any
		): AxiosPromise<ExternalToolSearchListResponse> {
			return localVarFp
				.toolControllerFindExternalTool(
					name,
					clientId,
					skip,
					limit,
					sortOrder,
					sortBy,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerGetExternalTool(
			toolId: string,
			options?: any
		): AxiosPromise<ExternalToolResponse> {
			return localVarFp
				.toolControllerGetExternalTool(toolId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Tool References
		 * @param {string} contextId
		 * @param {string} contextType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerGetToolReferences(
			contextId: string,
			contextType: string,
			options?: any
		): AxiosPromise<ToolReferenceListResponse> {
			return localVarFp
				.toolControllerGetToolReferences(contextId, contextType, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} toolId
		 * @param {ExternalToolUpdateParams} externalToolUpdateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolControllerUpdateExternalTool(
			toolId: string,
			externalToolUpdateParams: ExternalToolUpdateParams,
			options?: any
		): AxiosPromise<ExternalToolResponse> {
			return localVarFp
				.toolControllerUpdateExternalTool(
					toolId,
					externalToolUpdateParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get tool launch request for a context external tool id
		 * @param {string} contextExternalToolId The id of the context external tool
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolLaunchControllerGetToolLaunchRequest(
			contextExternalToolId: string,
			options?: any
		): AxiosPromise<ToolLaunchRequestResponse> {
			return localVarFp
				.toolLaunchControllerGetToolLaunchRequest(
					contextExternalToolId,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerCreateSchoolExternalTool(
			schoolExternalToolPostParams: SchoolExternalToolPostParams,
			options?: any
		): AxiosPromise<SchoolExternalToolResponse> {
			return localVarFp
				.toolSchoolControllerCreateSchoolExternalTool(
					schoolExternalToolPostParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerDeleteSchoolExternalTool(
			schoolExternalToolId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.toolSchoolControllerDeleteSchoolExternalTool(
					schoolExternalToolId,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerGetSchoolExternalTool(
			schoolExternalToolId: string,
			options?: any
		): AxiosPromise<SchoolExternalToolResponse> {
			return localVarFp
				.toolSchoolControllerGetSchoolExternalTool(
					schoolExternalToolId,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} schoolId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerGetSchoolExternalTools(
			schoolId: string,
			options?: any
		): AxiosPromise<SchoolExternalToolSearchListResponse> {
			return localVarFp
				.toolSchoolControllerGetSchoolExternalTools(schoolId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} schoolExternalToolId
		 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		toolSchoolControllerUpdateSchoolExternalTool(
			schoolExternalToolId: string,
			schoolExternalToolPostParams: SchoolExternalToolPostParams,
			options?: any
		): AxiosPromise<SchoolExternalToolResponse> {
			return localVarFp
				.toolSchoolControllerUpdateSchoolExternalTool(
					schoolExternalToolId,
					schoolExternalToolPostParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ToolApi - interface
 * @export
 * @interface ToolApi
 */
export interface ToolApiInterface {
	/**
	 *
	 * @summary Lists all available tools that can be added for a given context
	 * @param {any} context
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolConfigurationControllerGetAvailableToolsForContext(
		context: any,
		id: string,
		options?: any
	): AxiosPromise<SchoolToolConfigurationListResponse>;

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolConfigurationControllerGetAvailableToolsForSchool(
		id: string,
		options?: any
	): AxiosPromise<ToolConfigurationListResponse>;

	/**
	 *
	 * @param {string} toolId
	 * @param {any} context
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolConfigurationControllerGetExternalToolForContext(
		toolId: string,
		context: any,
		id: string,
		options?: any
	): AxiosPromise<ExternalToolConfigurationTemplateResponse>;

	/**
	 *
	 * @param {string} toolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolConfigurationControllerGetExternalToolForScope(
		toolId: string,
		options?: any
	): AxiosPromise<ExternalToolConfigurationTemplateResponse>;

	/**
	 *
	 * @summary Creates a ContextExternalTool
	 * @param {ContextExternalToolPostParams} contextExternalToolPostParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolContextControllerCreateContextExternalTool(
		contextExternalToolPostParams: ContextExternalToolPostParams,
		options?: any
	): AxiosPromise<ContextExternalToolResponse>;

	/**
	 *
	 * @summary Deletes a ContextExternalTool
	 * @param {string} contextExternalToolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolContextControllerDeleteContextExternalTool(
		contextExternalToolId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Returns a list of ContextExternalTools for the given context
	 * @param {string} contextId
	 * @param {string} contextType
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolContextControllerGetContextExternalToolsForContext(
		contextId: string,
		contextType: string,
		options?: any
	): AxiosPromise<ContextExternalToolSearchListResponse>;

	/**
	 *
	 * @param {ExternalToolCreateParams} externalToolCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolControllerCreateExternalTool(
		externalToolCreateParams: ExternalToolCreateParams,
		options?: any
	): AxiosPromise<ExternalToolResponse>;

	/**
	 *
	 * @param {string} toolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolControllerDeleteExternalTool(
		toolId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} [name] Name of the external tool
	 * @param {string} [clientId] OAuth2 client id of the external tool
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {'asc' | 'desc'} [sortOrder]
	 * @param {'id' | 'name'} [sortBy]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolControllerFindExternalTool(
		name?: string,
		clientId?: string,
		skip?: number,
		limit?: number,
		sortOrder?: "asc" | "desc",
		sortBy?: "id" | "name",
		options?: any
	): AxiosPromise<ExternalToolSearchListResponse>;

	/**
	 *
	 * @param {string} toolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolControllerGetExternalTool(
		toolId: string,
		options?: any
	): AxiosPromise<ExternalToolResponse>;

	/**
	 *
	 * @summary Get Tool References
	 * @param {string} contextId
	 * @param {string} contextType
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolControllerGetToolReferences(
		contextId: string,
		contextType: string,
		options?: any
	): AxiosPromise<ToolReferenceListResponse>;

	/**
	 *
	 * @param {string} toolId
	 * @param {ExternalToolUpdateParams} externalToolUpdateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolControllerUpdateExternalTool(
		toolId: string,
		externalToolUpdateParams: ExternalToolUpdateParams,
		options?: any
	): AxiosPromise<ExternalToolResponse>;

	/**
	 *
	 * @summary Get tool launch request for a context external tool id
	 * @param {string} contextExternalToolId The id of the context external tool
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolLaunchControllerGetToolLaunchRequest(
		contextExternalToolId: string,
		options?: any
	): AxiosPromise<ToolLaunchRequestResponse>;

	/**
	 *
	 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolSchoolControllerCreateSchoolExternalTool(
		schoolExternalToolPostParams: SchoolExternalToolPostParams,
		options?: any
	): AxiosPromise<SchoolExternalToolResponse>;

	/**
	 *
	 * @param {string} schoolExternalToolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolSchoolControllerDeleteSchoolExternalTool(
		schoolExternalToolId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} schoolExternalToolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolSchoolControllerGetSchoolExternalTool(
		schoolExternalToolId: string,
		options?: any
	): AxiosPromise<SchoolExternalToolResponse>;

	/**
	 *
	 * @param {string} schoolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolSchoolControllerGetSchoolExternalTools(
		schoolId: string,
		options?: any
	): AxiosPromise<SchoolExternalToolSearchListResponse>;

	/**
	 *
	 * @param {string} schoolExternalToolId
	 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApiInterface
	 */
	toolSchoolControllerUpdateSchoolExternalTool(
		schoolExternalToolId: string,
		schoolExternalToolPostParams: SchoolExternalToolPostParams,
		options?: any
	): AxiosPromise<SchoolExternalToolResponse>;
}

/**
 * ToolApi - object-oriented interface
 * @export
 * @class ToolApi
 * @extends {BaseAPI}
 */
export class ToolApi extends BaseAPI implements ToolApiInterface {
	/**
	 *
	 * @summary Lists all available tools that can be added for a given context
	 * @param {any} context
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolConfigurationControllerGetAvailableToolsForContext(
		context: any,
		id: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolConfigurationControllerGetAvailableToolsForContext(
				context,
				id,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolConfigurationControllerGetAvailableToolsForSchool(
		id: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolConfigurationControllerGetAvailableToolsForSchool(id, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} toolId
	 * @param {any} context
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolConfigurationControllerGetExternalToolForContext(
		toolId: string,
		context: any,
		id: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolConfigurationControllerGetExternalToolForContext(
				toolId,
				context,
				id,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} toolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolConfigurationControllerGetExternalToolForScope(
		toolId: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolConfigurationControllerGetExternalToolForScope(toolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Creates a ContextExternalTool
	 * @param {ContextExternalToolPostParams} contextExternalToolPostParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolContextControllerCreateContextExternalTool(
		contextExternalToolPostParams: ContextExternalToolPostParams,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolContextControllerCreateContextExternalTool(
				contextExternalToolPostParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Deletes a ContextExternalTool
	 * @param {string} contextExternalToolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolContextControllerDeleteContextExternalTool(
		contextExternalToolId: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolContextControllerDeleteContextExternalTool(
				contextExternalToolId,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Returns a list of ContextExternalTools for the given context
	 * @param {string} contextId
	 * @param {string} contextType
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolContextControllerGetContextExternalToolsForContext(
		contextId: string,
		contextType: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolContextControllerGetContextExternalToolsForContext(
				contextId,
				contextType,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {ExternalToolCreateParams} externalToolCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolControllerCreateExternalTool(
		externalToolCreateParams: ExternalToolCreateParams,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolControllerCreateExternalTool(externalToolCreateParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} toolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolControllerDeleteExternalTool(toolId: string, options?: any) {
		return ToolApiFp(this.configuration)
			.toolControllerDeleteExternalTool(toolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} [name] Name of the external tool
	 * @param {string} [clientId] OAuth2 client id of the external tool
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {'asc' | 'desc'} [sortOrder]
	 * @param {'id' | 'name'} [sortBy]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolControllerFindExternalTool(
		name?: string,
		clientId?: string,
		skip?: number,
		limit?: number,
		sortOrder?: "asc" | "desc",
		sortBy?: "id" | "name",
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolControllerFindExternalTool(
				name,
				clientId,
				skip,
				limit,
				sortOrder,
				sortBy,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} toolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolControllerGetExternalTool(toolId: string, options?: any) {
		return ToolApiFp(this.configuration)
			.toolControllerGetExternalTool(toolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Tool References
	 * @param {string} contextId
	 * @param {string} contextType
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolControllerGetToolReferences(
		contextId: string,
		contextType: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolControllerGetToolReferences(contextId, contextType, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} toolId
	 * @param {ExternalToolUpdateParams} externalToolUpdateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolControllerUpdateExternalTool(
		toolId: string,
		externalToolUpdateParams: ExternalToolUpdateParams,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolControllerUpdateExternalTool(
				toolId,
				externalToolUpdateParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get tool launch request for a context external tool id
	 * @param {string} contextExternalToolId The id of the context external tool
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolLaunchControllerGetToolLaunchRequest(
		contextExternalToolId: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolLaunchControllerGetToolLaunchRequest(contextExternalToolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolSchoolControllerCreateSchoolExternalTool(
		schoolExternalToolPostParams: SchoolExternalToolPostParams,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolSchoolControllerCreateSchoolExternalTool(
				schoolExternalToolPostParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} schoolExternalToolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolSchoolControllerDeleteSchoolExternalTool(
		schoolExternalToolId: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolSchoolControllerDeleteSchoolExternalTool(
				schoolExternalToolId,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} schoolExternalToolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolSchoolControllerGetSchoolExternalTool(
		schoolExternalToolId: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} schoolId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolSchoolControllerGetSchoolExternalTools(
		schoolId: string,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolSchoolControllerGetSchoolExternalTools(schoolId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} schoolExternalToolId
	 * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ToolApi
	 */
	public toolSchoolControllerUpdateSchoolExternalTool(
		schoolExternalToolId: string,
		schoolExternalToolPostParams: SchoolExternalToolPostParams,
		options?: any
	) {
		return ToolApiFp(this.configuration)
			.toolSchoolControllerUpdateSchoolExternalTool(
				schoolExternalToolId,
				schoolExternalToolPostParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {ChangeLanguageParams} changeLanguageParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userControllerChangeLanguage: async (
			changeLanguageParams: ChangeLanguageParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'changeLanguageParams' is not null or undefined
			assertParamExists(
				"userControllerChangeLanguage",
				"changeLanguageParams",
				changeLanguageParams
			);
			const localVarPath = `/user/language`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				changeLanguageParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userControllerMe: async (options: any = {}): Promise<RequestArgs> => {
			const localVarPath = `/user/me`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {ChangeLanguageParams} changeLanguageParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userControllerChangeLanguage(
			changeLanguageParams: ChangeLanguageParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SuccessfulResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userControllerChangeLanguage(
					changeLanguageParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userControllerMe(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ResolvedUserResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userControllerMe(options);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = UserApiFp(configuration);
	return {
		/**
		 *
		 * @param {ChangeLanguageParams} changeLanguageParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userControllerChangeLanguage(
			changeLanguageParams: ChangeLanguageParams,
			options?: any
		): AxiosPromise<SuccessfulResponse> {
			return localVarFp
				.userControllerChangeLanguage(changeLanguageParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userControllerMe(options?: any): AxiosPromise<ResolvedUserResponse> {
			return localVarFp
				.userControllerMe(options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
	/**
	 *
	 * @param {ChangeLanguageParams} changeLanguageParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApiInterface
	 */
	userControllerChangeLanguage(
		changeLanguageParams: ChangeLanguageParams,
		options?: any
	): AxiosPromise<SuccessfulResponse>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApiInterface
	 */
	userControllerMe(options?: any): AxiosPromise<ResolvedUserResponse>;
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
	/**
	 *
	 * @param {ChangeLanguageParams} changeLanguageParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public userControllerChangeLanguage(
		changeLanguageParams: ChangeLanguageParams,
		options?: any
	) {
		return UserApiFp(this.configuration)
			.userControllerChangeLanguage(changeLanguageParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserApi
	 */
	public userControllerMe(options?: any) {
		return UserApiFp(this.configuration)
			.userControllerMe(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * UserImportApi - axios parameter creator
 * @export
 */
export const UserImportApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerEndSchoolInMaintenance: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user/import/startSync`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} [firstName]
		 * @param {string} [lastName]
		 * @param {string} [loginName]
		 * @param {Array<'auto' | 'admin' | 'none'>} [match]
		 * @param {boolean} [flagged]
		 * @param {string} [classes]
		 * @param {'student' | 'teacher' | 'admin'} [role]
		 * @param {'asc' | 'desc'} [sortOrder]
		 * @param {'firstName' | 'lastName'} [sortBy]
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerFindAllImportUsers: async (
			firstName?: string,
			lastName?: string,
			loginName?: string,
			match?: Array<"auto" | "admin" | "none">,
			flagged?: boolean,
			classes?: string,
			role?: "student" | "teacher" | "admin",
			sortOrder?: "asc" | "desc",
			sortBy?: "firstName" | "lastName",
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user/import`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (firstName !== undefined) {
				localVarQueryParameter["firstName"] = firstName;
			}

			if (lastName !== undefined) {
				localVarQueryParameter["lastName"] = lastName;
			}

			if (loginName !== undefined) {
				localVarQueryParameter["loginName"] = loginName;
			}

			if (match) {
				localVarQueryParameter["match"] = match;
			}

			if (flagged !== undefined) {
				localVarQueryParameter["flagged"] = flagged;
			}

			if (classes !== undefined) {
				localVarQueryParameter["classes"] = classes;
			}

			if (role !== undefined) {
				localVarQueryParameter["role"] = role;
			}

			if (sortOrder !== undefined) {
				localVarQueryParameter["sortOrder"] = sortOrder;
			}

			if (sortBy !== undefined) {
				localVarQueryParameter["sortBy"] = sortBy;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerFindAllUnmatchedUsers: async (
			name?: string,
			skip?: number,
			limit?: number,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user/import/unassigned`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (name !== undefined) {
				localVarQueryParameter["name"] = name;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerRemoveMatch: async (
			importUserId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'importUserId' is not null or undefined
			assertParamExists(
				"importUserControllerRemoveMatch",
				"importUserId",
				importUserId
			);
			const localVarPath = `/user/import/{importUserId}/match`.replace(
				`{${"importUserId"}}`,
				encodeURIComponent(String(importUserId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerSaveAllUsersMatches: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user/import/migrate`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {UpdateMatchParams} updateMatchParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerSetMatch: async (
			importUserId: string,
			updateMatchParams: UpdateMatchParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'importUserId' is not null or undefined
			assertParamExists(
				"importUserControllerSetMatch",
				"importUserId",
				importUserId
			);
			// verify required parameter 'updateMatchParams' is not null or undefined
			assertParamExists(
				"importUserControllerSetMatch",
				"updateMatchParams",
				updateMatchParams
			);
			const localVarPath = `/user/import/{importUserId}/match`.replace(
				`{${"importUserId"}}`,
				encodeURIComponent(String(importUserId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateMatchParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {boolean} useCentralLdap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerStartSchoolInUserMigration: async (
			useCentralLdap: boolean,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'useCentralLdap' is not null or undefined
			assertParamExists(
				"importUserControllerStartSchoolInUserMigration",
				"useCentralLdap",
				useCentralLdap
			);
			const localVarPath = `/user/import/startUserMigration`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (useCentralLdap !== undefined) {
				localVarQueryParameter["useCentralLdap"] = useCentralLdap;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {UpdateFlagParams} updateFlagParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerUpdateFlag: async (
			importUserId: string,
			updateFlagParams: UpdateFlagParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'importUserId' is not null or undefined
			assertParamExists(
				"importUserControllerUpdateFlag",
				"importUserId",
				importUserId
			);
			// verify required parameter 'updateFlagParams' is not null or undefined
			assertParamExists(
				"importUserControllerUpdateFlag",
				"updateFlagParams",
				updateFlagParams
			);
			const localVarPath = `/user/import/{importUserId}/flag`.replace(
				`{${"importUserId"}}`,
				encodeURIComponent(String(importUserId))
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateFlagParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * UserImportApi - functional programming interface
 * @export
 */
export const UserImportApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		UserImportApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerEndSchoolInMaintenance(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerEndSchoolInMaintenance(
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} [firstName]
		 * @param {string} [lastName]
		 * @param {string} [loginName]
		 * @param {Array<'auto' | 'admin' | 'none'>} [match]
		 * @param {boolean} [flagged]
		 * @param {string} [classes]
		 * @param {'student' | 'teacher' | 'admin'} [role]
		 * @param {'asc' | 'desc'} [sortOrder]
		 * @param {'firstName' | 'lastName'} [sortBy]
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerFindAllImportUsers(
			firstName?: string,
			lastName?: string,
			loginName?: string,
			match?: Array<"auto" | "admin" | "none">,
			flagged?: boolean,
			classes?: string,
			role?: "student" | "teacher" | "admin",
			sortOrder?: "asc" | "desc",
			sortBy?: "firstName" | "lastName",
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ImportUserListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerFindAllImportUsers(
					firstName,
					lastName,
					loginName,
					match,
					flagged,
					classes,
					role,
					sortOrder,
					sortBy,
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerFindAllUnmatchedUsers(
			name?: string,
			skip?: number,
			limit?: number,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UserMatchListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerFindAllUnmatchedUsers(
					name,
					skip,
					limit,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerRemoveMatch(
			importUserId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ImportUserResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerRemoveMatch(
					importUserId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerSaveAllUsersMatches(
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerSaveAllUsersMatches(
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {UpdateMatchParams} updateMatchParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerSetMatch(
			importUserId: string,
			updateMatchParams: UpdateMatchParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ImportUserResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerSetMatch(
					importUserId,
					updateMatchParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {boolean} useCentralLdap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerStartSchoolInUserMigration(
			useCentralLdap: boolean,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerStartSchoolInUserMigration(
					useCentralLdap,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {UpdateFlagParams} updateFlagParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async importUserControllerUpdateFlag(
			importUserId: string,
			updateFlagParams: UpdateFlagParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ImportUserResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.importUserControllerUpdateFlag(
					importUserId,
					updateFlagParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * UserImportApi - factory interface
 * @export
 */
export const UserImportApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = UserImportApiFp(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerEndSchoolInMaintenance(
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.importUserControllerEndSchoolInMaintenance(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [firstName]
		 * @param {string} [lastName]
		 * @param {string} [loginName]
		 * @param {Array<'auto' | 'admin' | 'none'>} [match]
		 * @param {boolean} [flagged]
		 * @param {string} [classes]
		 * @param {'student' | 'teacher' | 'admin'} [role]
		 * @param {'asc' | 'desc'} [sortOrder]
		 * @param {'firstName' | 'lastName'} [sortBy]
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerFindAllImportUsers(
			firstName?: string,
			lastName?: string,
			loginName?: string,
			match?: Array<"auto" | "admin" | "none">,
			flagged?: boolean,
			classes?: string,
			role?: "student" | "teacher" | "admin",
			sortOrder?: "asc" | "desc",
			sortBy?: "firstName" | "lastName",
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<ImportUserListResponse> {
			return localVarFp
				.importUserControllerFindAllImportUsers(
					firstName,
					lastName,
					loginName,
					match,
					flagged,
					classes,
					role,
					sortOrder,
					sortBy,
					skip,
					limit,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} [name]
		 * @param {number} [skip] Number of elements (not pages) to be skipped
		 * @param {number} [limit] Page limit, defaults to 10.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerFindAllUnmatchedUsers(
			name?: string,
			skip?: number,
			limit?: number,
			options?: any
		): AxiosPromise<UserMatchListResponse> {
			return localVarFp
				.importUserControllerFindAllUnmatchedUsers(name, skip, limit, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerRemoveMatch(
			importUserId: string,
			options?: any
		): AxiosPromise<ImportUserResponse> {
			return localVarFp
				.importUserControllerRemoveMatch(importUserId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerSaveAllUsersMatches(options?: any): AxiosPromise<void> {
			return localVarFp
				.importUserControllerSaveAllUsersMatches(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {UpdateMatchParams} updateMatchParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerSetMatch(
			importUserId: string,
			updateMatchParams: UpdateMatchParams,
			options?: any
		): AxiosPromise<ImportUserResponse> {
			return localVarFp
				.importUserControllerSetMatch(importUserId, updateMatchParams, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {boolean} useCentralLdap
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerStartSchoolInUserMigration(
			useCentralLdap: boolean,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.importUserControllerStartSchoolInUserMigration(useCentralLdap, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
		 * @param {UpdateFlagParams} updateFlagParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		importUserControllerUpdateFlag(
			importUserId: string,
			updateFlagParams: UpdateFlagParams,
			options?: any
		): AxiosPromise<ImportUserResponse> {
			return localVarFp
				.importUserControllerUpdateFlag(importUserId, updateFlagParams, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * UserImportApi - interface
 * @export
 * @interface UserImportApi
 */
export interface UserImportApiInterface {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerEndSchoolInMaintenance(options?: any): AxiosPromise<void>;

	/**
	 *
	 * @param {string} [firstName]
	 * @param {string} [lastName]
	 * @param {string} [loginName]
	 * @param {Array<'auto' | 'admin' | 'none'>} [match]
	 * @param {boolean} [flagged]
	 * @param {string} [classes]
	 * @param {'student' | 'teacher' | 'admin'} [role]
	 * @param {'asc' | 'desc'} [sortOrder]
	 * @param {'firstName' | 'lastName'} [sortBy]
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerFindAllImportUsers(
		firstName?: string,
		lastName?: string,
		loginName?: string,
		match?: Array<"auto" | "admin" | "none">,
		flagged?: boolean,
		classes?: string,
		role?: "student" | "teacher" | "admin",
		sortOrder?: "asc" | "desc",
		sortBy?: "firstName" | "lastName",
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<ImportUserListResponse>;

	/**
	 *
	 * @param {string} [name]
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerFindAllUnmatchedUsers(
		name?: string,
		skip?: number,
		limit?: number,
		options?: any
	): AxiosPromise<UserMatchListResponse>;

	/**
	 *
	 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerRemoveMatch(
		importUserId: string,
		options?: any
	): AxiosPromise<ImportUserResponse>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerSaveAllUsersMatches(options?: any): AxiosPromise<void>;

	/**
	 *
	 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
	 * @param {UpdateMatchParams} updateMatchParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerSetMatch(
		importUserId: string,
		updateMatchParams: UpdateMatchParams,
		options?: any
	): AxiosPromise<ImportUserResponse>;

	/**
	 *
	 * @param {boolean} useCentralLdap
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerStartSchoolInUserMigration(
		useCentralLdap: boolean,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
	 * @param {UpdateFlagParams} updateFlagParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApiInterface
	 */
	importUserControllerUpdateFlag(
		importUserId: string,
		updateFlagParams: UpdateFlagParams,
		options?: any
	): AxiosPromise<ImportUserResponse>;
}

/**
 * UserImportApi - object-oriented interface
 * @export
 * @class UserImportApi
 * @extends {BaseAPI}
 */
export class UserImportApi extends BaseAPI implements UserImportApiInterface {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerEndSchoolInMaintenance(options?: any) {
		return UserImportApiFp(this.configuration)
			.importUserControllerEndSchoolInMaintenance(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} [firstName]
	 * @param {string} [lastName]
	 * @param {string} [loginName]
	 * @param {Array<'auto' | 'admin' | 'none'>} [match]
	 * @param {boolean} [flagged]
	 * @param {string} [classes]
	 * @param {'student' | 'teacher' | 'admin'} [role]
	 * @param {'asc' | 'desc'} [sortOrder]
	 * @param {'firstName' | 'lastName'} [sortBy]
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerFindAllImportUsers(
		firstName?: string,
		lastName?: string,
		loginName?: string,
		match?: Array<"auto" | "admin" | "none">,
		flagged?: boolean,
		classes?: string,
		role?: "student" | "teacher" | "admin",
		sortOrder?: "asc" | "desc",
		sortBy?: "firstName" | "lastName",
		skip?: number,
		limit?: number,
		options?: any
	) {
		return UserImportApiFp(this.configuration)
			.importUserControllerFindAllImportUsers(
				firstName,
				lastName,
				loginName,
				match,
				flagged,
				classes,
				role,
				sortOrder,
				sortBy,
				skip,
				limit,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} [name]
	 * @param {number} [skip] Number of elements (not pages) to be skipped
	 * @param {number} [limit] Page limit, defaults to 10.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerFindAllUnmatchedUsers(
		name?: string,
		skip?: number,
		limit?: number,
		options?: any
	) {
		return UserImportApiFp(this.configuration)
			.importUserControllerFindAllUnmatchedUsers(name, skip, limit, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerRemoveMatch(importUserId: string, options?: any) {
		return UserImportApiFp(this.configuration)
			.importUserControllerRemoveMatch(importUserId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerSaveAllUsersMatches(options?: any) {
		return UserImportApiFp(this.configuration)
			.importUserControllerSaveAllUsersMatches(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
	 * @param {UpdateMatchParams} updateMatchParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerSetMatch(
		importUserId: string,
		updateMatchParams: UpdateMatchParams,
		options?: any
	) {
		return UserImportApiFp(this.configuration)
			.importUserControllerSetMatch(importUserId, updateMatchParams, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {boolean} useCentralLdap
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerStartSchoolInUserMigration(
		useCentralLdap: boolean,
		options?: any
	) {
		return UserImportApiFp(this.configuration)
			.importUserControllerStartSchoolInUserMigration(useCentralLdap, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
	 * @param {UpdateFlagParams} updateFlagParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserImportApi
	 */
	public importUserControllerUpdateFlag(
		importUserId: string,
		updateFlagParams: UpdateFlagParams,
		options?: any
	) {
		return UserImportApiFp(this.configuration)
			.importUserControllerUpdateFlag(importUserId, updateFlagParams, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * UserLoginMigrationApi - axios parameter creator
 * @export
 */
export const UserLoginMigrationApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} [userId]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerGetMigrations: async (
			userId?: string,
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user-login-migrations`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			if (userId !== undefined) {
				localVarQueryParameter["userId"] = userId;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {Oauth2MigrationParams} oauth2MigrationParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerMigrateUserLogin: async (
			oauth2MigrationParams: Oauth2MigrationParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'oauth2MigrationParams' is not null or undefined
			assertParamExists(
				"userLoginMigrationControllerMigrateUserLogin",
				"oauth2MigrationParams",
				oauth2MigrationParams
			);
			const localVarPath = `/user-login-migrations/migrate-to-oauth2`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				oauth2MigrationParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerRestartMigration: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user-login-migrations/restart`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerSetMigrationMandatory: async (
			userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'userLoginMigrationMandatoryParams' is not null or undefined
			assertParamExists(
				"userLoginMigrationControllerSetMigrationMandatory",
				"userLoginMigrationMandatoryParams",
				userLoginMigrationMandatoryParams
			);
			const localVarPath = `/user-login-migrations/mandatory`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				userLoginMigrationMandatoryParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerStartMigration: async (
			options: any = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/user-login-migrations/start`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * UserLoginMigrationApi - functional programming interface
 * @export
 */
export const UserLoginMigrationApiFp = function (
	configuration?: Configuration
) {
	const localVarAxiosParamCreator =
		UserLoginMigrationApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} [userId]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userLoginMigrationControllerGetMigrations(
			userId?: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UserLoginMigrationSearchListResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userLoginMigrationControllerGetMigrations(
					userId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {Oauth2MigrationParams} oauth2MigrationParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userLoginMigrationControllerMigrateUserLogin(
			oauth2MigrationParams: Oauth2MigrationParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userLoginMigrationControllerMigrateUserLogin(
					oauth2MigrationParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userLoginMigrationControllerRestartMigration(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UserLoginMigrationResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userLoginMigrationControllerRestartMigration(
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userLoginMigrationControllerSetMigrationMandatory(
			userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UserLoginMigrationResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userLoginMigrationControllerSetMigrationMandatory(
					userLoginMigrationMandatoryParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userLoginMigrationControllerStartMigration(
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UserLoginMigrationResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userLoginMigrationControllerStartMigration(
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * UserLoginMigrationApi - factory interface
 * @export
 */
export const UserLoginMigrationApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = UserLoginMigrationApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} [userId]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerGetMigrations(
			userId?: string,
			options?: any
		): AxiosPromise<UserLoginMigrationSearchListResponse> {
			return localVarFp
				.userLoginMigrationControllerGetMigrations(userId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {Oauth2MigrationParams} oauth2MigrationParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerMigrateUserLogin(
			oauth2MigrationParams: Oauth2MigrationParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.userLoginMigrationControllerMigrateUserLogin(
					oauth2MigrationParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerRestartMigration(
			options?: any
		): AxiosPromise<UserLoginMigrationResponse> {
			return localVarFp
				.userLoginMigrationControllerRestartMigration(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerSetMigrationMandatory(
			userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams,
			options?: any
		): AxiosPromise<UserLoginMigrationResponse> {
			return localVarFp
				.userLoginMigrationControllerSetMigrationMandatory(
					userLoginMigrationMandatoryParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userLoginMigrationControllerStartMigration(
			options?: any
		): AxiosPromise<UserLoginMigrationResponse> {
			return localVarFp
				.userLoginMigrationControllerStartMigration(options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * UserLoginMigrationApi - interface
 * @export
 * @interface UserLoginMigrationApi
 */
export interface UserLoginMigrationApiInterface {
	/**
	 *
	 * @param {string} [userId]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApiInterface
	 */
	userLoginMigrationControllerGetMigrations(
		userId?: string,
		options?: any
	): AxiosPromise<UserLoginMigrationSearchListResponse>;

	/**
	 *
	 * @param {Oauth2MigrationParams} oauth2MigrationParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApiInterface
	 */
	userLoginMigrationControllerMigrateUserLogin(
		oauth2MigrationParams: Oauth2MigrationParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApiInterface
	 */
	userLoginMigrationControllerRestartMigration(
		options?: any
	): AxiosPromise<UserLoginMigrationResponse>;

	/**
	 *
	 * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApiInterface
	 */
	userLoginMigrationControllerSetMigrationMandatory(
		userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams,
		options?: any
	): AxiosPromise<UserLoginMigrationResponse>;

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApiInterface
	 */
	userLoginMigrationControllerStartMigration(
		options?: any
	): AxiosPromise<UserLoginMigrationResponse>;
}

/**
 * UserLoginMigrationApi - object-oriented interface
 * @export
 * @class UserLoginMigrationApi
 * @extends {BaseAPI}
 */
export class UserLoginMigrationApi
	extends BaseAPI
	implements UserLoginMigrationApiInterface
{
	/**
	 *
	 * @param {string} [userId]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApi
	 */
	public userLoginMigrationControllerGetMigrations(
		userId?: string,
		options?: any
	) {
		return UserLoginMigrationApiFp(this.configuration)
			.userLoginMigrationControllerGetMigrations(userId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {Oauth2MigrationParams} oauth2MigrationParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApi
	 */
	public userLoginMigrationControllerMigrateUserLogin(
		oauth2MigrationParams: Oauth2MigrationParams,
		options?: any
	) {
		return UserLoginMigrationApiFp(this.configuration)
			.userLoginMigrationControllerMigrateUserLogin(
				oauth2MigrationParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApi
	 */
	public userLoginMigrationControllerRestartMigration(options?: any) {
		return UserLoginMigrationApiFp(this.configuration)
			.userLoginMigrationControllerRestartMigration(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApi
	 */
	public userLoginMigrationControllerSetMigrationMandatory(
		userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams,
		options?: any
	) {
		return UserLoginMigrationApiFp(this.configuration)
			.userLoginMigrationControllerSetMigrationMandatory(
				userLoginMigrationMandatoryParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserLoginMigrationApi
	 */
	public userLoginMigrationControllerStartMigration(options?: any) {
		return UserLoginMigrationApiFp(this.configuration)
			.userLoginMigrationControllerStartMigration(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * UserMigrationApi - axios parameter creator
 * @export
 */
export const UserMigrationApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {any} pageType The Type of Page that is displayed
		 * @param {string} sourceSystem The Source System
		 * @param {string} targetSystem The Target System
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userMigrationControllerGetMigrationPageDetails: async (
			pageType: any,
			sourceSystem: string,
			targetSystem: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'pageType' is not null or undefined
			assertParamExists(
				"userMigrationControllerGetMigrationPageDetails",
				"pageType",
				pageType
			);
			// verify required parameter 'sourceSystem' is not null or undefined
			assertParamExists(
				"userMigrationControllerGetMigrationPageDetails",
				"sourceSystem",
				sourceSystem
			);
			// verify required parameter 'targetSystem' is not null or undefined
			assertParamExists(
				"userMigrationControllerGetMigrationPageDetails",
				"targetSystem",
				targetSystem
			);
			const localVarPath = `/user-migration/page-content`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (pageType !== undefined) {
				localVarQueryParameter["pageType"] = pageType;
			}

			if (sourceSystem !== undefined) {
				localVarQueryParameter["sourceSystem"] = sourceSystem;
			}

			if (targetSystem !== undefined) {
				localVarQueryParameter["targetSystem"] = targetSystem;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * UserMigrationApi - functional programming interface
 * @export
 */
export const UserMigrationApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		UserMigrationApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {any} pageType The Type of Page that is displayed
		 * @param {string} sourceSystem The Source System
		 * @param {string} targetSystem The Target System
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async userMigrationControllerGetMigrationPageDetails(
			pageType: any,
			sourceSystem: string,
			targetSystem: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PageContentResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.userMigrationControllerGetMigrationPageDetails(
					pageType,
					sourceSystem,
					targetSystem,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * UserMigrationApi - factory interface
 * @export
 */
export const UserMigrationApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = UserMigrationApiFp(configuration);
	return {
		/**
		 *
		 * @param {any} pageType The Type of Page that is displayed
		 * @param {string} sourceSystem The Source System
		 * @param {string} targetSystem The Target System
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		userMigrationControllerGetMigrationPageDetails(
			pageType: any,
			sourceSystem: string,
			targetSystem: string,
			options?: any
		): AxiosPromise<PageContentResponse> {
			return localVarFp
				.userMigrationControllerGetMigrationPageDetails(
					pageType,
					sourceSystem,
					targetSystem,
					options
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * UserMigrationApi - interface
 * @export
 * @interface UserMigrationApi
 */
export interface UserMigrationApiInterface {
	/**
	 *
	 * @param {any} pageType The Type of Page that is displayed
	 * @param {string} sourceSystem The Source System
	 * @param {string} targetSystem The Target System
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserMigrationApiInterface
	 */
	userMigrationControllerGetMigrationPageDetails(
		pageType: any,
		sourceSystem: string,
		targetSystem: string,
		options?: any
	): AxiosPromise<PageContentResponse>;
}

/**
 * UserMigrationApi - object-oriented interface
 * @export
 * @class UserMigrationApi
 * @extends {BaseAPI}
 */
export class UserMigrationApi
	extends BaseAPI
	implements UserMigrationApiInterface
{
	/**
	 *
	 * @param {any} pageType The Type of Page that is displayed
	 * @param {string} sourceSystem The Source System
	 * @param {string} targetSystem The Target System
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof UserMigrationApi
	 */
	public userMigrationControllerGetMigrationPageDetails(
		pageType: any,
		sourceSystem: string,
		targetSystem: string,
		options?: any
	) {
		return UserMigrationApiFp(this.configuration)
			.userMigrationControllerGetMigrationPageDetails(
				pageType,
				sourceSystem,
				targetSystem,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * VideoConferenceApi - axios parameter creator
 * @export
 */
export const VideoConferenceApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Use this endpoint to end a running video conference.
		 * @summary Ends a running video conference.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerEnd: async (
			scope: VideoConferenceScope,
			scopeId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists("videoConferenceControllerEnd", "scope", scope);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists("videoConferenceControllerEnd", "scopeId", scopeId);
			const localVarPath = `/videoconference2/{scope}/{scopeId}/end`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Use this endpoint to get information about a running video conference.
		 * @summary Returns information about a running video conference.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerInfo: async (
			scope: VideoConferenceScope,
			scopeId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists("videoConferenceControllerInfo", "scope", scope);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists("videoConferenceControllerInfo", "scopeId", scopeId);
			const localVarPath = `/videoconference2/{scope}/{scopeId}/info`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Use this endpoint to get a link to join an existing video conference. The conference must be running.
		 * @summary Creates a join link for a video conference, if it has started.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerJoin: async (
			scope: VideoConferenceScope,
			scopeId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists("videoConferenceControllerJoin", "scope", scope);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists("videoConferenceControllerJoin", "scopeId", scopeId);
			const localVarPath = `/videoconference2/{scope}/{scopeId}/join`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
		 * @summary Creates the video conference, if it has not started yet.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerStart: async (
			scope: VideoConferenceScope,
			scopeId: string,
			videoConferenceCreateParams: VideoConferenceCreateParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists("videoConferenceControllerStart", "scope", scope);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists("videoConferenceControllerStart", "scopeId", scopeId);
			// verify required parameter 'videoConferenceCreateParams' is not null or undefined
			assertParamExists(
				"videoConferenceControllerStart",
				"videoConferenceCreateParams",
				videoConferenceCreateParams
			);
			const localVarPath = `/videoconference2/{scope}/{scopeId}/start`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				videoConferenceCreateParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceDeprecatedControllerCreateAndJoin: async (
			scope: string,
			scopeId: string,
			videoConferenceCreateParams: VideoConferenceCreateParams,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerCreateAndJoin",
				"scope",
				scope
			);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerCreateAndJoin",
				"scopeId",
				scopeId
			);
			// verify required parameter 'videoConferenceCreateParams' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerCreateAndJoin",
				"videoConferenceCreateParams",
				videoConferenceCreateParams
			);
			const localVarPath = `/videoconference/{scope}/{scopeId}`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				videoConferenceCreateParams,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Ends a running video conference.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceDeprecatedControllerEnd: async (
			scope: string,
			scopeId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerEnd",
				"scope",
				scope
			);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerEnd",
				"scopeId",
				scopeId
			);
			const localVarPath = `/videoconference/{scope}/{scopeId}`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Returns information about a running video conference.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceDeprecatedControllerInfo: async (
			scope: string,
			scopeId: string,
			options: any = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'scope' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerInfo",
				"scope",
				scope
			);
			// verify required parameter 'scopeId' is not null or undefined
			assertParamExists(
				"videoConferenceDeprecatedControllerInfo",
				"scopeId",
				scopeId
			);
			const localVarPath = `/videoconference/{scope}/{scopeId}`
				.replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
				.replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration);

			setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * VideoConferenceApi - functional programming interface
 * @export
 */
export const VideoConferenceApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		VideoConferenceApiAxiosParamCreator(configuration);
	return {
		/**
		 * Use this endpoint to end a running video conference.
		 * @summary Ends a running video conference.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceControllerEnd(
			scope: VideoConferenceScope,
			scopeId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceControllerEnd(
					scope,
					scopeId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Use this endpoint to get information about a running video conference.
		 * @summary Returns information about a running video conference.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceControllerInfo(
			scope: VideoConferenceScope,
			scopeId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceControllerInfo(
					scope,
					scopeId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Use this endpoint to get a link to join an existing video conference. The conference must be running.
		 * @summary Creates a join link for a video conference, if it has started.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceControllerJoin(
			scope: VideoConferenceScope,
			scopeId: string,
			options?: any
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<VideoConferenceJoinResponse>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceControllerJoin(
					scope,
					scopeId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
		 * @summary Creates the video conference, if it has not started yet.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceControllerStart(
			scope: VideoConferenceScope,
			scopeId: string,
			videoConferenceCreateParams: VideoConferenceCreateParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceControllerStart(
					scope,
					scopeId,
					videoConferenceCreateParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceDeprecatedControllerCreateAndJoin(
			scope: string,
			scopeId: string,
			videoConferenceCreateParams: VideoConferenceCreateParams,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceDeprecatedControllerCreateAndJoin(
					scope,
					scopeId,
					videoConferenceCreateParams,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Ends a running video conference.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceDeprecatedControllerEnd(
			scope: string,
			scopeId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceDeprecatedControllerEnd(
					scope,
					scopeId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
		/**
		 *
		 * @summary Returns information about a running video conference.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async videoConferenceDeprecatedControllerInfo(
			scope: string,
			scopeId: string,
			options?: any
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.videoConferenceDeprecatedControllerInfo(
					scope,
					scopeId,
					options
				);
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			);
		},
	};
};

/**
 * VideoConferenceApi - factory interface
 * @export
 */
export const VideoConferenceApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = VideoConferenceApiFp(configuration);
	return {
		/**
		 * Use this endpoint to end a running video conference.
		 * @summary Ends a running video conference.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerEnd(
			scope: VideoConferenceScope,
			scopeId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.videoConferenceControllerEnd(scope, scopeId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Use this endpoint to get information about a running video conference.
		 * @summary Returns information about a running video conference.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerInfo(
			scope: VideoConferenceScope,
			scopeId: string,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.videoConferenceControllerInfo(scope, scopeId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Use this endpoint to get a link to join an existing video conference. The conference must be running.
		 * @summary Creates a join link for a video conference, if it has started.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerJoin(
			scope: VideoConferenceScope,
			scopeId: string,
			options?: any
		): AxiosPromise<VideoConferenceJoinResponse> {
			return localVarFp
				.videoConferenceControllerJoin(scope, scopeId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
		 * @summary Creates the video conference, if it has not started yet.
		 * @param {VideoConferenceScope} scope
		 * @param {string} scopeId
		 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceControllerStart(
			scope: VideoConferenceScope,
			scopeId: string,
			videoConferenceCreateParams: VideoConferenceCreateParams,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.videoConferenceControllerStart(
					scope,
					scopeId,
					videoConferenceCreateParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceDeprecatedControllerCreateAndJoin(
			scope: string,
			scopeId: string,
			videoConferenceCreateParams: VideoConferenceCreateParams,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.videoConferenceDeprecatedControllerCreateAndJoin(
					scope,
					scopeId,
					videoConferenceCreateParams,
					options
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Ends a running video conference.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceDeprecatedControllerEnd(
			scope: string,
			scopeId: string,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.videoConferenceDeprecatedControllerEnd(scope, scopeId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Returns information about a running video conference.
		 * @param {string} scope
		 * @param {string} scopeId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		videoConferenceDeprecatedControllerInfo(
			scope: string,
			scopeId: string,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.videoConferenceDeprecatedControllerInfo(scope, scopeId, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * VideoConferenceApi - interface
 * @export
 * @interface VideoConferenceApi
 */
export interface VideoConferenceApiInterface {
	/**
	 * Use this endpoint to end a running video conference.
	 * @summary Ends a running video conference.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceControllerEnd(
		scope: VideoConferenceScope,
		scopeId: string,
		options?: any
	): AxiosPromise<void>;

	/**
	 * Use this endpoint to get information about a running video conference.
	 * @summary Returns information about a running video conference.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceControllerInfo(
		scope: VideoConferenceScope,
		scopeId: string,
		options?: any
	): AxiosPromise<object>;

	/**
	 * Use this endpoint to get a link to join an existing video conference. The conference must be running.
	 * @summary Creates a join link for a video conference, if it has started.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceControllerJoin(
		scope: VideoConferenceScope,
		scopeId: string,
		options?: any
	): AxiosPromise<VideoConferenceJoinResponse>;

	/**
	 * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
	 * @summary Creates the video conference, if it has not started yet.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceControllerStart(
		scope: VideoConferenceScope,
		scopeId: string,
		videoConferenceCreateParams: VideoConferenceCreateParams,
		options?: any
	): AxiosPromise<void>;

	/**
	 *
	 * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
	 * @param {string} scope
	 * @param {string} scopeId
	 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceDeprecatedControllerCreateAndJoin(
		scope: string,
		scopeId: string,
		videoConferenceCreateParams: VideoConferenceCreateParams,
		options?: any
	): AxiosPromise<object>;

	/**
	 *
	 * @summary Ends a running video conference.
	 * @param {string} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceDeprecatedControllerEnd(
		scope: string,
		scopeId: string,
		options?: any
	): AxiosPromise<object>;

	/**
	 *
	 * @summary Returns information about a running video conference.
	 * @param {string} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApiInterface
	 */
	videoConferenceDeprecatedControllerInfo(
		scope: string,
		scopeId: string,
		options?: any
	): AxiosPromise<object>;
}

/**
 * VideoConferenceApi - object-oriented interface
 * @export
 * @class VideoConferenceApi
 * @extends {BaseAPI}
 */
export class VideoConferenceApi
	extends BaseAPI
	implements VideoConferenceApiInterface
{
	/**
	 * Use this endpoint to end a running video conference.
	 * @summary Ends a running video conference.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceControllerEnd(
		scope: VideoConferenceScope,
		scopeId: string,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceControllerEnd(scope, scopeId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Use this endpoint to get information about a running video conference.
	 * @summary Returns information about a running video conference.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceControllerInfo(
		scope: VideoConferenceScope,
		scopeId: string,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceControllerInfo(scope, scopeId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Use this endpoint to get a link to join an existing video conference. The conference must be running.
	 * @summary Creates a join link for a video conference, if it has started.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceControllerJoin(
		scope: VideoConferenceScope,
		scopeId: string,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceControllerJoin(scope, scopeId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
	 * @summary Creates the video conference, if it has not started yet.
	 * @param {VideoConferenceScope} scope
	 * @param {string} scopeId
	 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceControllerStart(
		scope: VideoConferenceScope,
		scopeId: string,
		videoConferenceCreateParams: VideoConferenceCreateParams,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceControllerStart(
				scope,
				scopeId,
				videoConferenceCreateParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
	 * @param {string} scope
	 * @param {string} scopeId
	 * @param {VideoConferenceCreateParams} videoConferenceCreateParams
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceDeprecatedControllerCreateAndJoin(
		scope: string,
		scopeId: string,
		videoConferenceCreateParams: VideoConferenceCreateParams,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceDeprecatedControllerCreateAndJoin(
				scope,
				scopeId,
				videoConferenceCreateParams,
				options
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Ends a running video conference.
	 * @param {string} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceDeprecatedControllerEnd(
		scope: string,
		scopeId: string,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceDeprecatedControllerEnd(scope, scopeId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Returns information about a running video conference.
	 * @param {string} scope
	 * @param {string} scopeId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof VideoConferenceApi
	 */
	public videoConferenceDeprecatedControllerInfo(
		scope: string,
		scopeId: string,
		options?: any
	) {
		return VideoConferenceApiFp(this.configuration)
			.videoConferenceDeprecatedControllerInfo(scope, scopeId, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
