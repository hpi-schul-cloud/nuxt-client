/* tslint:disable */
/* eslint-disable */
/**
 * Schulcloud-Verbund-Software Server API
 * This is v3 of Schulcloud-Verbund-Software Server. Checkout /docs for v1.
 *
 * The version of the OpenAPI document: 3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountByIdBodyParams
 */
export interface AccountByIdBodyParams {
    /**
     * The new user name for the user.
     * @type {string}
     * @memberof AccountByIdBodyParams
     */
    username?: string;
    /**
     * The new password for the user.
     * @type {string}
     * @memberof AccountByIdBodyParams
     */
    password?: string;
    /**
     * The new activation state of the user.
     * @type {boolean}
     * @memberof AccountByIdBodyParams
     */
    activated?: boolean;
}
/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    userId: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountResponse
     */
    activated: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountResponse
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface AccountSearchListResponse
 */
export interface AccountSearchListResponse {
    /**
     * The items for the current page.
     * @type {Array<AccountResponse>}
     * @memberof AccountSearchListResponse
     */
    data: Array<AccountResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof AccountSearchListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof AccountSearchListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof AccountSearchListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface AddRoomMembersBodyParams
 */
export interface AddRoomMembersBodyParams {
    /**
     * The IDs of the users
     * @type {Array<string>}
     * @memberof AddRoomMembersBodyParams
     */
    userIds: Array<string>;
}
/**
 * 
 * @export
 * @interface AlertResponse
 */
export interface AlertResponse {
    /**
     * 
     * @type {Array<Message>}
     * @memberof AlertResponse
     */
    data: Array<Message>;
}
/**
 * 
 * @export
 * @interface ApiValidationError
 */
export interface ApiValidationError {
    /**
     * The response status code.
     * @type {number}
     * @memberof ApiValidationError
     */
    code: number;
    /**
     * The error type.
     * @type {string}
     * @memberof ApiValidationError
     */
    type: string;
    /**
     * The error title.
     * @type {string}
     * @memberof ApiValidationError
     */
    title: string;
    /**
     * The error message.
     * @type {string}
     * @memberof ApiValidationError
     */
    message: string;
    /**
     * The error details.
     * @type {object}
     * @memberof ApiValidationError
     */
    details?: object;
}
/**
 * 
 * @export
 * @interface AuthorizationBodyParams
 */
export interface AuthorizationBodyParams {
    /**
     * 
     * @type {AuthorizationContextParams}
     * @memberof AuthorizationBodyParams
     */
    context: AuthorizationContextParams;
    /**
     * The entity or domain object the operation should be performed on.
     * @type {string}
     * @memberof AuthorizationBodyParams
     */
    referenceType: AuthorizationBodyParamsReferenceTypeEnum;
    /**
     * The id of the entity/domain object of the defined referenceType.
     * @type {string}
     * @memberof AuthorizationBodyParams
     */
    referenceId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AuthorizationBodyParamsReferenceTypeEnum {
    Users = 'users',
    Schools = 'schools',
    Courses = 'courses',
    Coursegroups = 'coursegroups',
    Tasks = 'tasks',
    Lessons = 'lessons',
    Teams = 'teams',
    Submissions = 'submissions',
    SchoolExternalTools = 'school-external-tools',
    Boardnodes = 'boardnodes',
    ContextExternalTools = 'context-external-tools',
    ExternalTools = 'external-tools',
    Instances = 'instances'
}

/**
 * 
 * @export
 * @interface AuthorizationContextParams
 */
export interface AuthorizationContextParams {
    /**
     * Define for which action the operation should be performend.
     * @type {string}
     * @memberof AuthorizationContextParams
     */
    action: AuthorizationContextParamsActionEnum;
    /**
     * User permissions that are needed to execute the operation.
     * @type {Array<string>}
     * @memberof AuthorizationContextParams
     */
    requiredPermissions: Array<AuthorizationContextParamsRequiredPermissionsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum AuthorizationContextParamsActionEnum {
    Read = 'read',
    Write = 'write'
}
/**
    * @export
    * @enum {string}
    */
export enum AuthorizationContextParamsRequiredPermissionsEnum {
    AccountCreate = 'ACCOUNT_CREATE',
    AccountDelete = 'ACCOUNT_DELETE',
    AccountEdit = 'ACCOUNT_EDIT',
    AccountView = 'ACCOUNT_VIEW',
    AddSchoolMembers = 'ADD_SCHOOL_MEMBERS',
    AdminEdit = 'ADMIN_EDIT',
    AdminView = 'ADMIN_VIEW',
    BaseView = 'BASE_VIEW',
    CalendarCreate = 'CALENDAR_CREATE',
    CalendarEdit = 'CALENDAR_EDIT',
    CalendarView = 'CALENDAR_VIEW',
    ChangeTeamRoles = 'CHANGE_TEAM_ROLES',
    ClassCreate = 'CLASS_CREATE',
    ClassEdit = 'CLASS_EDIT',
    ClassFullAdmin = 'CLASS_FULL_ADMIN',
    ClassList = 'CLASS_LIST',
    ClassRemove = 'CLASS_REMOVE',
    ClassView = 'CLASS_VIEW',
    CommentsCreate = 'COMMENTS_CREATE',
    CommentsEdit = 'COMMENTS_EDIT',
    CommentsView = 'COMMENTS_VIEW',
    ContentNonOerView = 'CONTENT_NON_OER_VIEW',
    ContentView = 'CONTENT_VIEW',
    ContextToolAdmin = 'CONTEXT_TOOL_ADMIN',
    ContextToolUser = 'CONTEXT_TOOL_USER',
    CoursegroupCreate = 'COURSEGROUP_CREATE',
    CoursegroupEdit = 'COURSEGROUP_EDIT',
    CourseAdministration = 'COURSE_ADMINISTRATION',
    CourseCreate = 'COURSE_CREATE',
    CourseDelete = 'COURSE_DELETE',
    CourseEdit = 'COURSE_EDIT',
    CourseRemove = 'COURSE_REMOVE',
    CourseView = 'COURSE_VIEW',
    CreateSupportJwt = 'CREATE_SUPPORT_JWT',
    CreateTopicsAndTasks = 'CREATE_TOPICS_AND_TASKS',
    DashboardView = 'DASHBOARD_VIEW',
    DatasourcesCreate = 'DATASOURCES_CREATE',
    DatasourcesDelete = 'DATASOURCES_DELETE',
    DatasourcesEdit = 'DATASOURCES_EDIT',
    DatasourcesRun = 'DATASOURCES_RUN',
    DatasourcesRunView = 'DATASOURCES_RUN_VIEW',
    DatasourcesView = 'DATASOURCES_VIEW',
    DefaultFilePermissions = 'DEFAULT_FILE_PERMISSIONS',
    DeleteTeam = 'DELETE_TEAM',
    EditAllFiles = 'EDIT_ALL_FILES',
    EnterthecloudStart = 'ENTERTHECLOUD_START',
    FederalstateCreate = 'FEDERALSTATE_CREATE',
    FederalstateEdit = 'FEDERALSTATE_EDIT',
    FederalstateView = 'FEDERALSTATE_VIEW',
    FilestorageCreate = 'FILESTORAGE_CREATE',
    FilestorageEdit = 'FILESTORAGE_EDIT',
    FilestorageRemove = 'FILESTORAGE_REMOVE',
    FilestorageView = 'FILESTORAGE_VIEW',
    FileCreate = 'FILE_CREATE',
    FileDelete = 'FILE_DELETE',
    FileMove = 'FILE_MOVE',
    FolderCreate = 'FOLDER_CREATE',
    FolderDelete = 'FOLDER_DELETE',
    GroupList = 'GROUP_LIST',
    GroupFullAdmin = 'GROUP_FULL_ADMIN',
    GroupView = 'GROUP_VIEW',
    HelpdeskCreate = 'HELPDESK_CREATE',
    HelpdeskEdit = 'HELPDESK_EDIT',
    HelpdeskView = 'HELPDESK_VIEW',
    HomeworkCreate = 'HOMEWORK_CREATE',
    HomeworkEdit = 'HOMEWORK_EDIT',
    HomeworkView = 'HOMEWORK_VIEW',
    ImportUserMigrate = 'IMPORT_USER_MIGRATE',
    ImportUserUpdate = 'IMPORT_USER_UPDATE',
    ImportUserView = 'IMPORT_USER_VIEW',
    InstanceView = 'INSTANCE_VIEW',
    InviteAdministrators = 'INVITE_ADMINISTRATORS',
    InviteExperts = 'INVITE_EXPERTS',
    JoinMeeting = 'JOIN_MEETING',
    LeaveTeam = 'LEAVE_TEAM',
    LernstoreView = 'LERNSTORE_VIEW',
    LessonsCreate = 'LESSONS_CREATE',
    LessonsView = 'LESSONS_VIEW',
    LinkCreate = 'LINK_CREATE',
    MediaSchoolLicenseAdmin = 'MEDIA_SCHOOL_LICENSE_ADMIN',
    NewsCreate = 'NEWS_CREATE',
    NewsEdit = 'NEWS_EDIT',
    NewsView = 'NEWS_VIEW',
    NextcloudUser = 'NEXTCLOUD_USER',
    NotificationCreate = 'NOTIFICATION_CREATE',
    NotificationEdit = 'NOTIFICATION_EDIT',
    NotificationView = 'NOTIFICATION_VIEW',
    OauthClientEdit = 'OAUTH_CLIENT_EDIT',
    OauthClientView = 'OAUTH_CLIENT_VIEW',
    PasswordEdit = 'PASSWORD_EDIT',
    PwrecoveryCreate = 'PWRECOVERY_CREATE',
    PwrecoveryEdit = 'PWRECOVERY_EDIT',
    PwrecoveryView = 'PWRECOVERY_VIEW',
    ReleasesCreate = 'RELEASES_CREATE',
    ReleasesEdit = 'RELEASES_EDIT',
    ReleasesView = 'RELEASES_VIEW',
    RemoveMembers = 'REMOVE_MEMBERS',
    RenameTeam = 'RENAME_TEAM',
    RequestConsents = 'REQUEST_CONSENTS',
    RoleCreate = 'ROLE_CREATE',
    RoleEdit = 'ROLE_EDIT',
    RoleView = 'ROLE_VIEW',
    RoomCreate = 'ROOM_CREATE',
    RoomEdit = 'ROOM_EDIT',
    RoomView = 'ROOM_VIEW',
    RoomDelete = 'ROOM_DELETE',
    RoomLeave = 'ROOM_LEAVE',
    RoomMembersAdd = 'ROOM_MEMBERS_ADD',
    RoomMembersRemove = 'ROOM_MEMBERS_REMOVE',
    RoomMembersChangeRole = 'ROOM_MEMBERS_CHANGE_ROLE',
    RoomChangeOwner = 'ROOM_CHANGE_OWNER',
    SchoolChatManage = 'SCHOOL_CHAT_MANAGE',
    SchoolCreate = 'SCHOOL_CREATE',
    SchoolEdit = 'SCHOOL_EDIT',
    SchoolEditAll = 'SCHOOL_EDIT_ALL',
    SchoolLogoManage = 'SCHOOL_LOGO_MANAGE',
    SchoolNewsEdit = 'SCHOOL_NEWS_EDIT',
    SchoolPermissionChange = 'SCHOOL_PERMISSION_CHANGE',
    SchoolPermissionView = 'SCHOOL_PERMISSION_VIEW',
    SchoolStudentTeamManage = 'SCHOOL_STUDENT_TEAM_MANAGE',
    SchoolSystemEdit = 'SCHOOL_SYSTEM_EDIT',
    SchoolSystemView = 'SCHOOL_SYSTEM_VIEW',
    SchoolToolAdmin = 'SCHOOL_TOOL_ADMIN',
    ScopePermissionsView = 'SCOPE_PERMISSIONS_VIEW',
    StartMeeting = 'START_MEETING',
    StudentCreate = 'STUDENT_CREATE',
    StudentDelete = 'STUDENT_DELETE',
    StudentEdit = 'STUDENT_EDIT',
    StudentList = 'STUDENT_LIST',
    StudentSkipRegistration = 'STUDENT_SKIP_REGISTRATION',
    SubmissionsCreate = 'SUBMISSIONS_CREATE',
    SubmissionsEdit = 'SUBMISSIONS_EDIT',
    SubmissionsSchoolView = 'SUBMISSIONS_SCHOOL_VIEW',
    SubmissionsView = 'SUBMISSIONS_VIEW',
    SyncStart = 'SYNC_START',
    SystemCreate = 'SYSTEM_CREATE',
    SystemEdit = 'SYSTEM_EDIT',
    SystemView = 'SYSTEM_VIEW',
    TaskDashboardTeacherViewV3 = 'TASK_DASHBOARD_TEACHER_VIEW_V3',
    TaskDashboardViewV3 = 'TASK_DASHBOARD_VIEW_V3',
    TeacherCreate = 'TEACHER_CREATE',
    TeacherDelete = 'TEACHER_DELETE',
    TeacherEdit = 'TEACHER_EDIT',
    TeacherList = 'TEACHER_LIST',
    TeacherSkipRegistration = 'TEACHER_SKIP_REGISTRATION',
    TeamCreate = 'TEAM_CREATE',
    ToolCreateEtherpad = 'TOOL_CREATE_ETHERPAD',
    TeamEdit = 'TEAM_EDIT',
    TeamInviteExternal = 'TEAM_INVITE_EXTERNAL',
    TeamView = 'TEAM_VIEW',
    ToolAdmin = 'TOOL_ADMIN',
    ToolCreate = 'TOOL_CREATE',
    ToolEdit = 'TOOL_EDIT',
    ToolNewView = 'TOOL_NEW_VIEW',
    ToolView = 'TOOL_VIEW',
    TopicCreate = 'TOPIC_CREATE',
    TopicEdit = 'TOPIC_EDIT',
    TopicView = 'TOPIC_VIEW',
    UploadFiles = 'UPLOAD_FILES',
    UseLibreoffice = 'USE_LIBREOFFICE',
    UseRocketchat = 'USE_ROCKETCHAT',
    UsergroupCreate = 'USERGROUP_CREATE',
    UsergroupEdit = 'USERGROUP_EDIT',
    UsergroupView = 'USERGROUP_VIEW',
    UserChangeOwnName = 'USER_CHANGE_OWN_NAME',
    UserCreate = 'USER_CREATE',
    UserLoginMigrationAdmin = 'USER_LOGIN_MIGRATION_ADMIN',
    UserLoginMigrationRollback = 'USER_LOGIN_MIGRATION_ROLLBACK',
    UserLoginMigrationForce = 'USER_LOGIN_MIGRATION_FORCE',
    UserMigrate = 'USER_MIGRATE',
    UserUpdate = 'USER_UPDATE',
    YearsEdit = 'YEARS_EDIT'
}

/**
 * 
 * @export
 * @interface AuthorizedReponse
 */
export interface AuthorizedReponse {
    /**
     * 
     * @type {string}
     * @memberof AuthorizedReponse
     */
    userId: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizedReponse
     */
    isAuthorized: boolean;
}
/**
 * 
 * @export
 * @interface BasicToolConfigParams
 */
export interface BasicToolConfigParams {
    /**
     * 
     * @type {string}
     * @memberof BasicToolConfigParams
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof BasicToolConfigParams
     */
    baseUrl: string;
}
/**
 * 
 * @export
 * @interface BoardColumnBoardResponse
 */
export interface BoardColumnBoardResponse {
    /**
     * 
     * @type {string}
     * @memberof BoardColumnBoardResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BoardColumnBoardResponse
     */
    title: string;
    /**
     * 
     * @type {boolean}
     * @memberof BoardColumnBoardResponse
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof BoardColumnBoardResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof BoardColumnBoardResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof BoardColumnBoardResponse
     */
    columnBoardId: string;
    /**
     * 
     * @type {BoardLayout}
     * @memberof BoardColumnBoardResponse
     */
    layout: BoardLayout;
}
/**
 * 
 * @export
 * @interface BoardContextResponse
 */
export interface BoardContextResponse {
    /**
     * 
     * @type {string}
     * @memberof BoardContextResponse
     */
    id: string;
    /**
     * 
     * @type {BoardExternalReferenceType}
     * @memberof BoardContextResponse
     */
    type: BoardExternalReferenceType;
}
/**
 * 
 * @export
 * @interface BoardElementResponse
 */
export interface BoardElementResponse {
    /**
     * the type of the element in the content. For possible types, please refer to the enum
     * @type {string}
     * @memberof BoardElementResponse
     */
    type: BoardElementResponseTypeEnum;
    /**
     * Content of the Board, either: a task or a lesson specific for the board
     * @type {BoardTaskResponse | BoardLessonResponse | BoardColumnBoardResponse}
     * @memberof BoardElementResponse
     */
    content: BoardTaskResponse | BoardLessonResponse | BoardColumnBoardResponse;
}

/**
    * @export
    * @enum {string}
    */
export enum BoardElementResponseTypeEnum {
    Task = 'task',
    Lesson = 'lesson',
    ColumnBoard = 'column-board'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum BoardExternalReferenceType {
    Course = 'course',
    Room = 'room',
    User = 'user'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum BoardFeature {
    Videoconference = 'videoconference'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum BoardLayout {
    Columns = 'columns',
    List = 'list',
    Grid = 'grid'
}

/**
 * 
 * @export
 * @interface BoardLessonResponse
 */
export interface BoardLessonResponse {
    /**
     * 
     * @type {string}
     * @memberof BoardLessonResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BoardLessonResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BoardLessonResponse
     */
    courseName?: string;
    /**
     * 
     * @type {number}
     * @memberof BoardLessonResponse
     */
    numberOfPublishedTasks: number;
    /**
     * 
     * @type {number}
     * @memberof BoardLessonResponse
     */
    numberOfDraftTasks: number;
    /**
     * 
     * @type {number}
     * @memberof BoardLessonResponse
     */
    numberOfPlannedTasks: number;
    /**
     * 
     * @type {string}
     * @memberof BoardLessonResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof BoardLessonResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {boolean}
     * @memberof BoardLessonResponse
     */
    hidden: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum BoardParentType {
    Course = 'course',
    Room = 'room',
    User = 'user'
}

/**
 * 
 * @export
 * @interface BoardResponse
 */
export interface BoardResponse {
    /**
     * 
     * @type {string}
     * @memberof BoardResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BoardResponse
     */
    title: string;
    /**
     * 
     * @type {Array<ColumnResponse>}
     * @memberof BoardResponse
     */
    columns: Array<ColumnResponse>;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof BoardResponse
     */
    timestamps: TimestampsResponse;
    /**
     * 
     * @type {boolean}
     * @memberof BoardResponse
     */
    isVisible: boolean;
    /**
     * 
     * @type {string}
     * @memberof BoardResponse
     */
    layout: string;
    /**
     * 
     * @type {Array<BoardFeature>}
     * @memberof BoardResponse
     */
    features: Array<BoardFeature>;
}
/**
 * 
 * @export
 * @interface BoardTaskResponse
 */
export interface BoardTaskResponse {
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    availableDate?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    dueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    courseName?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    displayColor?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof BoardTaskResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {BoardTaskStatusResponse}
     * @memberof BoardTaskResponse
     */
    status: BoardTaskStatusResponse;
}
/**
 * 
 * @export
 * @interface BoardTaskStatusResponse
 */
export interface BoardTaskStatusResponse {
    /**
     * 
     * @type {number}
     * @memberof BoardTaskStatusResponse
     */
    submitted: number;
    /**
     * 
     * @type {number}
     * @memberof BoardTaskStatusResponse
     */
    maxSubmissions: number;
    /**
     * 
     * @type {number}
     * @memberof BoardTaskStatusResponse
     */
    graded: number;
    /**
     * 
     * @type {boolean}
     * @memberof BoardTaskStatusResponse
     */
    isDraft: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BoardTaskStatusResponse
     */
    isSubstitutionTeacher: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BoardTaskStatusResponse
     */
    isFinished: boolean;
}
/**
 * 
 * @export
 * @interface CardListResponse
 */
export interface CardListResponse {
    /**
     * 
     * @type {Array<CardResponse>}
     * @memberof CardListResponse
     */
    data: Array<CardResponse>;
}
/**
 * 
 * @export
 * @interface CardResponse
 */
export interface CardResponse {
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CardResponse
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof CardResponse
     */
    height: number;
    /**
     * 
     * @type {Array<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | CollaborativeTextEditorElementResponse | DeletedElementResponse | VideoConferenceElementResponse>}
     * @memberof CardResponse
     */
    elements: Array<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | CollaborativeTextEditorElementResponse | DeletedElementResponse | VideoConferenceElementResponse>;
    /**
     * 
     * @type {VisibilitySettingsResponse}
     * @memberof CardResponse
     */
    visibilitySettings: VisibilitySettingsResponse;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof CardResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface CardSkeletonResponse
 */
export interface CardSkeletonResponse {
    /**
     * 
     * @type {string}
     * @memberof CardSkeletonResponse
     */
    cardId: string;
    /**
     * The approximate height of the referenced card. Intended to be used for prerendering purposes. Note, that different devices can lead to this value not being precise
     * @type {number}
     * @memberof CardSkeletonResponse
     */
    height: number;
}
/**
 * 
 * @export
 * @interface ChangeLanguageParams
 */
export interface ChangeLanguageParams {
    /**
     * 
     * @type {LanguageType}
     * @memberof ChangeLanguageParams
     */
    language: LanguageType;
}
/**
 * 
 * @export
 * @interface ChangeRoomRoleBodyParams
 */
export interface ChangeRoomRoleBodyParams {
    /**
     * The IDs of the users
     * @type {Array<string>}
     * @memberof ChangeRoomRoleBodyParams
     */
    userIds: Array<string>;
    /**
     * The role to assign to the users. Must be a Room Role role other than ROOMOWNER.
     * @type {string}
     * @memberof ChangeRoomRoleBodyParams
     */
    roleName: ChangeRoomRoleBodyParamsRoleNameEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ChangeRoomRoleBodyParamsRoleNameEnum {
    Roomadmin = 'roomadmin',
    Roomeditor = 'roomeditor',
    Roomviewer = 'roomviewer'
}

/**
 * 
 * @export
 * @interface ClassInfoResponse
 */
export interface ClassInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof ClassInfoResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ClassInfoResponse
     */
    type: ClassInfoResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClassInfoResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ClassInfoResponse
     */
    externalSourceName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassInfoResponse
     */
    teacherNames: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassInfoResponse
     */
    schoolYear?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClassInfoResponse
     */
    isUpgradable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClassInfoResponse
     */
    studentCount: number;
    /**
     * 
     * @type {Array<CourseInfoResponse>}
     * @memberof ClassInfoResponse
     */
    synchronizedCourses?: Array<CourseInfoResponse>;
}

/**
    * @export
    * @enum {string}
    */
export enum ClassInfoResponseTypeEnum {
    Class = 'class',
    Group = 'group'
}

/**
 * 
 * @export
 * @interface ClassInfoSearchListResponse
 */
export interface ClassInfoSearchListResponse {
    /**
     * The items for the current page.
     * @type {Array<ClassInfoResponse>}
     * @memberof ClassInfoSearchListResponse
     */
    data: Array<ClassInfoResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof ClassInfoSearchListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof ClassInfoSearchListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof ClassInfoSearchListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface ClassResponse
 */
export interface ClassResponse {
    /**
     * 
     * @type {string}
     * @memberof ClassResponse
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ClassResponse
     */
    gradeLevel: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ClassSortQueryType {
    Name = 'name',
    ExternalSourceName = 'externalSourceName',
    SynchronizedCourses = 'synchronizedCourses',
    StudentCount = 'studentCount',
    TeacherNames = 'teacherNames'
}

/**
 * 
 * @export
 * @interface CollaborativeTextEditorElementResponse
 */
export interface CollaborativeTextEditorElementResponse {
    /**
     * 
     * @type {string}
     * @memberof CollaborativeTextEditorElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof CollaborativeTextEditorElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof CollaborativeTextEditorElementResponse
     */
    timestamps: TimestampsResponse;
    /**
     * 
     * @type {object}
     * @memberof CollaborativeTextEditorElementResponse
     */
    content: object;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CollaborativeTextEditorParentType {
    ContentElement = 'content-element'
}

/**
 * 
 * @export
 * @interface CollaborativeTextEditorResponse
 */
export interface CollaborativeTextEditorResponse {
    /**
     * 
     * @type {string}
     * @memberof CollaborativeTextEditorResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface CollapsableBodyParams
 */
export interface CollapsableBodyParams {
    /**
     * 
     * @type {boolean}
     * @memberof CollapsableBodyParams
     */
    collapsed: boolean;
}
/**
 * 
 * @export
 * @interface ColorBodyParams
 */
export interface ColorBodyParams {
    /**
     * 
     * @type {MediaBoardColors}
     * @memberof ColorBodyParams
     */
    backgroundColor: MediaBoardColors;
}
/**
 * 
 * @export
 * @interface ColumnResponse
 */
export interface ColumnResponse {
    /**
     * 
     * @type {string}
     * @memberof ColumnResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ColumnResponse
     */
    title: string;
    /**
     * 
     * @type {Array<CardSkeletonResponse>}
     * @memberof ColumnResponse
     */
    cards: Array<CardSkeletonResponse>;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof ColumnResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface ComponentEtherpadPropsImpl
 */
export interface ComponentEtherpadPropsImpl {
    /**
     * description of a Etherpad component
     * @type {string}
     * @memberof ComponentEtherpadPropsImpl
     */
    description: string;
    /**
     * title of a Etherpad component
     * @type {string}
     * @memberof ComponentEtherpadPropsImpl
     */
    title: string;
    /**
     * url of a Etherpad component
     * @type {string}
     * @memberof ComponentEtherpadPropsImpl
     */
    url: string;
}
/**
 * 
 * @export
 * @interface ComponentGeogebraPropsImpl
 */
export interface ComponentGeogebraPropsImpl {
    /**
     * materialId of a Geogebra component
     * @type {string}
     * @memberof ComponentGeogebraPropsImpl
     */
    materialId: string;
}
/**
 * 
 * @export
 * @interface ComponentInternalPropsImpl
 */
export interface ComponentInternalPropsImpl {
    /**
     * url of a Internal component
     * @type {string}
     * @memberof ComponentInternalPropsImpl
     */
    url: string;
}
/**
 * 
 * @export
 * @interface ComponentLernstorePropsImpl
 */
export interface ComponentLernstorePropsImpl {
    /**
     * resources of a Lernstore component
     * @type {Array<string>}
     * @memberof ComponentLernstorePropsImpl
     */
    resources: Array<string>;
}
/**
 * 
 * @export
 * @interface ComponentTextPropsImpl
 */
export interface ComponentTextPropsImpl {
    /**
     * 
     * @type {string}
     * @memberof ComponentTextPropsImpl
     */
    text: string;
}
/**
 * 
 * @export
 * @interface ConfigResponse
 */
export interface ConfigResponse {
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    ACCESSIBILITY_REPORT_EMAIL: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    SC_CONTACT_EMAIL: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_NEW_SCHOOL_ADMINISTRATION_PAGE_AS_DEFAULT_ENABLED: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConfigResponse
     */
    MIGRATION_END_GRACE_PERIOD_MS: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SHOW_OUTDATED_USERS: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_ENABLE_LDAP_SYNC_DURING_MIGRATION: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConfigResponse
     */
    CTL_TOOLS_RELOAD_TIME_MS: number;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SHOW_NEW_CLASS_VIEW_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SHOW_NEW_ROOMS_VIEW_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_CTL_TOOLS_COPY_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_PREFERRED_CTL_TOOLS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SHOW_MIGRATION_WIZARD: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    MIGRATION_WIZARD_DOCUMENTATION_LINK?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_TLDRAW_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    ADMIN_TABLES_DISPLAY_CONSENT_COLUMN: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    ALERT_STATUS_URL: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_ES_COLLECTIONS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_EXTENSIONS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_TEAMS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_LERNSTORE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_ADMIN_TOGGLE_STUDENT_LERNSTORE_VIEW_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    TEACHER_STUDENT_VISIBILITY__IS_CONFIGURABLE: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    TEACHER_STUDENT_VISIBILITY__IS_ENABLED_BY_DEFAULT: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    TEACHER_STUDENT_VISIBILITY__IS_VISIBLE: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SCHOOL_POLICY_ENABLED_NEW: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SCHOOL_TERMS_OF_USE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_VIDEOCONFERENCE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_SUBMISSIONS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_COLLABORATIVE_TEXT_EDITOR_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_LINK_ELEMENT_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_EXTERNAL_TOOLS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_SHARE: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_SOCKET_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COLUMN_BOARD_VIDEOCONFERENCE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COURSE_SHARE: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_LOGIN_LINK_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_LESSON_SHARE: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_TASK_SHARE: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_BOARD_LAYOUT_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_USER_MIGRATION_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    CALENDAR_SERVICE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COPY_SERVICE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_CONSENT_NECESSARY: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COMMON_CARTRIDGE_COURSE_EXPORT_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_COMMON_CARTRIDGE_COURSE_IMPORT_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SCHOOL_SANIS_USER_MIGRATION_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SCHULCONNEX_COURSE_SYNC_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_ALLOW_INSECURE_LDAP_URL_ENABLED: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    GHOST_BASE_URL: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    ROCKETCHAT_SERVICE_ENABLED: boolean;
    /**
     * 
     * @type {Array<LanguageType>}
     * @memberof ConfigResponse
     */
    I18N__AVAILABLE_LANGUAGES: Array<LanguageType>;
    /**
     * 
     * @type {LanguageType}
     * @memberof ConfigResponse
     */
    I18N__DEFAULT_LANGUAGE: LanguageType;
    /**
     * 
     * @type {LanguageType}
     * @memberof ConfigResponse
     */
    I18N__FALLBACK_LANGUAGE: LanguageType;
    /**
     * 
     * @type {Timezone}
     * @memberof ConfigResponse
     */
    I18N__DEFAULT_TIMEZONE: Timezone;
    /**
     * 
     * @type {number}
     * @memberof ConfigResponse
     */
    JWT_SHOW_TIMEOUT_WARNING_SECONDS: number;
    /**
     * 
     * @type {number}
     * @memberof ConfigResponse
     */
    JWT_TIMEOUT_SECONDS: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    NOT_AUTHENTICATED_REDIRECT_URL: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    DOCUMENT_BASE_DIR: string;
    /**
     * 
     * @type {SchulcloudTheme}
     * @memberof ConfigResponse
     */
    SC_THEME: SchulcloudTheme;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    SC_TITLE: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    TRAINING_URL: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_MEDIA_SHELF_ENABLED: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigResponse
     */
    BOARD_COLLABORATION_URI: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_SCHULCONNEX_MEDIA_LICENSE_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_AI_TUTOR_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_ROOMS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_ROOMS_CHANGE_PERMISSIONS_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_EXTERNAL_SYSTEM_LOGOUT_ENABLED: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigResponse
     */
    FEATURE_VIDIS_MEDIA_ACTIVATIONS_ENABLED: boolean;
}
/**
 * 
 * @export
 * @interface ConsentRequestBody
 */
export interface ConsentRequestBody {
    /**
     * The error should follow the OAuth2 error format (e.g. invalid_request, login_required). Defaults to request_denied.
     * @type {string}
     * @memberof ConsentRequestBody
     */
    error?: string;
    /**
     * Debug contains information to help resolve the problem as a developer. Usually not exposed to the public but only in the server logs.
     * @type {string}
     * @memberof ConsentRequestBody
     */
    error_debug?: string;
    /**
     * Description of the error in a human readable format.
     * @type {string}
     * @memberof ConsentRequestBody
     */
    error_description?: string;
    /**
     * Hint to help resolve the error.
     * @type {string}
     * @memberof ConsentRequestBody
     */
    error_hint?: string;
    /**
     * Represents the HTTP status code of the error (e.g. 401 or 403). Defaults to 400.
     * @type {number}
     * @memberof ConsentRequestBody
     */
    status_code?: number;
    /**
     * The Oauth2 client id.
     * @type {Array<string>}
     * @memberof ConsentRequestBody
     */
    grant_scope?: Array<string>;
    /**
     * Remember, if set to true, tells the oauth provider to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope.
     * @type {boolean}
     * @memberof ConsentRequestBody
     */
    remember?: boolean;
    /**
     * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely.
     * @type {number}
     * @memberof ConsentRequestBody
     */
    remember_for?: number;
}
/**
 * 
 * @export
 * @interface ConsentResponse
 */
export interface ConsentResponse {
    /**
     * ACR represents the Authentication AuthorizationContext Class Reference value for this authentication session
     * @type {string}
     * @memberof ConsentResponse
     */
    acr: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConsentResponse
     */
    amr?: Array<string>;
    /**
     * Is the id/authorization challenge of the consent authorization request. It is used to identify the session.
     * @type {string}
     * @memberof ConsentResponse
     */
    challenge: string;
    /**
     * 
     * @type {OauthClientResponse}
     * @memberof ConsentResponse
     */
    client: OauthClientResponse;
    /**
     * 
     * @type {object}
     * @memberof ConsentResponse
     */
    context: object;
    /**
     * LoginChallenge is the login challenge this consent challenge belongs to.
     * @type {string}
     * @memberof ConsentResponse
     */
    login_challenge: string;
    /**
     * LoginSessionID is the login session ID.
     * @type {string}
     * @memberof ConsentResponse
     */
    login_session_id: string;
    /**
     * 
     * @type {OidcContextResponse}
     * @memberof ConsentResponse
     */
    oidc_context: OidcContextResponse;
    /**
     * RequestUrl is the original OAuth 2.0 Authorization URL requested by the OAuth 2.0 client.
     * @type {string}
     * @memberof ConsentResponse
     */
    request_url: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ConsentResponse
     */
    requested_access_token_audience?: Array<string>;
    /**
     * The request scopes of the login request.
     * @type {Array<string>}
     * @memberof ConsentResponse
     */
    requested_scope?: Array<string>;
    /**
     * Skip, if true, implies that the client has requested the same scopes from the same user previously.
     * @type {boolean}
     * @memberof ConsentResponse
     */
    skip: boolean;
    /**
     * Subject is the user id of the end-user that is authenticated.
     * @type {string}
     * @memberof ConsentResponse
     */
    subject: string;
}
/**
 * 
 * @export
 * @interface ConsentSessionResponse
 */
export interface ConsentSessionResponse {
    /**
     * The id of the client.
     * @type {string}
     * @memberof ConsentSessionResponse
     */
    client_id: string;
    /**
     * The name of the client.
     * @type {string}
     * @memberof ConsentSessionResponse
     */
    client_name: string;
    /**
     * The id/challenge of the consent authorization request.
     * @type {string}
     * @memberof ConsentSessionResponse
     */
    challenge: string;
}
/**
 * 
 * @export
 * @interface ConsentsResponse
 */
export interface ConsentsResponse {
    /**
     * 
     * @type {UserConsentResponse}
     * @memberof ConsentsResponse
     */
    userConsent: UserConsentResponse;
    /**
     * 
     * @type {Array<ParentConsentResponse>}
     * @memberof ConsentsResponse
     */
    parentConsents: Array<ParentConsentResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ContentElementType {
    File = 'file',
    Drawing = 'drawing',
    Link = 'link',
    RichText = 'richText',
    SubmissionContainer = 'submissionContainer',
    ExternalTool = 'externalTool',
    CollaborativeTextEditor = 'collaborativeTextEditor',
    VideoConference = 'videoConference',
    Deleted = 'deleted'
}

/**
 * 
 * @export
 * @interface ContextExternalToolBodyParams
 */
export interface ContextExternalToolBodyParams {
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolBodyParams
     */
    contextId: string;
    /**
     * 
     * @type {ToolContextType}
     * @memberof ContextExternalToolBodyParams
     */
    contextType: ToolContextType;
}
/**
 * 
 * @export
 * @interface ContextExternalToolConfigurationStatusResponse
 */
export interface ContextExternalToolConfigurationStatusResponse {
    /**
     * Is the tool outdated on school scope, because of non matching versions or required parameter changes on ExternalTool?
     * @type {boolean}
     * @memberof ContextExternalToolConfigurationStatusResponse
     */
    isOutdatedOnScopeSchool: boolean;
    /**
     * Is the tool outdated on context scope, because of non matching versions or required parameter changes on SchoolExternalTool?
     * @type {boolean}
     * @memberof ContextExternalToolConfigurationStatusResponse
     */
    isOutdatedOnScopeContext: boolean;
    /**
     * True, if a mandatory parameter on the context external tool is missing a value
     * @type {boolean}
     * @memberof ContextExternalToolConfigurationStatusResponse
     */
    isIncompleteOnScopeContext: boolean;
    /**
     * True, if a optional parameter on the context external tool is missing a value. This is happening, when course is copied.
     * @type {boolean}
     * @memberof ContextExternalToolConfigurationStatusResponse
     */
    isIncompleteOperationalOnScopeContext: boolean;
    /**
     * Is the tool deactivated, because of superhero or school administrator
     * @type {boolean}
     * @memberof ContextExternalToolConfigurationStatusResponse
     */
    isDeactivated: boolean;
    /**
     * True if the tool is not licensed for user
     * @type {boolean}
     * @memberof ContextExternalToolConfigurationStatusResponse
     */
    isNotLicensed: boolean;
}
/**
 * 
 * @export
 * @interface ContextExternalToolConfigurationTemplateListResponse
 */
export interface ContextExternalToolConfigurationTemplateListResponse {
    /**
     * 
     * @type {Array<ContextExternalToolConfigurationTemplateResponse>}
     * @memberof ContextExternalToolConfigurationTemplateListResponse
     */
    data: Array<ContextExternalToolConfigurationTemplateResponse>;
}
/**
 * 
 * @export
 * @interface ContextExternalToolConfigurationTemplateResponse
 */
export interface ContextExternalToolConfigurationTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolConfigurationTemplateResponse
     */
    externalToolId: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolConfigurationTemplateResponse
     */
    schoolExternalToolId: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolConfigurationTemplateResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolConfigurationTemplateResponse
     */
    baseUrl: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolConfigurationTemplateResponse
     */
    logoUrl?: string;
    /**
     * 
     * @type {Array<CustomParameterResponse>}
     * @memberof ContextExternalToolConfigurationTemplateResponse
     */
    parameters: Array<CustomParameterResponse>;
}
/**
 * 
 * @export
 * @interface ContextExternalToolCountPerContextResponse
 */
export interface ContextExternalToolCountPerContextResponse {
    /**
     * 
     * @type {number}
     * @memberof ContextExternalToolCountPerContextResponse
     */
    course: number;
    /**
     * 
     * @type {number}
     * @memberof ContextExternalToolCountPerContextResponse
     */
    boardElement: number;
    /**
     * 
     * @type {number}
     * @memberof ContextExternalToolCountPerContextResponse
     */
    mediaBoard: number;
}
/**
 * 
 * @export
 * @interface ContextExternalToolPostParams
 */
export interface ContextExternalToolPostParams {
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolPostParams
     */
    schoolToolId: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolPostParams
     */
    contextId: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolPostParams
     */
    contextType: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolPostParams
     */
    displayName?: string;
    /**
     * 
     * @type {Array<CustomParameterEntryParam>}
     * @memberof ContextExternalToolPostParams
     */
    parameters?: Array<CustomParameterEntryParam>;
}
/**
 * 
 * @export
 * @interface ContextExternalToolResponse
 */
export interface ContextExternalToolResponse {
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolResponse
     */
    schoolToolId: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolResponse
     */
    contextId: string;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolResponse
     */
    contextType: ContextExternalToolResponseContextTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ContextExternalToolResponse
     */
    displayName?: string;
    /**
     * 
     * @type {Array<CustomParameterEntryResponse>}
     * @memberof ContextExternalToolResponse
     */
    parameters: Array<CustomParameterEntryResponse>;
}

/**
    * @export
    * @enum {string}
    */
export enum ContextExternalToolResponseContextTypeEnum {
    Course = 'course',
    BoardElement = 'board-element',
    MediaBoard = 'media-board'
}

/**
 * 
 * @export
 * @interface ContextExternalToolSearchListResponse
 */
export interface ContextExternalToolSearchListResponse {
    /**
     * 
     * @type {Array<ContextExternalToolResponse>}
     * @memberof ContextExternalToolSearchListResponse
     */
    data: Array<ContextExternalToolResponse>;
}
/**
 * 
 * @export
 * @interface CopyApiResponse
 */
export interface CopyApiResponse {
    /**
     * Id of copied element
     * @type {string}
     * @memberof CopyApiResponse
     */
    id?: string;
    /**
     * Title of copied element
     * @type {string}
     * @memberof CopyApiResponse
     */
    title?: string;
    /**
     * Type of copied element
     * @type {string}
     * @memberof CopyApiResponse
     */
    type: CopyApiResponseTypeEnum;
    /**
     * Id of destination parent reference
     * @type {string}
     * @memberof CopyApiResponse
     */
    destinationId?: string;
    /**
     * Copy progress status of copied element
     * @type {string}
     * @memberof CopyApiResponse
     */
    status: CopyApiResponseStatusEnum;
    /**
     * List of included sub elements with recursive type structure
     * @type {Array<CopyApiResponse>}
     * @memberof CopyApiResponse
     */
    elements?: Array<CopyApiResponse>;
}

/**
    * @export
    * @enum {string}
    */
export enum CopyApiResponseTypeEnum {
    Board = 'BOARD',
    Card = 'CARD',
    CollaborativeTextEditorElement = 'COLLABORATIVE_TEXT_EDITOR_ELEMENT',
    Column = 'COLUMN',
    Columnboard = 'COLUMNBOARD',
    Content = 'CONTENT',
    Course = 'COURSE',
    CoursegroupGroup = 'COURSEGROUP_GROUP',
    DeletedElement = 'DELETED_ELEMENT',
    ExternalTool = 'EXTERNAL_TOOL',
    ExternalToolElement = 'EXTERNAL_TOOL_ELEMENT',
    File = 'FILE',
    FileElement = 'FILE_ELEMENT',
    DrawingElement = 'DRAWING_ELEMENT',
    FileGroup = 'FILE_GROUP',
    Leaf = 'LEAF',
    Lesson = 'LESSON',
    LessonContentEtherpad = 'LESSON_CONTENT_ETHERPAD',
    LessonContentGeogebra = 'LESSON_CONTENT_GEOGEBRA',
    LessonContentGroup = 'LESSON_CONTENT_GROUP',
    LessonContentLernstore = 'LESSON_CONTENT_LERNSTORE',
    LessonContentTask = 'LESSON_CONTENT_TASK',
    LessonContentText = 'LESSON_CONTENT_TEXT',
    LernstoreMaterial = 'LERNSTORE_MATERIAL',
    LernstoreMaterialGroup = 'LERNSTORE_MATERIAL_GROUP',
    LinkElement = 'LINK_ELEMENT',
    MediaBoard = 'MEDIA_BOARD',
    MediaLine = 'MEDIA_LINE',
    MediaExternalToolElement = 'MEDIA_EXTERNAL_TOOL_ELEMENT',
    Metadata = 'METADATA',
    RichtextElement = 'RICHTEXT_ELEMENT',
    SubmissionContainerElement = 'SUBMISSION_CONTAINER_ELEMENT',
    SubmissionItem = 'SUBMISSION_ITEM',
    SubmissionGroup = 'SUBMISSION_GROUP',
    Task = 'TASK',
    TaskGroup = 'TASK_GROUP',
    TimeGroup = 'TIME_GROUP',
    UserGroup = 'USER_GROUP',
    VideoConferenceElement = 'VIDEO_CONFERENCE_ELEMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum CopyApiResponseStatusEnum {
    Success = 'success',
    Failure = 'failure',
    NotDoing = 'not-doing',
    NotImplemented = 'not-implemented',
    Partial = 'partial'
}

/**
 * 
 * @export
 * @interface CountyResponse
 */
export interface CountyResponse {
    /**
     * 
     * @type {string}
     * @memberof CountyResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CountyResponse
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CountyResponse
     */
    countyId: number;
    /**
     * 
     * @type {string}
     * @memberof CountyResponse
     */
    antaresKey: string;
}
/**
 * 
 * @export
 * @interface CourseCommonCartridgeMetadataResponse
 */
export interface CourseCommonCartridgeMetadataResponse {
    /**
     * The id of the course
     * @type {string}
     * @memberof CourseCommonCartridgeMetadataResponse
     */
    id: string;
    /**
     * Title of the course
     * @type {string}
     * @memberof CourseCommonCartridgeMetadataResponse
     */
    title: string;
    /**
     * Creation date of the course
     * @type {string}
     * @memberof CourseCommonCartridgeMetadataResponse
     */
    creationDate: string;
    /**
     * Copy right owners of the course
     * @type {Array<string>}
     * @memberof CourseCommonCartridgeMetadataResponse
     */
    copyRightOwners: Array<string>;
}
/**
 * 
 * @export
 * @interface CourseInfoDataResponse
 */
export interface CourseInfoDataResponse {
    /**
     * 
     * @type {string}
     * @memberof CourseInfoDataResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CourseInfoDataResponse
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseInfoDataResponse
     */
    teacherNames: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseInfoDataResponse
     */
    classNames: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CourseInfoDataResponse
     */
    syncedGroup?: string;
}
/**
 * 
 * @export
 * @interface CourseInfoListResponse
 */
export interface CourseInfoListResponse {
    /**
     * The items for the current page.
     * @type {Array<CourseInfoDataResponse>}
     * @memberof CourseInfoListResponse
     */
    data: Array<CourseInfoDataResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof CourseInfoListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof CourseInfoListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof CourseInfoListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface CourseInfoResponse
 */
export interface CourseInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof CourseInfoResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CourseInfoResponse
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CourseMetadataListResponse
 */
export interface CourseMetadataListResponse {
    /**
     * The items for the current page.
     * @type {Array<CourseMetadataResponse>}
     * @memberof CourseMetadataListResponse
     */
    data: Array<CourseMetadataResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof CourseMetadataListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof CourseMetadataListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof CourseMetadataListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface CourseMetadataResponse
 */
export interface CourseMetadataResponse {
    /**
     * The id of the Grid element
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    id: string;
    /**
     * Title of the Grid element
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    title: string;
    /**
     * Short title of the Grid element
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    shortTitle: string;
    /**
     * Color of the Grid element
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    displayColor: string;
    /**
     * Start date of the course
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    startDate?: string;
    /**
     * End date of the course. After this the course counts as archived
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    untilDate?: string;
    /**
     * Start of the copying process if it is still ongoing - otherwise property is not set.
     * @type {string}
     * @memberof CourseMetadataResponse
     */
    copyingSince?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CourseSortProps {
    Name = 'name'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum CourseStatus {
    Archive = 'archive',
    Current = 'current'
}

/**
 * 
 * @export
 * @interface CourseSyncBodyParams
 */
export interface CourseSyncBodyParams {
    /**
     * The id of the group
     * @type {string}
     * @memberof CourseSyncBodyParams
     */
    groupId: string;
}
/**
 * 
 * @export
 * @interface CreateBoardBodyParams
 */
export interface CreateBoardBodyParams {
    /**
     * The title of the board
     * @type {string}
     * @memberof CreateBoardBodyParams
     */
    title: string;
    /**
     * The id of the parent
     * @type {string}
     * @memberof CreateBoardBodyParams
     */
    parentId: string;
    /**
     * The type of the parent
     * @type {BoardParentType}
     * @memberof CreateBoardBodyParams
     */
    parentType: BoardParentType;
    /**
     * The layout of the board
     * @type {BoardLayout}
     * @memberof CreateBoardBodyParams
     */
    layout: BoardLayout;
}
/**
 * 
 * @export
 * @interface CreateBoardResponse
 */
export interface CreateBoardResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateBoardResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface CreateCardBodyParams
 */
export interface CreateCardBodyParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateCardBodyParams
     */
    requiredEmptyElements?: Array<CreateCardBodyParamsRequiredEmptyElementsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateCardBodyParamsRequiredEmptyElementsEnum {
    File = 'file',
    Drawing = 'drawing',
    Link = 'link',
    RichText = 'richText',
    SubmissionContainer = 'submissionContainer',
    ExternalTool = 'externalTool',
    CollaborativeTextEditor = 'collaborativeTextEditor',
    VideoConference = 'videoConference',
    Deleted = 'deleted'
}

/**
 * 
 * @export
 * @interface CreateContentElementBodyParams
 */
export interface CreateContentElementBodyParams {
    /**
     * The type of element
     * @type {ContentElementType}
     * @memberof CreateContentElementBodyParams
     */
    type: ContentElementType;
    /**
     * to bring element to a specific position, default is last position
     * @type {number}
     * @memberof CreateContentElementBodyParams
     */
    toPosition?: number;
}
/**
 * 
 * @export
 * @interface CreateCourseBodyParams
 */
export interface CreateCourseBodyParams {
    /**
     * The title of the course
     * @type {string}
     * @memberof CreateCourseBodyParams
     */
    title: string;
}
/**
 * 
 * @export
 * @interface CreateCourseResponse
 */
export interface CreateCourseResponse {
    /**
     * The id of the created course
     * @type {string}
     * @memberof CreateCourseResponse
     */
    courseId: string;
}
/**
 * 
 * @export
 * @interface CreateMediaElementBodyParams
 */
export interface CreateMediaElementBodyParams {
    /**
     * The id of the line where the element is created
     * @type {string}
     * @memberof CreateMediaElementBodyParams
     */
    lineId: string;
    /**
     * The position where the element is created
     * @type {number}
     * @memberof CreateMediaElementBodyParams
     */
    position: number;
    /**
     * The id of the school external tool
     * @type {string}
     * @memberof CreateMediaElementBodyParams
     */
    schoolExternalToolId: string;
}
/**
 * 
 * @export
 * @interface CreateNewsParams
 */
export interface CreateNewsParams {
    /**
     * Title of the News entity
     * @type {string}
     * @memberof CreateNewsParams
     */
    title: string;
    /**
     * Content of the News entity
     * @type {string}
     * @memberof CreateNewsParams
     */
    content: string;
    /**
     * The point in time from when the News entity schould be displayed. Defaults to now so that the news is published
     * @type {string}
     * @memberof CreateNewsParams
     */
    displayAt?: string;
    /**
     * Target model to which the News entity is related
     * @type {string}
     * @memberof CreateNewsParams
     */
    targetModel: CreateNewsParamsTargetModelEnum;
    /**
     * Specific target id to which the News entity is related
     * @type {string}
     * @memberof CreateNewsParams
     */
    targetId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreateNewsParamsTargetModelEnum {
    Schools = 'schools',
    Courses = 'courses',
    Teams = 'teams'
}

/**
 * 
 * @export
 * @interface CreateRoomBodyParams
 */
export interface CreateRoomBodyParams {
    /**
     * The name of the room
     * @type {string}
     * @memberof CreateRoomBodyParams
     */
    name: string;
    /**
     * The display color of the room
     * @type {RoomColor}
     * @memberof CreateRoomBodyParams
     */
    color: RoomColor;
    /**
     * Start date of the room
     * @type {string}
     * @memberof CreateRoomBodyParams
     */
    startDate?: string;
    /**
     * End date of the room
     * @type {string}
     * @memberof CreateRoomBodyParams
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface CreateSubmissionItemBodyParams
 */
export interface CreateSubmissionItemBodyParams {
    /**
     * Boolean indicating whether the submission is completed.
     * @type {boolean}
     * @memberof CreateSubmissionItemBodyParams
     */
    completed: boolean;
}
/**
 * 
 * @export
 * @interface CustomParameterEntryParam
 */
export interface CustomParameterEntryParam {
    /**
     * 
     * @type {string}
     * @memberof CustomParameterEntryParam
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterEntryParam
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface CustomParameterEntryResponse
 */
export interface CustomParameterEntryResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomParameterEntryResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterEntryResponse
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface CustomParameterPostParams
 */
export interface CustomParameterPostParams {
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    defaultValue?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    regex?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    regexComment?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    scope: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    location: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterPostParams
     */
    type: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomParameterPostParams
     */
    isOptional: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomParameterPostParams
     */
    isProtected: boolean;
}
/**
 * 
 * @export
 * @interface CustomParameterResponse
 */
export interface CustomParameterResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    displayName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    defaultValue?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    regex?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    regexComment?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    scope: CustomParameterResponseScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    location: CustomParameterResponseLocationEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomParameterResponse
     */
    type: CustomParameterResponseTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CustomParameterResponse
     */
    isOptional: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomParameterResponse
     */
    isProtected: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomParameterResponseScopeEnum {
    Global = 'global',
    School = 'school',
    Context = 'context'
}
/**
    * @export
    * @enum {string}
    */
export enum CustomParameterResponseLocationEnum {
    Path = 'path',
    Body = 'body',
    Query = 'query'
}
/**
    * @export
    * @enum {string}
    */
export enum CustomParameterResponseTypeEnum {
    String = 'string',
    Number = 'number',
    Boolean = 'boolean',
    AutoContextid = 'auto_contextid',
    AutoContextname = 'auto_contextname',
    AutoSchoolid = 'auto_schoolid',
    AutoSchoolnumber = 'auto_schoolnumber',
    AutoMediumid = 'auto_mediumid',
    AutoGroupExternaluuid = 'auto_group_externaluuid'
}

/**
 * 
 * @export
 * @interface DashboardGridElementResponse
 */
export interface DashboardGridElementResponse {
    /**
     * The id of the Grid element
     * @type {string}
     * @memberof DashboardGridElementResponse
     */
    id: string;
    /**
     * Title of the Grid element
     * @type {string}
     * @memberof DashboardGridElementResponse
     */
    title: string;
    /**
     * Short title of the Grid element
     * @type {string}
     * @memberof DashboardGridElementResponse
     */
    shortTitle: string;
    /**
     * Color of the Grid element
     * @type {string}
     * @memberof DashboardGridElementResponse
     */
    displayColor: string;
    /**
     * X position of the Grid element
     * @type {number}
     * @memberof DashboardGridElementResponse
     */
    xPosition: number;
    /**
     * Y position of the Grid element
     * @type {number}
     * @memberof DashboardGridElementResponse
     */
    yPosition: number;
    /**
     * The id of the group element
     * @type {string}
     * @memberof DashboardGridElementResponse
     */
    groupId: string;
    /**
     * List of all subelements in the group
     * @type {Array<DashboardGridSubElementResponse>}
     * @memberof DashboardGridElementResponse
     */
    groupElements: Array<DashboardGridSubElementResponse>;
    /**
     * Start of the copying process if it is still ongoing - otherwise property is not set.
     * @type {string}
     * @memberof DashboardGridElementResponse
     */
    copyingSince: string;
    /**
     * Is the course synchronized with a group?
     * @type {boolean}
     * @memberof DashboardGridElementResponse
     */
    isSynchronized: boolean;
}
/**
 * 
 * @export
 * @interface DashboardGridSubElementResponse
 */
export interface DashboardGridSubElementResponse {
    /**
     * The id of the Grid element
     * @type {string}
     * @memberof DashboardGridSubElementResponse
     */
    id: string;
    /**
     * Title of the Grid element
     * @type {string}
     * @memberof DashboardGridSubElementResponse
     */
    title: string;
    /**
     * Short title of the Grid element
     * @type {string}
     * @memberof DashboardGridSubElementResponse
     */
    shortTitle: string;
    /**
     * Color of the Grid element
     * @type {string}
     * @memberof DashboardGridSubElementResponse
     */
    displayColor: string;
}
/**
 * 
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
    /**
     * The id of the Dashboard entity
     * @type {string}
     * @memberof DashboardResponse
     */
    id: string;
    /**
     * List of all elements visible on the dashboard
     * @type {Array<DashboardGridElementResponse>}
     * @memberof DashboardResponse
     */
    gridElements: Array<DashboardGridElementResponse>;
}
/**
 * 
 * @export
 * @interface DeletedElementContent
 */
export interface DeletedElementContent {
    /**
     * 
     * @type {string}
     * @memberof DeletedElementContent
     */
    title: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof DeletedElementContent
     */
    deletedElementType: ContentElementType;
    /**
     * 
     * @type {string}
     * @memberof DeletedElementContent
     */
    description: string;
}
/**
 * 
 * @export
 * @interface DeletedElementResponse
 */
export interface DeletedElementResponse {
    /**
     * 
     * @type {string}
     * @memberof DeletedElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof DeletedElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {DeletedElementContent}
     * @memberof DeletedElementResponse
     */
    content: DeletedElementContent;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof DeletedElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface DrawingContentBody
 */
export interface DrawingContentBody {
    /**
     * 
     * @type {string}
     * @memberof DrawingContentBody
     */
    description: string;
}
/**
 * 
 * @export
 * @interface DrawingElementContent
 */
export interface DrawingElementContent {
    /**
     * 
     * @type {string}
     * @memberof DrawingElementContent
     */
    description: string;
}
/**
 * 
 * @export
 * @interface DrawingElementContentBody
 */
export interface DrawingElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof DrawingElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {DrawingContentBody}
     * @memberof DrawingElementContentBody
     */
    content: DrawingContentBody;
}
/**
 * 
 * @export
 * @interface DrawingElementResponse
 */
export interface DrawingElementResponse {
    /**
     * 
     * @type {string}
     * @memberof DrawingElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof DrawingElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof DrawingElementResponse
     */
    timestamps: TimestampsResponse;
    /**
     * 
     * @type {DrawingElementContent}
     * @memberof DrawingElementResponse
     */
    content: DrawingElementContent;
}
/**
 * 
 * @export
 * @interface EntityNotFoundError
 */
export interface EntityNotFoundError {
    /**
     * The response status code.
     * @type {number}
     * @memberof EntityNotFoundError
     */
    code: number;
    /**
     * The error type.
     * @type {string}
     * @memberof EntityNotFoundError
     */
    type: string;
    /**
     * The error title.
     * @type {string}
     * @memberof EntityNotFoundError
     */
    title: string;
    /**
     * The error message.
     * @type {string}
     * @memberof EntityNotFoundError
     */
    message: string;
    /**
     * The error details.
     * @type {object}
     * @memberof EntityNotFoundError
     */
    details?: object;
}
/**
 * 
 * @export
 * @interface ExternalSourceResponse
 */
export interface ExternalSourceResponse {
    /**
     * 
     * @type {string}
     * @memberof ExternalSourceResponse
     */
    externalId: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalSourceResponse
     */
    systemId: string;
}
/**
 * 
 * @export
 * @interface ExternalToolBulkCreateParams
 */
export interface ExternalToolBulkCreateParams {
    /**
     * List of external tools
     * @type {Array<ExternalToolCreateParams>}
     * @memberof ExternalToolBulkCreateParams
     */
    data: Array<ExternalToolCreateParams>;
}
/**
 * 
 * @export
 * @interface ExternalToolContentBody
 */
export interface ExternalToolContentBody {
    /**
     * 
     * @type {string}
     * @memberof ExternalToolContentBody
     */
    contextExternalToolId?: string;
}
/**
 * 
 * @export
 * @interface ExternalToolCreateParams
 */
export interface ExternalToolCreateParams {
    /**
     * Name of the external tool
     * @type {string}
     * @memberof ExternalToolCreateParams
     */
    name: string;
    /**
     * Description of the external tool
     * @type {string}
     * @memberof ExternalToolCreateParams
     */
    description?: string;
    /**
     * URL of the external tool
     * @type {string}
     * @memberof ExternalToolCreateParams
     */
    url?: string;
    /**
     * URL of the logo of the external tool
     * @type {string}
     * @memberof ExternalToolCreateParams
     */
    logoUrl?: string;
    /**
     * URL of the thumbnail of the external tool
     * @type {string}
     * @memberof ExternalToolCreateParams
     */
    thumbnailUrl?: string;
    /**
     * Configuration of the external tool
     * @type {BasicToolConfigParams | Lti11ToolConfigCreateParams | Oauth2ToolConfigCreateParams}
     * @memberof ExternalToolCreateParams
     */
    config: BasicToolConfigParams | Lti11ToolConfigCreateParams | Oauth2ToolConfigCreateParams;
    /**
     * Custom parameters of the external tool
     * @type {Array<CustomParameterPostParams>}
     * @memberof ExternalToolCreateParams
     */
    parameters?: Array<CustomParameterPostParams>;
    /**
     * Tool can be hidden, those tools cant be added to e.g. school, course or board
     * @type {boolean}
     * @memberof ExternalToolCreateParams
     */
    isHidden: boolean;
    /**
     * Tool can be deactivated, related tools can not be added to e.g. school, course or board anymore
     * @type {boolean}
     * @memberof ExternalToolCreateParams
     */
    isDeactivated: boolean;
    /**
     * Tool should be opened in a new tab
     * @type {boolean}
     * @memberof ExternalToolCreateParams
     */
    openNewTab: boolean;
    /**
     * Restrict tools to specific contexts
     * @type {Array<ToolContextType>}
     * @memberof ExternalToolCreateParams
     */
    restrictToContexts?: Array<ToolContextType>;
    /**
     * Medium of the external tool
     * @type {ExternalToolMediumParams}
     * @memberof ExternalToolCreateParams
     */
    medium?: ExternalToolMediumParams;
    /**
     * Should the tool be a preferred tool
     * @type {boolean}
     * @memberof ExternalToolCreateParams
     */
    isPreferred: boolean;
    /**
     * Name of the icon to be rendered when displaying it as a preferred tool
     * @type {string}
     * @memberof ExternalToolCreateParams
     */
    iconName?: string;
}
/**
 * 
 * @export
 * @interface ExternalToolElementContent
 */
export interface ExternalToolElementContent {
    /**
     * 
     * @type {string}
     * @memberof ExternalToolElementContent
     */
    contextExternalToolId: string | null;
}
/**
 * 
 * @export
 * @interface ExternalToolElementContentBody
 */
export interface ExternalToolElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof ExternalToolElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {ExternalToolContentBody}
     * @memberof ExternalToolElementContentBody
     */
    content: ExternalToolContentBody;
}
/**
 * 
 * @export
 * @interface ExternalToolElementResponse
 */
export interface ExternalToolElementResponse {
    /**
     * 
     * @type {string}
     * @memberof ExternalToolElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof ExternalToolElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {ExternalToolElementContent}
     * @memberof ExternalToolElementResponse
     */
    content: ExternalToolElementContent;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof ExternalToolElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface ExternalToolMediumParams
 */
export interface ExternalToolMediumParams {
    /**
     * Id of the medium
     * @type {string}
     * @memberof ExternalToolMediumParams
     */
    mediumId: string;
    /**
     * Publisher of the medium
     * @type {string}
     * @memberof ExternalToolMediumParams
     */
    publisher?: string;
    /**
     * The id of the media source
     * @type {string}
     * @memberof ExternalToolMediumParams
     */
    mediaSourceId?: string;
}
/**
 * 
 * @export
 * @interface ExternalToolMediumResponse
 */
export interface ExternalToolMediumResponse {
    /**
     * Id of the medium
     * @type {string}
     * @memberof ExternalToolMediumResponse
     */
    mediumId: string;
    /**
     * Publisher of the medium
     * @type {string}
     * @memberof ExternalToolMediumResponse
     */
    publisher?: string;
    /**
     * The id of the media source
     * @type {string}
     * @memberof ExternalToolMediumResponse
     */
    mediaSourceId?: string;
}
/**
 * 
 * @export
 * @interface ExternalToolMetadataResponse
 */
export interface ExternalToolMetadataResponse {
    /**
     * 
     * @type {number}
     * @memberof ExternalToolMetadataResponse
     */
    schoolExternalToolCount: number;
    /**
     * 
     * @type {ContextExternalToolCountPerContextResponse}
     * @memberof ExternalToolMetadataResponse
     */
    contextExternalToolCountPerContext: ContextExternalToolCountPerContextResponse;
}
/**
 * 
 * @export
 * @interface ExternalToolResponse
 */
export interface ExternalToolResponse {
    /**
     * Id of the external tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    id: string;
    /**
     * Name of the external tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    name: string;
    /**
     * Description of the external tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    description?: string;
    /**
     * URL of the external tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    url?: string;
    /**
     * URL of the logo of the external tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    logoUrl?: string;
    /**
     * URL of the thumbnail of the external tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    thumbnailUrl?: string;
    /**
     * Configuration of the external tool
     * @type {BasicToolConfigParams | Lti11ToolConfigCreateParams | Oauth2ToolConfigCreateParams}
     * @memberof ExternalToolResponse
     */
    config: BasicToolConfigParams | Lti11ToolConfigCreateParams | Oauth2ToolConfigCreateParams;
    /**
     * Custom parameters of the external tool
     * @type {Array<CustomParameterResponse>}
     * @memberof ExternalToolResponse
     */
    parameters: Array<CustomParameterResponse>;
    /**
     * Is the external tool hidden
     * @type {boolean}
     * @memberof ExternalToolResponse
     */
    isHidden: boolean;
    /**
     * Is the external tool deactivated
     * @type {boolean}
     * @memberof ExternalToolResponse
     */
    isDeactivated: boolean;
    /**
     * Should the external tool be opened in a new tab
     * @type {boolean}
     * @memberof ExternalToolResponse
     */
    openNewTab: boolean;
    /**
     * Contexts in which the external tool is restricted
     * @type {Array<ToolContextType>}
     * @memberof ExternalToolResponse
     */
    restrictToContexts?: Array<ToolContextType>;
    /**
     * Medium of the external tool
     * @type {ExternalToolMediumResponse}
     * @memberof ExternalToolResponse
     */
    medium?: ExternalToolMediumResponse;
    /**
     * Should the tool be a preferred tool
     * @type {boolean}
     * @memberof ExternalToolResponse
     */
    isPreferred: boolean;
    /**
     * Name of the icon to be rendered when displaying it as a preferred tool
     * @type {string}
     * @memberof ExternalToolResponse
     */
    iconName?: string;
}
/**
 * 
 * @export
 * @interface ExternalToolSearchListResponse
 */
export interface ExternalToolSearchListResponse {
    /**
     * The items for the current page.
     * @type {Array<ExternalToolResponse>}
     * @memberof ExternalToolSearchListResponse
     */
    data: Array<ExternalToolResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof ExternalToolSearchListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof ExternalToolSearchListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof ExternalToolSearchListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface ExternalToolUpdateParams
 */
export interface ExternalToolUpdateParams {
    /**
     * ID of the external tool
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    name: string;
    /**
     * Description of the external tool
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    description?: string;
    /**
     * URL of the external tool
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    url?: string;
    /**
     * URL of the logo of the external tool
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    logoUrl?: string;
    /**
     * URL of the thumbnail of the external tool
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    thumbnailUrl?: string;
    /**
     * Configuration of the external tool
     * @type {BasicToolConfigParams | Lti11ToolConfigUpdateParams | Oauth2ToolConfigUpdateParams}
     * @memberof ExternalToolUpdateParams
     */
    config: BasicToolConfigParams | Lti11ToolConfigUpdateParams | Oauth2ToolConfigUpdateParams;
    /**
     * Custom parameters of the external tool
     * @type {Array<CustomParameterPostParams>}
     * @memberof ExternalToolUpdateParams
     */
    parameters?: Array<CustomParameterPostParams>;
    /**
     * 
     * @type {boolean}
     * @memberof ExternalToolUpdateParams
     */
    isHidden: boolean;
    /**
     * Tool can be deactivated, related tools can not be added to e.g. school, course or board anymore
     * @type {boolean}
     * @memberof ExternalToolUpdateParams
     */
    isDeactivated: boolean;
    /**
     * Open the tool in a new tab
     * @type {boolean}
     * @memberof ExternalToolUpdateParams
     */
    openNewTab: boolean;
    /**
     * Restrict the tool to certain contexts
     * @type {Array<ToolContextType>}
     * @memberof ExternalToolUpdateParams
     */
    restrictToContexts?: Array<ToolContextType>;
    /**
     * Medium of the external tool
     * @type {ExternalToolMediumParams}
     * @memberof ExternalToolUpdateParams
     */
    medium?: ExternalToolMediumParams;
    /**
     * Should the tool be a preferred tool
     * @type {boolean}
     * @memberof ExternalToolUpdateParams
     */
    isPreferred: boolean;
    /**
     * Name of the icon to be rendered when displaying it as a preferred tool
     * @type {string}
     * @memberof ExternalToolUpdateParams
     */
    iconName?: string;
}
/**
 * 
 * @export
 * @interface FederalStateResponse
 */
export interface FederalStateResponse {
    /**
     * 
     * @type {string}
     * @memberof FederalStateResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FederalStateResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FederalStateResponse
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof FederalStateResponse
     */
    logoUrl: string;
    /**
     * 
     * @type {Array<CountyResponse>}
     * @memberof FederalStateResponse
     */
    counties: Array<CountyResponse>;
}
/**
 * 
 * @export
 * @interface FileContentBody
 */
export interface FileContentBody {
    /**
     * 
     * @type {string}
     * @memberof FileContentBody
     */
    caption: string;
    /**
     * 
     * @type {string}
     * @memberof FileContentBody
     */
    alternativeText: string;
}
/**
 * 
 * @export
 * @interface FileElementContent
 */
export interface FileElementContent {
    /**
     * 
     * @type {string}
     * @memberof FileElementContent
     */
    caption: string;
    /**
     * 
     * @type {string}
     * @memberof FileElementContent
     */
    alternativeText: string;
}
/**
 * 
 * @export
 * @interface FileElementContentBody
 */
export interface FileElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof FileElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {FileContentBody}
     * @memberof FileElementContentBody
     */
    content: FileContentBody;
}
/**
 * 
 * @export
 * @interface FileElementResponse
 */
export interface FileElementResponse {
    /**
     * 
     * @type {string}
     * @memberof FileElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof FileElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {FileElementContent}
     * @memberof FileElementResponse
     */
    content: FileElementContent;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof FileElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FileStorageType {
    AwsS3 = 'awsS3'
}

/**
 * 
 * @export
 * @interface ForbiddenOperationError
 */
export interface ForbiddenOperationError {
    /**
     * The response status code.
     * @type {number}
     * @memberof ForbiddenOperationError
     */
    code: number;
    /**
     * The error type.
     * @type {string}
     * @memberof ForbiddenOperationError
     */
    type: string;
    /**
     * The error title.
     * @type {string}
     * @memberof ForbiddenOperationError
     */
    title: string;
    /**
     * The error message.
     * @type {string}
     * @memberof ForbiddenOperationError
     */
    message: string;
    /**
     * The error details.
     * @type {object}
     * @memberof ForbiddenOperationError
     */
    details?: object;
}
/**
 * 
 * @export
 * @interface ForceMigrationParams
 */
export interface ForceMigrationParams {
    /**
     * Email of the administrator
     * @type {string}
     * @memberof ForceMigrationParams
     */
    email: string;
    /**
     * Target externalId to link it with an external account
     * @type {string}
     * @memberof ForceMigrationParams
     */
    externalUserId: string;
    /**
     * Target externalId to link it with an external school
     * @type {string}
     * @memberof ForceMigrationParams
     */
    externalSchoolId: string;
    /**
     * Should extended mode be used
     * @type {boolean}
     * @memberof ForceMigrationParams
     */
    forceExtendedMode: boolean;
}
/**
 * 
 * @export
 * @interface GetMetaTagDataBody
 */
export interface GetMetaTagDataBody {
    /**
     * 
     * @type {string}
     * @memberof GetMetaTagDataBody
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GroupListResponse
 */
export interface GroupListResponse {
    /**
     * The items for the current page.
     * @type {Array<GroupResponse>}
     * @memberof GroupListResponse
     */
    data: Array<GroupResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof GroupListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof GroupListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof GroupListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    type: GroupResponseTypeEnum;
    /**
     * 
     * @type {Array<GroupUserResponse>}
     * @memberof GroupResponse
     */
    users: Array<GroupUserResponse>;
    /**
     * 
     * @type {ExternalSourceResponse}
     * @memberof GroupResponse
     */
    externalSource?: ExternalSourceResponse;
    /**
     * 
     * @type {PeriodResponse}
     * @memberof GroupResponse
     */
    validPeriod?: PeriodResponse;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    organizationId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum GroupResponseTypeEnum {
    Class = 'class',
    Course = 'course',
    Room = 'room',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface GroupUserResponse
 */
export interface GroupUserResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupUserResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GroupUserResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GroupUserResponse
     */
    lastName: string;
    /**
     * 
     * @type {RoleName}
     * @memberof GroupUserResponse
     */
    role: RoleName;
}
/**
 * 
 * @export
 * @interface ImportUserListResponse
 */
export interface ImportUserListResponse {
    /**
     * The items for the current page.
     * @type {Array<ImportUserResponse>}
     * @memberof ImportUserListResponse
     */
    data: Array<ImportUserResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof ImportUserListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof ImportUserListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof ImportUserListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface ImportUserResponse
 */
export interface ImportUserResponse {
    /**
     * id reference to a import user
     * @type {string}
     * @memberof ImportUserResponse
     */
    importUserId: string;
    /**
     * login name from external system
     * @type {string}
     * @memberof ImportUserResponse
     */
    loginName: string;
    /**
     * external systems user firstname
     * @type {string}
     * @memberof ImportUserResponse
     */
    firstName: string;
    /**
     * external systems user lastname
     * @type {string}
     * @memberof ImportUserResponse
     */
    lastName: string;
    /**
     * list of user roles from external system: student, teacher, admin
     * @type {Array<string>}
     * @memberof ImportUserResponse
     */
    roleNames: Array<ImportUserResponseRoleNamesEnum>;
    /**
     * names of classes the user attends from external system
     * @type {Array<string>}
     * @memberof ImportUserResponse
     */
    classNames: Array<string>;
    /**
     * assignemnt to a local user account
     * @type {UserMatchResponse}
     * @memberof ImportUserResponse
     */
    match?: UserMatchResponse;
    /**
     * manual flag to apply it as filter
     * @type {boolean}
     * @memberof ImportUserResponse
     */
    flagged: boolean;
    /**
     * exact user roles from the external system
     * @type {Array<string>}
     * @memberof ImportUserResponse
     */
    externalRoleNames?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum ImportUserResponseRoleNamesEnum {
    Student = 'student',
    Teacher = 'teacher',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum InstanceFeature {
    IsTeamCreationByStudentsEnabled = 'isTeamCreationByStudentsEnabled'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum LanguageType {
    De = 'de',
    En = 'en',
    Es = 'es',
    Uk = 'uk'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum LaunchType {
    Basic = 'basic',
    Oauth2 = 'oauth2',
    Lti11BasicLaunch = 'lti11BasicLaunch',
    Lti11ContentItemSelection = 'lti11ContentItemSelection'
}

/**
 * 
 * @export
 * @interface LayoutBodyParams
 */
export interface LayoutBodyParams {
    /**
     * 
     * @type {BoardLayout}
     * @memberof LayoutBodyParams
     */
    layout: BoardLayout;
}
/**
 * 
 * @export
 * @interface LdapAuthorizationBodyParams
 */
export interface LdapAuthorizationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof LdapAuthorizationBodyParams
     */
    systemId: string;
    /**
     * 
     * @type {string}
     * @memberof LdapAuthorizationBodyParams
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof LdapAuthorizationBodyParams
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof LdapAuthorizationBodyParams
     */
    schoolId: string;
}
/**
 * 
 * @export
 * @interface LessonContentResponse
 */
export interface LessonContentResponse {
    /**
     * 
     * @type {ComponentTextPropsImpl | ComponentEtherpadPropsImpl | ComponentGeogebraPropsImpl | ComponentInternalPropsImpl | ComponentLernstorePropsImpl}
     * @memberof LessonContentResponse
     */
    content: ComponentTextPropsImpl | ComponentEtherpadPropsImpl | ComponentGeogebraPropsImpl | ComponentInternalPropsImpl | ComponentLernstorePropsImpl;
    /**
     * The id of the Material entity
     * @type {string}
     * @memberof LessonContentResponse
     * @deprecated
     */
    _id: string;
    /**
     * The id of the Material entity
     * @type {string}
     * @memberof LessonContentResponse
     */
    id: string;
    /**
     * Title of the Material entity
     * @type {string}
     * @memberof LessonContentResponse
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof LessonContentResponse
     */
    component: LessonContentResponseComponentEnum;
    /**
     * 
     * @type {boolean}
     * @memberof LessonContentResponse
     */
    hidden: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum LessonContentResponseComponentEnum {
    Etherpad = 'Etherpad',
    GeoGebra = 'geoGebra',
    Internal = 'internal',
    Resources = 'resources',
    Text = 'text'
}

/**
 * 
 * @export
 * @interface LessonCopyApiParams
 */
export interface LessonCopyApiParams {
    /**
     * Destination course parent Id the lesson is copied to
     * @type {string}
     * @memberof LessonCopyApiParams
     */
    courseId?: string;
}
/**
 * 
 * @export
 * @interface LessonLinkedTaskResponse
 */
export interface LessonLinkedTaskResponse {
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    descriptionInputFormat: LessonLinkedTaskResponseDescriptionInputFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    availableDate: string | null;
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    dueDate: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LessonLinkedTaskResponse
     */
    _private: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LessonLinkedTaskResponse
     */
    publicSubmissions: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof LessonLinkedTaskResponse
     */
    teamSubmissions: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    creator: string | null;
    /**
     * 
     * @type {string}
     * @memberof LessonLinkedTaskResponse
     */
    courseId: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LessonLinkedTaskResponse
     */
    submissionIds: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LessonLinkedTaskResponse
     */
    finishedIds: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum LessonLinkedTaskResponseDescriptionInputFormatEnum {
    PlainText = 'plainText',
    RichTextCk5Simple = 'richTextCk5Simple',
    RichTextCk4 = 'richTextCk4',
    RichTextCk5 = 'richTextCk5'
}

/**
 * 
 * @export
 * @interface LessonMetadataListResponse
 */
export interface LessonMetadataListResponse {
    /**
     * The items for the current page.
     * @type {Array<LessonMetadataResponse>}
     * @memberof LessonMetadataListResponse
     */
    data: Array<LessonMetadataResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof LessonMetadataListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof LessonMetadataListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof LessonMetadataListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface LessonMetadataResponse
 */
export interface LessonMetadataResponse {
    /**
     * The id of the Lesson entity
     * @type {string}
     * @memberof LessonMetadataResponse
     */
    _id: string;
    /**
     * Name of the Lesson entity
     * @type {string}
     * @memberof LessonMetadataResponse
     */
    name: string;
}
/**
 * 
 * @export
 * @interface LessonResponse
 */
export interface LessonResponse {
    /**
     * The id of the Lesson entity
     * @type {string}
     * @memberof LessonResponse
     * @deprecated
     */
    _id: string;
    /**
     * The id of the Lesson entity
     * @type {string}
     * @memberof LessonResponse
     */
    id: string;
    /**
     * Name of the Lesson entity
     * @type {string}
     * @memberof LessonResponse
     */
    name: string;
    /**
     * The id of the Course entity
     * @type {string}
     * @memberof LessonResponse
     */
    courseId?: string;
    /**
     * The id of the Course-group entity
     * @type {string}
     * @memberof LessonResponse
     */
    courseGroupId?: string;
    /**
     * Hidden status of the Lesson entity
     * @type {boolean}
     * @memberof LessonResponse
     */
    hidden: boolean;
    /**
     * Position of the Lesson entity
     * @type {number}
     * @memberof LessonResponse
     */
    position: number;
    /**
     * Contents of the Lesson entity
     * @type {Array<LessonContentResponse>}
     * @memberof LessonResponse
     */
    contents: Array<LessonContentResponse>;
    /**
     * Materials of the Lesson entity
     * @type {Array<MaterialResponse>}
     * @memberof LessonResponse
     */
    materials: Array<MaterialResponse>;
}
/**
 * 
 * @export
 * @interface LinkContentBody
 */
export interface LinkContentBody {
    /**
     * 
     * @type {string}
     * @memberof LinkContentBody
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof LinkContentBody
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof LinkContentBody
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof LinkContentBody
     */
    imageUrl: string;
    /**
     * 
     * @type {string}
     * @memberof LinkContentBody
     */
    originalImageUrl: string;
}
/**
 * 
 * @export
 * @interface LinkElementContent
 */
export interface LinkElementContent {
    /**
     * 
     * @type {string}
     * @memberof LinkElementContent
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof LinkElementContent
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof LinkElementContent
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkElementContent
     */
    originalImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkElementContent
     */
    imageUrl?: string;
}
/**
 * 
 * @export
 * @interface LinkElementContentBody
 */
export interface LinkElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof LinkElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {LinkContentBody}
     * @memberof LinkElementContentBody
     */
    content: LinkContentBody;
}
/**
 * 
 * @export
 * @interface LinkElementResponse
 */
export interface LinkElementResponse {
    /**
     * 
     * @type {string}
     * @memberof LinkElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof LinkElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {LinkElementContent}
     * @memberof LinkElementResponse
     */
    content: LinkElementContent;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof LinkElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface LocalAuthorizationBodyParams
 */
export interface LocalAuthorizationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof LocalAuthorizationBodyParams
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof LocalAuthorizationBodyParams
     */
    password: string;
}
/**
 * 
 * @export
 * @interface LoginRequestBody
 */
export interface LoginRequestBody {
    /**
     * The error should follow the OAuth2 error format (e.g. invalid_request, login_required). Defaults to request_denied.
     * @type {string}
     * @memberof LoginRequestBody
     */
    error?: string;
    /**
     * Debug contains information to help resolve the problem as a developer. Usually not exposed to the public but only in the server logs.
     * @type {string}
     * @memberof LoginRequestBody
     */
    error_debug?: string;
    /**
     * Description of the error in a human readable format.
     * @type {string}
     * @memberof LoginRequestBody
     */
    error_description?: string;
    /**
     * Hint to help resolve the error.
     * @type {string}
     * @memberof LoginRequestBody
     */
    error_hint?: string;
    /**
     * Represents the HTTP status code of the error (e.g. 401 or 403). Defaults to 400.
     * @type {number}
     * @memberof LoginRequestBody
     */
    status_code?: number;
    /**
     * Remember, if set to true, tells the oauth provider to remember this consent authorization and reuse it if the same client asks the same user for the same, or a subset of, scope.
     * @type {boolean}
     * @memberof LoginRequestBody
     */
    remember?: boolean;
    /**
     * RememberFor sets how long the consent authorization should be remembered for in seconds. If set to 0, the authorization will be remembered indefinitely.
     * @type {number}
     * @memberof LoginRequestBody
     */
    remember_for?: number;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    accessToken: string;
}
/**
 * 
 * @export
 * @interface Lti11DeepLinkContentItemListParams
 */
export interface Lti11DeepLinkContentItemListParams {
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkContentItemListParams
     */
    context: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Lti11DeepLinkContentItemListParams
     */
    graph: Array<string>;
}
/**
 * 
 * @export
 * @interface Lti11DeepLinkParams
 */
export interface Lti11DeepLinkParams {
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    lti_message_type: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    lti_version: string;
    /**
     * 
     * @type {Lti11DeepLinkContentItemListParams}
     * @memberof Lti11DeepLinkParams
     */
    content_items?: Lti11DeepLinkContentItemListParams;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    oauth_version: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    oauth_nonce: string;
    /**
     * 
     * @type {number}
     * @memberof Lti11DeepLinkParams
     */
    oauth_timestamp: number;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    oauth_signature_method: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    oauth_consumer_key: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    oauth_signature: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParams
     */
    oauth_callback?: string;
}
/**
 * 
 * @export
 * @interface Lti11DeepLinkParamsRaw
 */
export interface Lti11DeepLinkParamsRaw {
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    lti_message_type: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    lti_version: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    content_items?: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_version: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_nonce: string;
    /**
     * 
     * @type {number}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_timestamp: number;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_signature_method: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_consumer_key: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_signature: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11DeepLinkParamsRaw
     */
    oauth_callback?: string;
}
/**
 * 
 * @export
 * @interface Lti11ToolConfigCreateParams
 */
export interface Lti11ToolConfigCreateParams {
    /**
     * 
     * @type {ToolConfigType}
     * @memberof Lti11ToolConfigCreateParams
     */
    type: ToolConfigType;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigCreateParams
     */
    baseUrl: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigCreateParams
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigCreateParams
     */
    secret: string;
    /**
     * 
     * @type {LtiMessageType}
     * @memberof Lti11ToolConfigCreateParams
     */
    lti_message_type: LtiMessageType;
    /**
     * 
     * @type {LtiPrivacyPermission}
     * @memberof Lti11ToolConfigCreateParams
     */
    privacy_permission: LtiPrivacyPermission;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigCreateParams
     */
    launch_presentation_locale: string;
}
/**
 * 
 * @export
 * @interface Lti11ToolConfigUpdateParams
 */
export interface Lti11ToolConfigUpdateParams {
    /**
     * 
     * @type {ToolConfigType}
     * @memberof Lti11ToolConfigUpdateParams
     */
    type: ToolConfigType;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigUpdateParams
     */
    baseUrl: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigUpdateParams
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigUpdateParams
     */
    secret?: string;
    /**
     * 
     * @type {LtiMessageType}
     * @memberof Lti11ToolConfigUpdateParams
     */
    lti_message_type: LtiMessageType;
    /**
     * 
     * @type {LtiPrivacyPermission}
     * @memberof Lti11ToolConfigUpdateParams
     */
    privacy_permission: LtiPrivacyPermission;
    /**
     * 
     * @type {string}
     * @memberof Lti11ToolConfigUpdateParams
     */
    launch_presentation_locale: string;
}
/**
 * 
 * @export
 * @interface LtiDeepLinkResponse
 */
export interface LtiDeepLinkResponse {
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    mediaType: string;
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    availableFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    availableUntil?: string;
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    submissionFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof LtiDeepLinkResponse
     */
    submissionUntil?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LtiMessageType {
    BasicLtiLaunchRequest = 'basic-lti-launch-request',
    ContentItemSelectionRequest = 'ContentItemSelectionRequest'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum LtiPrivacyPermission {
    Anonymous = 'anonymous',
    EMail = 'e-mail',
    Name = 'name',
    Public = 'public',
    Pseudonymous = 'pseudonymous'
}

/**
 * 
 * @export
 * @interface MaterialResponse
 */
export interface MaterialResponse {
    /**
     * The id of the Material entity
     * @type {string}
     * @memberof MaterialResponse
     */
    _id: string;
    /**
     * The id of the Material entity
     * @type {string}
     * @memberof MaterialResponse
     */
    id: string;
    /**
     * Title of the Material entity
     * @type {string}
     * @memberof MaterialResponse
     */
    title: string;
    /**
     * ?
     * @type {Array<string>}
     * @memberof MaterialResponse
     */
    relatedResources: Array<string>;
    /**
     * Url of the material
     * @type {string}
     * @memberof MaterialResponse
     */
    url: string;
    /**
     * Position of the Lesson entity
     * @type {string}
     * @memberof MaterialResponse
     */
    client: string;
    /**
     * Description of the material license
     * @type {Array<string>}
     * @memberof MaterialResponse
     */
    license: Array<string>;
    /**
     * For material from Merlin, the Merlin reference
     * @type {string}
     * @memberof MaterialResponse
     */
    merlinReference: string;
}
/**
 * 
 * @export
 * @interface MeAccountResponse
 */
export interface MeAccountResponse {
    /**
     * 
     * @type {string}
     * @memberof MeAccountResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface MeResponse
 */
export interface MeResponse {
    /**
     * 
     * @type {MeSchoolResponse}
     * @memberof MeResponse
     */
    school: MeSchoolResponse;
    /**
     * 
     * @type {MeUserResponse}
     * @memberof MeResponse
     */
    user: MeUserResponse;
    /**
     * 
     * @type {Array<MeRoleResponse>}
     * @memberof MeResponse
     */
    roles: Array<MeRoleResponse>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MeResponse
     */
    permissions: Array<string>;
    /**
     * 
     * @type {LanguageType}
     * @memberof MeResponse
     */
    language: LanguageType;
    /**
     * 
     * @type {MeAccountResponse}
     * @memberof MeResponse
     */
    account: MeAccountResponse;
    /**
     * 
     * @type {string}
     * @memberof MeResponse
     */
    systemId?: string;
}
/**
 * 
 * @export
 * @interface MeRoleResponse
 */
export interface MeRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof MeRoleResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MeRoleResponse
     */
    name: string;
}
/**
 * 
 * @export
 * @interface MeSchoolLogoResponse
 */
export interface MeSchoolLogoResponse {
    /**
     * 
     * @type {string}
     * @memberof MeSchoolLogoResponse
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MeSchoolLogoResponse
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface MeSchoolResponse
 */
export interface MeSchoolResponse {
    /**
     * 
     * @type {string}
     * @memberof MeSchoolResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MeSchoolResponse
     */
    name: string;
    /**
     * 
     * @type {MeSchoolLogoResponse}
     * @memberof MeSchoolResponse
     */
    logo: MeSchoolLogoResponse;
}
/**
 * 
 * @export
 * @interface MeUserResponse
 */
export interface MeUserResponse {
    /**
     * 
     * @type {string}
     * @memberof MeUserResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MeUserResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof MeUserResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof MeUserResponse
     */
    customAvatarBackgroundColor?: string;
}
/**
 * 
 * @export
 * @interface MediaAvailableLineElementResponse
 */
export interface MediaAvailableLineElementResponse {
    /**
     * School External tool id of the media available line element
     * @type {string}
     * @memberof MediaAvailableLineElementResponse
     */
    schoolExternalToolId: string;
    /**
     * Name of the media available line element
     * @type {string}
     * @memberof MediaAvailableLineElementResponse
     */
    name: string;
    /**
     * Description of the media available line element
     * @type {string}
     * @memberof MediaAvailableLineElementResponse
     */
    description?: string;
    /**
     * Logo url of the media available line element
     * @type {string}
     * @memberof MediaAvailableLineElementResponse
     */
    logoUrl?: string;
    /**
     * Thumbnail url of the media available line element
     * @type {string}
     * @memberof MediaAvailableLineElementResponse
     */
    thumbnailUrl?: string;
}
/**
 * 
 * @export
 * @interface MediaAvailableLineResponse
 */
export interface MediaAvailableLineResponse {
    /**
     * Available media elements in the line
     * @type {Array<MediaAvailableLineElementResponse>}
     * @memberof MediaAvailableLineResponse
     */
    elements: Array<MediaAvailableLineElementResponse>;
    /**
     * Background color of available media line
     * @type {MediaBoardColors}
     * @memberof MediaAvailableLineResponse
     */
    backgroundColor: MediaBoardColors;
    /**
     * Collapse available media line
     * @type {boolean}
     * @memberof MediaAvailableLineResponse
     */
    collapsed: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaBoardColors {
    Transparent = 'transparent',
    Red = 'red',
    Pink = 'pink',
    Purple = 'purple',
    DeepPurple = 'deepPurple',
    Indigo = 'indigo',
    Blue = 'blue',
    LightBlue = 'lightBlue',
    Cyan = 'cyan',
    Teal = 'teal',
    Green = 'green',
    LightGreen = 'lightGreen',
    Lime = 'lime',
    Yellow = 'yellow',
    Amber = 'amber',
    Orange = 'orange',
    DeepOrange = 'deepOrange',
    Brown = 'brown',
    Grey = 'grey',
    BlueGrey = 'blueGrey'
}

/**
 * 
 * @export
 * @interface MediaBoardResponse
 */
export interface MediaBoardResponse {
    /**
     * The id of the media board
     * @type {string}
     * @memberof MediaBoardResponse
     */
    id: string;
    /**
     * The lines of the media board
     * @type {Array<MediaLineResponse>}
     * @memberof MediaBoardResponse
     */
    lines: Array<MediaLineResponse>;
    /**
     * The timestamps of the media board
     * @type {TimestampsResponse}
     * @memberof MediaBoardResponse
     */
    timestamps: TimestampsResponse;
    /**
     * Layout of media board
     * @type {BoardLayout}
     * @memberof MediaBoardResponse
     */
    layout: BoardLayout;
}
/**
 * 
 * @export
 * @interface MediaExternalToolElementContent
 */
export interface MediaExternalToolElementContent {
    /**
     * The id of the context external tool
     * @type {string}
     * @memberof MediaExternalToolElementContent
     */
    contextExternalToolId: string;
}
/**
 * 
 * @export
 * @interface MediaExternalToolElementResponse
 */
export interface MediaExternalToolElementResponse {
    /**
     * The id of the media external tool element
     * @type {string}
     * @memberof MediaExternalToolElementResponse
     */
    id: string;
    /**
     * The content of the media external tool element
     * @type {MediaExternalToolElementContent}
     * @memberof MediaExternalToolElementResponse
     */
    content: MediaExternalToolElementContent;
    /**
     * The timestamps of the media external tool element
     * @type {TimestampsResponse}
     * @memberof MediaExternalToolElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface MediaLineResponse
 */
export interface MediaLineResponse {
    /**
     * The id of the media line
     * @type {string}
     * @memberof MediaLineResponse
     */
    id: string;
    /**
     * The title of the media line
     * @type {string}
     * @memberof MediaLineResponse
     */
    title: string;
    /**
     * The elements of the media line
     * @type {Array<MediaExternalToolElementResponse | DeletedElementResponse>}
     * @memberof MediaLineResponse
     */
    elements: Array<MediaExternalToolElementResponse | DeletedElementResponse>;
    /**
     * The timestamps of the media line
     * @type {TimestampsResponse}
     * @memberof MediaLineResponse
     */
    timestamps: TimestampsResponse;
    /**
     * The background color of the media line
     * @type {MediaBoardColors}
     * @memberof MediaLineResponse
     */
    backgroundColor: MediaBoardColors;
    /**
     * Collapse the media line
     * @type {boolean}
     * @memberof MediaLineResponse
     */
    collapsed: boolean;
}
/**
 * 
 * @export
 * @interface MediaSchoolLicenseListResponse
 */
export interface MediaSchoolLicenseListResponse {
    /**
     * 
     * @type {Array<MediaSchoolLicenseResponse>}
     * @memberof MediaSchoolLicenseListResponse
     */
    data: Array<MediaSchoolLicenseResponse>;
}
/**
 * 
 * @export
 * @interface MediaSchoolLicenseResponse
 */
export interface MediaSchoolLicenseResponse {
    /**
     * 
     * @type {string}
     * @memberof MediaSchoolLicenseResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MediaSchoolLicenseResponse
     */
    schoolId: string;
    /**
     * 
     * @type {string}
     * @memberof MediaSchoolLicenseResponse
     */
    mediumId: string;
    /**
     * 
     * @type {string}
     * @memberof MediaSchoolLicenseResponse
     */
    mediaSourceId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaSchoolLicenseResponse
     */
    mediaSourceName?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaSourceLicenseType {
    UserLicense = 'user-license',
    SchoolLicense = 'school-license'
}

/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    timestamp: string;
    /**
     * 
     * @type {MessageOrigin}
     * @memberof Message
     */
    origin: MessageOrigin;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface MessageOrigin
 */
export interface MessageOrigin {
    /**
     * 
     * @type {number}
     * @memberof MessageOrigin
     */
    message_id: number;
    /**
     * 
     * @type {string}
     * @memberof MessageOrigin
     */
    page: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetaDataEntityType {
    Unknown = 'unknown',
    External = 'external',
    Course = 'course',
    Board = 'board',
    BoardCard = 'board-card',
    Task = 'task',
    Lesson = 'lesson'
}

/**
 * 
 * @export
 * @interface MetaTagExtractorResponse
 */
export interface MetaTagExtractorResponse {
    /**
     * 
     * @type {string}
     * @memberof MetaTagExtractorResponse
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof MetaTagExtractorResponse
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof MetaTagExtractorResponse
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof MetaTagExtractorResponse
     */
    originalImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof MetaTagExtractorResponse
     */
    imageUrl?: string;
    /**
     * 
     * @type {MetaDataEntityType}
     * @memberof MetaTagExtractorResponse
     */
    type: MetaDataEntityType;
    /**
     * 
     * @type {string}
     * @memberof MetaTagExtractorResponse
     */
    parentTitle?: string;
    /**
     * 
     * @type {MetaDataEntityType}
     * @memberof MetaTagExtractorResponse
     */
    parentType?: MetaDataEntityType;
}
/**
 * 
 * @export
 * @interface MoveCardBodyParams
 */
export interface MoveCardBodyParams {
    /**
     * 
     * @type {string}
     * @memberof MoveCardBodyParams
     */
    toColumnId: string;
    /**
     * 
     * @type {number}
     * @memberof MoveCardBodyParams
     */
    toPosition: number;
}
/**
 * 
 * @export
 * @interface MoveColumnBodyParams
 */
export interface MoveColumnBodyParams {
    /**
     * The id of the target board
     * @type {string}
     * @memberof MoveColumnBodyParams
     */
    toBoardId: string;
    /**
     * 
     * @type {number}
     * @memberof MoveColumnBodyParams
     */
    toPosition: number;
}
/**
 * 
 * @export
 * @interface MoveContentElementBody
 */
export interface MoveContentElementBody {
    /**
     * 
     * @type {string}
     * @memberof MoveContentElementBody
     */
    toCardId: string;
    /**
     * 
     * @type {number}
     * @memberof MoveContentElementBody
     */
    toPosition: number;
}
/**
 * 
 * @export
 * @interface MoveElementBodyParams
 */
export interface MoveElementBodyParams {
    /**
     * The id of the line where the element is moved to
     * @type {string}
     * @memberof MoveElementBodyParams
     */
    toLineId: string;
    /**
     * The position where the element is moved to
     * @type {number}
     * @memberof MoveElementBodyParams
     */
    toPosition: number;
}
/**
 * 
 * @export
 * @interface MoveElementParams
 */
export interface MoveElementParams {
    /**
     * 
     * @type {MoveElementPositionParams}
     * @memberof MoveElementParams
     */
    from: MoveElementPositionParams;
    /**
     * 
     * @type {MoveElementPositionParams}
     * @memberof MoveElementParams
     */
    to: MoveElementPositionParams;
}
/**
 * 
 * @export
 * @interface MoveElementPositionParams
 */
export interface MoveElementPositionParams {
    /**
     * 
     * @type {number}
     * @memberof MoveElementPositionParams
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof MoveElementPositionParams
     */
    y: number;
    /**
     * used to identify a position within a group.
     * @type {number}
     * @memberof MoveElementPositionParams
     */
    groupIndex?: number;
}
/**
 * 
 * @export
 * @interface NewsListResponse
 */
export interface NewsListResponse {
    /**
     * The items for the current page.
     * @type {Array<NewsResponse>}
     * @memberof NewsListResponse
     */
    data: Array<NewsResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof NewsListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof NewsListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof NewsListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface NewsResponse
 */
export interface NewsResponse {
    /**
     * The id of the News entity
     * @type {string}
     * @memberof NewsResponse
     */
    id: string;
    /**
     * Title of the News entity
     * @type {string}
     * @memberof NewsResponse
     */
    title: string;
    /**
     * Content of the News entity
     * @type {string}
     * @memberof NewsResponse
     */
    content: string;
    /**
     * The point in time from when the News entity schould be displayed
     * @type {string}
     * @memberof NewsResponse
     */
    displayAt: string;
    /**
     * The type of source of the News entity
     * @type {string}
     * @memberof NewsResponse
     */
    source?: NewsResponseSourceEnum;
    /**
     * The source description of the News entity
     * @type {string}
     * @memberof NewsResponse
     */
    sourceDescription?: string;
    /**
     * Target model to which the News entity is related
     * @type {NewsTargetModel}
     * @memberof NewsResponse
     */
    targetModel: NewsTargetModel;
    /**
     * Specific target id to which the News entity is related
     * @type {string}
     * @memberof NewsResponse
     */
    targetId: string;
    /**
     * The target object with id and name, could be the school, team, or course name
     * @type {TargetInfoResponse}
     * @memberof NewsResponse
     */
    target: TargetInfoResponse;
    /**
     * The School ownership
     * @type {SchoolInfoResponse}
     * @memberof NewsResponse
     */
    school: SchoolInfoResponse;
    /**
     * Reference to the User that created the News entity
     * @type {UserInfoResponse}
     * @memberof NewsResponse
     */
    creator: UserInfoResponse;
    /**
     * Reference to the User that updated the News entity
     * @type {UserInfoResponse}
     * @memberof NewsResponse
     */
    updater?: UserInfoResponse;
    /**
     * The creation timestamp
     * @type {string}
     * @memberof NewsResponse
     */
    createdAt: string;
    /**
     * The update timestamp
     * @type {string}
     * @memberof NewsResponse
     */
    updatedAt: string;
    /**
     * List of permissions the current user has for the News entity
     * @type {Array<string>}
     * @memberof NewsResponse
     */
    permissions: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum NewsResponseSourceEnum {
    Internal = 'internal',
    Rss = 'rss'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum NewsTargetModel {
    Schools = 'schools',
    Courses = 'courses',
    Teams = 'teams'
}

/**
 * 
 * @export
 * @interface Oauth2AuthorizationBodyParams
 */
export interface Oauth2AuthorizationBodyParams {
    /**
     * 
     * @type {string}
     * @memberof Oauth2AuthorizationBodyParams
     */
    redirectUri: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2AuthorizationBodyParams
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2AuthorizationBodyParams
     */
    systemId: string;
}
/**
 * 
 * @export
 * @interface Oauth2MigrationParams
 */
export interface Oauth2MigrationParams {
    /**
     * 
     * @type {string}
     * @memberof Oauth2MigrationParams
     */
    redirectUri: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2MigrationParams
     */
    code: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2MigrationParams
     */
    systemId: string;
}
/**
 * 
 * @export
 * @interface Oauth2ToolConfigCreateParams
 */
export interface Oauth2ToolConfigCreateParams {
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    baseUrl: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    clientId: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    clientSecret: string;
    /**
     * 
     * @type {boolean}
     * @memberof Oauth2ToolConfigCreateParams
     */
    skipConsent: boolean;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    frontchannelLogoutUri?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    scope?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Oauth2ToolConfigCreateParams
     */
    redirectUris: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigCreateParams
     */
    tokenEndpointAuthMethod: string;
}
/**
 * 
 * @export
 * @interface Oauth2ToolConfigUpdateParams
 */
export interface Oauth2ToolConfigUpdateParams {
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    baseUrl: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    clientId: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    clientSecret?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    skipConsent: boolean;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    frontchannelLogoutUri?: string;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    scope?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    redirectUris: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Oauth2ToolConfigUpdateParams
     */
    tokenEndpointAuthMethod: string;
}
/**
 * 
 * @export
 * @interface OauthClientCreateBody
 */
export interface OauthClientCreateBody {
    /**
     * The Oauth2 client id.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    client_id: string;
    /**
     * The Oauth2 client name.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    client_name: string;
    /**
     * The Oauth2 client secret.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    client_secret: string;
    /**
     * The allowed redirect urls of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientCreateBody
     */
    redirect_uris?: Array<string>;
    /**
     * Requested Client Authentication method for the Token Endpoint. The options are client_secret_post, client_secret_basic, private_key_jwt, and none.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    token_endpoint_auth_method: string;
    /**
     * SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    subject_type: string;
    /**
     * Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    scope?: string;
    /**
     * Thr frontchannel logout uri.
     * @type {string}
     * @memberof OauthClientCreateBody
     */
    frontchannel_logout_uri?: string;
    /**
     * The grant types of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientCreateBody
     */
    grant_types?: Array<string>;
    /**
     * The response types of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientCreateBody
     */
    response_types?: Array<string>;
}
/**
 * 
 * @export
 * @interface OauthClientResponse
 */
export interface OauthClientResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    allowed_cors_origins?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    audience: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    authorization_code_grant_access_token_lifespan: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    authorization_code_grant_id_token_lifespan: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    authorization_code_grant_refresh_token_lifespan: string;
    /**
     * Boolean value specifying whether the RP requires that a sid (session ID) Claim.
     * @type {boolean}
     * @memberof OauthClientResponse
     */
    backchannel_logout_session_required: boolean;
    /**
     * RP URL that will cause the RP to log itself out when sent a Logout Token by the OP.
     * @type {string}
     * @memberof OauthClientResponse
     */
    backchannel_logout_uri: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    client_credentials_grant_access_token_lifespan: string;
    /**
     * Id of the client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    client_id: string;
    /**
     * Human-readable string name of the client presented to the end-user.
     * @type {string}
     * @memberof OauthClientResponse
     */
    client_name: string;
    /**
     * SecretExpiresAt is an integer holding the time at which the client secret will expire or 0 if it will not expire.
     * @type {number}
     * @memberof OauthClientResponse
     */
    client_secret_expires_at: number;
    /**
     * ClientUri is an URL string of a web page providing information about the client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    client_uri: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    contacts?: Array<string>;
    /**
     * CreatedAt returns the timestamp of the clients creation.
     * @type {string}
     * @memberof OauthClientResponse
     */
    created_at: string;
    /**
     * Boolean value specifying whether the RP requires that iss (issuer) and sid (session ID) query parameters.
     * @type {boolean}
     * @memberof OauthClientResponse
     */
    frontchannel_logout_session_required: boolean;
    /**
     * RP URL that will cause the RP to log itself out when rendered in an iframe by the OP.
     * @type {string}
     * @memberof OauthClientResponse
     */
    frontchannel_logout_uri: string;
    /**
     * The grant types of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    grant_types?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    implicit_grant_access_token_lifespan: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    implicit_grant_id_token_lifespan: string;
    /**
     * 
     * @type {object}
     * @memberof OauthClientResponse
     */
    jwks: object;
    /**
     * URL for the clients JSON Web Key Set [JWK] document
     * @type {string}
     * @memberof OauthClientResponse
     */
    jwks_uri: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    jwt_bearer_grant_access_token_lifespan: string;
    /**
     * LogoUri is an URL string that references a logo for the client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    logo_uri: string;
    /**
     * 
     * @type {object}
     * @memberof OauthClientResponse
     */
    metadata: object;
    /**
     * Owner is a string identifying the owner of the OAuth 2.0 Client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    owner: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    password_grant_access_token_lifespan: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    password_grant_refresh_token_lifespan: string;
    /**
     * PolicyUri is a URL string that points to a human-readable privacy policy document
     * @type {string}
     * @memberof OauthClientResponse
     */
    policy_uri: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    post_logout_redirect_uris?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    redirect_uris?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    refresh_token_grant_access_token_lifespan: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    refresh_token_grant_id_token_lifespan: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    refresh_token_grant_refresh_token_lifespan: string;
    /**
     * RegistrationAccessToken can be used to update, get, or delete the OAuth2 Client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    registration_access_token: string;
    /**
     * RegistrationClientURI is the URL used to update, get, or delete the OAuth2 Client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    registration_client_uri: string;
    /**
     * JWS [JWS] alg algorithm [JWA] that MUST be used for signing Request Objects sent to the OP.
     * @type {string}
     * @memberof OauthClientResponse
     */
    request_object_signing_alg: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    request_uris?: Array<string>;
    /**
     * The response types of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientResponse
     */
    response_types?: Array<string>;
    /**
     * Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
     * @type {string}
     * @memberof OauthClientResponse
     */
    scope: string;
    /**
     * URL using the https scheme to be used in calculating Pseudonymous Identifiers by the OP.
     * @type {string}
     * @memberof OauthClientResponse
     */
    sector_identifier_uri: string;
    /**
     * SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public.
     * @type {string}
     * @memberof OauthClientResponse
     */
    subject_type: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    token_endpoint_auth_method: string;
    /**
     * 
     * @type {string}
     * @memberof OauthClientResponse
     */
    token_endpoint_auth_signing_alg: string;
    /**
     * TermsOfServiceUri is a URL string that points to a human-readable terms of service document for the client.
     * @type {string}
     * @memberof OauthClientResponse
     */
    tos_uri: string;
    /**
     * UpdatedAt returns the timestamp of the last update.
     * @type {string}
     * @memberof OauthClientResponse
     */
    updated_at: string;
    /**
     * JWS alg algorithm [JWA] REQUIRED for signing UserInfo Responses. 
     * @type {string}
     * @memberof OauthClientResponse
     */
    userinfo_signed_response_alg: string;
}
/**
 * 
 * @export
 * @interface OauthClientUpdateBody
 */
export interface OauthClientUpdateBody {
    /**
     * The Oauth2 client name.
     * @type {string}
     * @memberof OauthClientUpdateBody
     */
    client_name: string;
    /**
     * The Oauth2 client secret.
     * @type {string}
     * @memberof OauthClientUpdateBody
     */
    client_secret?: string;
    /**
     * The allowed redirect urls of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientUpdateBody
     */
    redirect_uris?: Array<string>;
    /**
     * Requested Client Authentication method for the Token Endpoint. The options are client_secret_post, client_secret_basic, private_key_jwt, and none.
     * @type {string}
     * @memberof OauthClientUpdateBody
     */
    token_endpoint_auth_method: string;
    /**
     * SubjectType requested for responses to this Client. The subject_types_supported Discovery parameter contains a list of the supported subject_type values for this server. Valid types include pairwise and public.
     * @type {string}
     * @memberof OauthClientUpdateBody
     */
    subject_type: string;
    /**
     * Scope is a string containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens.
     * @type {string}
     * @memberof OauthClientUpdateBody
     */
    scope?: string;
    /**
     * Thr frontchannel logout uri.
     * @type {string}
     * @memberof OauthClientUpdateBody
     */
    frontchannel_logout_uri?: string;
    /**
     * The grant types of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientUpdateBody
     */
    grant_types?: Array<string>;
    /**
     * The response types of the Oauth2 client.
     * @type {Array<string>}
     * @memberof OauthClientUpdateBody
     */
    response_types?: Array<string>;
}
/**
 * 
 * @export
 * @interface OauthConfigResponse
 */
export interface OauthConfigResponse {
    /**
     * Client id
     * @type {string}
     * @memberof OauthConfigResponse
     */
    clientId: string;
    /**
     * Hint for idp redirects (optional)
     * @type {string}
     * @memberof OauthConfigResponse
     */
    idpHint?: string | null;
    /**
     * Redirect uri
     * @type {string}
     * @memberof OauthConfigResponse
     */
    redirectUri: string;
    /**
     * Grant type
     * @type {string}
     * @memberof OauthConfigResponse
     */
    grantType: string;
    /**
     * Token endpoint
     * @type {string}
     * @memberof OauthConfigResponse
     */
    tokenEndpoint: string;
    /**
     * Auth endpoint
     * @type {string}
     * @memberof OauthConfigResponse
     */
    authEndpoint: string;
    /**
     * Response type
     * @type {string}
     * @memberof OauthConfigResponse
     */
    responseType: string;
    /**
     * Scope
     * @type {string}
     * @memberof OauthConfigResponse
     */
    scope: string;
    /**
     * Provider
     * @type {string}
     * @memberof OauthConfigResponse
     */
    provider: string;
    /**
     * Logout endpoint
     * @type {string}
     * @memberof OauthConfigResponse
     */
    logoutEndpoint?: string;
    /**
     * Issuer
     * @type {string}
     * @memberof OauthConfigResponse
     */
    issuer: string;
    /**
     * Jwks endpoint
     * @type {string}
     * @memberof OauthConfigResponse
     */
    jwksEndpoint: string;
    /**
     * End session endpoint
     * @type {string}
     * @memberof OauthConfigResponse
     */
    endSessionEndpoint?: string;
}
/**
 * 
 * @export
 * @interface OauthProviderLoginResponse
 */
export interface OauthProviderLoginResponse {
    /**
     * Id of the corresponding client.
     * @type {string}
     * @memberof OauthProviderLoginResponse
     */
    client_id: string;
    /**
     * The id/challenge of the consent login request.
     * @type {string}
     * @memberof OauthProviderLoginResponse
     */
    challenge: string;
    /**
     * 
     * @type {OauthClientResponse}
     * @memberof OauthProviderLoginResponse
     */
    client: OauthClientResponse;
    /**
     * 
     * @type {OidcContextResponse}
     * @memberof OauthProviderLoginResponse
     */
    oidc_context: OidcContextResponse;
    /**
     * The original oauth2.0 authorization url request by the client.
     * @type {string}
     * @memberof OauthProviderLoginResponse
     */
    request_url: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OauthProviderLoginResponse
     */
    requested_access_token_audience: Array<string>;
    /**
     * The request scopes of the login request.
     * @type {Array<string>}
     * @memberof OauthProviderLoginResponse
     */
    requested_scope?: Array<string>;
    /**
     * The login session id. This parameter is used as sid for the oidc front-/backchannel logout.
     * @type {string}
     * @memberof OauthProviderLoginResponse
     */
    session_id: string;
    /**
     * Skip, if true, implies that the client has requested the same scopes from the same user previously.
     * @type {boolean}
     * @memberof OauthProviderLoginResponse
     */
    skip: boolean;
    /**
     * User id of the end-user that is authenticated.
     * @type {string}
     * @memberof OauthProviderLoginResponse
     */
    subject: string;
}
/**
 * 
 * @export
 * @interface OidcContextResponse
 */
export interface OidcContextResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof OidcContextResponse
     */
    acr_values: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OidcContextResponse
     */
    display: string;
    /**
     * 
     * @type {object}
     * @memberof OidcContextResponse
     */
    id_token_hint_claims: object;
    /**
     * 
     * @type {string}
     * @memberof OidcContextResponse
     */
    login_hint: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof OidcContextResponse
     */
    ui_locales: Array<string>;
}
/**
 * 
 * @export
 * @interface OidcLogoutBodyParams
 */
export interface OidcLogoutBodyParams {
    /**
     * 
     * @type {string}
     * @memberof OidcLogoutBodyParams
     */
    logout_token: string;
}
/**
 * 
 * @export
 * @interface ParentConsentResponse
 */
export interface ParentConsentResponse {
    /**
     * 
     * @type {string}
     * @memberof ParentConsentResponse
     */
    form: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParentConsentResponse
     */
    privacyConsent: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ParentConsentResponse
     */
    termsOfUseConsent: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParentConsentResponse
     */
    dateOfPrivacyConsent: string;
    /**
     * 
     * @type {string}
     * @memberof ParentConsentResponse
     */
    dateOfTermsOfUseConsent: string;
    /**
     * 
     * @type {string}
     * @memberof ParentConsentResponse
     */
    _id: string;
}
/**
 * 
 * @export
 * @interface PassOwnershipBodyParams
 */
export interface PassOwnershipBodyParams {
    /**
     * The IDs of the users
     * @type {string}
     * @memberof PassOwnershipBodyParams
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface PatchGroupParams
 */
export interface PatchGroupParams {
    /**
     * Title of the Group grid element
     * @type {string}
     * @memberof PatchGroupParams
     */
    title: string;
}
/**
 * 
 * @export
 * @interface PatchMyAccountParams
 */
export interface PatchMyAccountParams {
    /**
     * The current user password to authorize the update action.
     * @type {string}
     * @memberof PatchMyAccountParams
     */
    passwordOld: string;
    /**
     * The new password for the current user.
     * @type {string}
     * @memberof PatchMyAccountParams
     */
    passwordNew?: string;
    /**
     * The new email address for the current user.
     * @type {string}
     * @memberof PatchMyAccountParams
     */
    email?: string;
    /**
     * The new first name for the current user.
     * @type {string}
     * @memberof PatchMyAccountParams
     */
    firstName?: string;
    /**
     * The new last name for the current user.
     * @type {string}
     * @memberof PatchMyAccountParams
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface PatchMyPasswordParams
 */
export interface PatchMyPasswordParams {
    /**
     * The new user password.
     * @type {string}
     * @memberof PatchMyPasswordParams
     */
    password: string;
    /**
     * The confirmed new user password. Must match the password field.
     * @type {string}
     * @memberof PatchMyPasswordParams
     */
    confirmPassword: string;
}
/**
 * 
 * @export
 * @interface PatchOrderParams
 */
export interface PatchOrderParams {
    /**
     * Array ids determining the new order
     * @type {Array<string>}
     * @memberof PatchOrderParams
     */
    elements: Array<string>;
}
/**
 * 
 * @export
 * @interface PatchVisibilityParams
 */
export interface PatchVisibilityParams {
    /**
     * true to publish the element, false to unpublish
     * @type {boolean}
     * @memberof PatchVisibilityParams
     */
    visibility: boolean;
}
/**
 * 
 * @export
 * @interface PeriodResponse
 */
export interface PeriodResponse {
    /**
     * 
     * @type {string}
     * @memberof PeriodResponse
     */
    from: string;
    /**
     * 
     * @type {string}
     * @memberof PeriodResponse
     */
    until: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Permission {
    AccountCreate = 'ACCOUNT_CREATE',
    AccountDelete = 'ACCOUNT_DELETE',
    AccountEdit = 'ACCOUNT_EDIT',
    AccountView = 'ACCOUNT_VIEW',
    AddSchoolMembers = 'ADD_SCHOOL_MEMBERS',
    AdminEdit = 'ADMIN_EDIT',
    AdminView = 'ADMIN_VIEW',
    BaseView = 'BASE_VIEW',
    CalendarCreate = 'CALENDAR_CREATE',
    CalendarEdit = 'CALENDAR_EDIT',
    CalendarView = 'CALENDAR_VIEW',
    ChangeTeamRoles = 'CHANGE_TEAM_ROLES',
    ClassCreate = 'CLASS_CREATE',
    ClassEdit = 'CLASS_EDIT',
    ClassFullAdmin = 'CLASS_FULL_ADMIN',
    ClassList = 'CLASS_LIST',
    ClassRemove = 'CLASS_REMOVE',
    ClassView = 'CLASS_VIEW',
    CommentsCreate = 'COMMENTS_CREATE',
    CommentsEdit = 'COMMENTS_EDIT',
    CommentsView = 'COMMENTS_VIEW',
    ContentNonOerView = 'CONTENT_NON_OER_VIEW',
    ContentView = 'CONTENT_VIEW',
    ContextToolAdmin = 'CONTEXT_TOOL_ADMIN',
    ContextToolUser = 'CONTEXT_TOOL_USER',
    CoursegroupCreate = 'COURSEGROUP_CREATE',
    CoursegroupEdit = 'COURSEGROUP_EDIT',
    CourseAdministration = 'COURSE_ADMINISTRATION',
    CourseCreate = 'COURSE_CREATE',
    CourseDelete = 'COURSE_DELETE',
    CourseEdit = 'COURSE_EDIT',
    CourseRemove = 'COURSE_REMOVE',
    CourseView = 'COURSE_VIEW',
    CreateSupportJwt = 'CREATE_SUPPORT_JWT',
    CreateTopicsAndTasks = 'CREATE_TOPICS_AND_TASKS',
    DashboardView = 'DASHBOARD_VIEW',
    DatasourcesCreate = 'DATASOURCES_CREATE',
    DatasourcesDelete = 'DATASOURCES_DELETE',
    DatasourcesEdit = 'DATASOURCES_EDIT',
    DatasourcesRun = 'DATASOURCES_RUN',
    DatasourcesRunView = 'DATASOURCES_RUN_VIEW',
    DatasourcesView = 'DATASOURCES_VIEW',
    DefaultFilePermissions = 'DEFAULT_FILE_PERMISSIONS',
    DeleteTeam = 'DELETE_TEAM',
    EditAllFiles = 'EDIT_ALL_FILES',
    EnterthecloudStart = 'ENTERTHECLOUD_START',
    FederalstateCreate = 'FEDERALSTATE_CREATE',
    FederalstateEdit = 'FEDERALSTATE_EDIT',
    FederalstateView = 'FEDERALSTATE_VIEW',
    FilestorageCreate = 'FILESTORAGE_CREATE',
    FilestorageEdit = 'FILESTORAGE_EDIT',
    FilestorageRemove = 'FILESTORAGE_REMOVE',
    FilestorageView = 'FILESTORAGE_VIEW',
    FileCreate = 'FILE_CREATE',
    FileDelete = 'FILE_DELETE',
    FileMove = 'FILE_MOVE',
    FolderCreate = 'FOLDER_CREATE',
    FolderDelete = 'FOLDER_DELETE',
    GroupList = 'GROUP_LIST',
    GroupFullAdmin = 'GROUP_FULL_ADMIN',
    GroupView = 'GROUP_VIEW',
    HelpdeskCreate = 'HELPDESK_CREATE',
    HelpdeskEdit = 'HELPDESK_EDIT',
    HelpdeskView = 'HELPDESK_VIEW',
    HomeworkCreate = 'HOMEWORK_CREATE',
    HomeworkEdit = 'HOMEWORK_EDIT',
    HomeworkView = 'HOMEWORK_VIEW',
    ImportUserMigrate = 'IMPORT_USER_MIGRATE',
    ImportUserUpdate = 'IMPORT_USER_UPDATE',
    ImportUserView = 'IMPORT_USER_VIEW',
    InstanceView = 'INSTANCE_VIEW',
    InviteAdministrators = 'INVITE_ADMINISTRATORS',
    InviteExperts = 'INVITE_EXPERTS',
    JoinMeeting = 'JOIN_MEETING',
    LeaveTeam = 'LEAVE_TEAM',
    LernstoreView = 'LERNSTORE_VIEW',
    LessonsCreate = 'LESSONS_CREATE',
    LessonsView = 'LESSONS_VIEW',
    LinkCreate = 'LINK_CREATE',
    MediaSchoolLicenseAdmin = 'MEDIA_SCHOOL_LICENSE_ADMIN',
    NewsCreate = 'NEWS_CREATE',
    NewsEdit = 'NEWS_EDIT',
    NewsView = 'NEWS_VIEW',
    NextcloudUser = 'NEXTCLOUD_USER',
    NotificationCreate = 'NOTIFICATION_CREATE',
    NotificationEdit = 'NOTIFICATION_EDIT',
    NotificationView = 'NOTIFICATION_VIEW',
    OauthClientEdit = 'OAUTH_CLIENT_EDIT',
    OauthClientView = 'OAUTH_CLIENT_VIEW',
    PasswordEdit = 'PASSWORD_EDIT',
    PwrecoveryCreate = 'PWRECOVERY_CREATE',
    PwrecoveryEdit = 'PWRECOVERY_EDIT',
    PwrecoveryView = 'PWRECOVERY_VIEW',
    ReleasesCreate = 'RELEASES_CREATE',
    ReleasesEdit = 'RELEASES_EDIT',
    ReleasesView = 'RELEASES_VIEW',
    RemoveMembers = 'REMOVE_MEMBERS',
    RenameTeam = 'RENAME_TEAM',
    RequestConsents = 'REQUEST_CONSENTS',
    RoleCreate = 'ROLE_CREATE',
    RoleEdit = 'ROLE_EDIT',
    RoleView = 'ROLE_VIEW',
    RoomCreate = 'ROOM_CREATE',
    RoomEdit = 'ROOM_EDIT',
    RoomView = 'ROOM_VIEW',
    RoomDelete = 'ROOM_DELETE',
    RoomLeave = 'ROOM_LEAVE',
    RoomMembersAdd = 'ROOM_MEMBERS_ADD',
    RoomMembersRemove = 'ROOM_MEMBERS_REMOVE',
    RoomMembersChangeRole = 'ROOM_MEMBERS_CHANGE_ROLE',
    RoomChangeOwner = 'ROOM_CHANGE_OWNER',
    SchoolChatManage = 'SCHOOL_CHAT_MANAGE',
    SchoolCreate = 'SCHOOL_CREATE',
    SchoolEdit = 'SCHOOL_EDIT',
    SchoolEditAll = 'SCHOOL_EDIT_ALL',
    SchoolLogoManage = 'SCHOOL_LOGO_MANAGE',
    SchoolNewsEdit = 'SCHOOL_NEWS_EDIT',
    SchoolPermissionChange = 'SCHOOL_PERMISSION_CHANGE',
    SchoolPermissionView = 'SCHOOL_PERMISSION_VIEW',
    SchoolStudentTeamManage = 'SCHOOL_STUDENT_TEAM_MANAGE',
    SchoolSystemEdit = 'SCHOOL_SYSTEM_EDIT',
    SchoolSystemView = 'SCHOOL_SYSTEM_VIEW',
    SchoolToolAdmin = 'SCHOOL_TOOL_ADMIN',
    ScopePermissionsView = 'SCOPE_PERMISSIONS_VIEW',
    StartMeeting = 'START_MEETING',
    StudentCreate = 'STUDENT_CREATE',
    StudentDelete = 'STUDENT_DELETE',
    StudentEdit = 'STUDENT_EDIT',
    StudentList = 'STUDENT_LIST',
    StudentSkipRegistration = 'STUDENT_SKIP_REGISTRATION',
    SubmissionsCreate = 'SUBMISSIONS_CREATE',
    SubmissionsEdit = 'SUBMISSIONS_EDIT',
    SubmissionsSchoolView = 'SUBMISSIONS_SCHOOL_VIEW',
    SubmissionsView = 'SUBMISSIONS_VIEW',
    SyncStart = 'SYNC_START',
    SystemCreate = 'SYSTEM_CREATE',
    SystemEdit = 'SYSTEM_EDIT',
    SystemView = 'SYSTEM_VIEW',
    TaskDashboardTeacherViewV3 = 'TASK_DASHBOARD_TEACHER_VIEW_V3',
    TaskDashboardViewV3 = 'TASK_DASHBOARD_VIEW_V3',
    TeacherCreate = 'TEACHER_CREATE',
    TeacherDelete = 'TEACHER_DELETE',
    TeacherEdit = 'TEACHER_EDIT',
    TeacherList = 'TEACHER_LIST',
    TeacherSkipRegistration = 'TEACHER_SKIP_REGISTRATION',
    TeamCreate = 'TEAM_CREATE',
    ToolCreateEtherpad = 'TOOL_CREATE_ETHERPAD',
    TeamEdit = 'TEAM_EDIT',
    TeamInviteExternal = 'TEAM_INVITE_EXTERNAL',
    TeamView = 'TEAM_VIEW',
    ToolAdmin = 'TOOL_ADMIN',
    ToolCreate = 'TOOL_CREATE',
    ToolEdit = 'TOOL_EDIT',
    ToolNewView = 'TOOL_NEW_VIEW',
    ToolView = 'TOOL_VIEW',
    TopicCreate = 'TOPIC_CREATE',
    TopicEdit = 'TOPIC_EDIT',
    TopicView = 'TOPIC_VIEW',
    UploadFiles = 'UPLOAD_FILES',
    UseLibreoffice = 'USE_LIBREOFFICE',
    UseRocketchat = 'USE_ROCKETCHAT',
    UsergroupCreate = 'USERGROUP_CREATE',
    UsergroupEdit = 'USERGROUP_EDIT',
    UsergroupView = 'USERGROUP_VIEW',
    UserChangeOwnName = 'USER_CHANGE_OWN_NAME',
    UserCreate = 'USER_CREATE',
    UserLoginMigrationAdmin = 'USER_LOGIN_MIGRATION_ADMIN',
    UserLoginMigrationRollback = 'USER_LOGIN_MIGRATION_ROLLBACK',
    UserLoginMigrationForce = 'USER_LOGIN_MIGRATION_FORCE',
    UserMigrate = 'USER_MIGRATE',
    UserUpdate = 'USER_UPDATE',
    YearsEdit = 'YEARS_EDIT'
}

/**
 * 
 * @export
 * @interface PreferredToolListResponse
 */
export interface PreferredToolListResponse {
    /**
     * 
     * @type {Array<PreferredToolResponse>}
     * @memberof PreferredToolListResponse
     */
    data: Array<PreferredToolResponse>;
}
/**
 * 
 * @export
 * @interface PreferredToolResponse
 */
export interface PreferredToolResponse {
    /**
     * Id of the school external tool
     * @type {string}
     * @memberof PreferredToolResponse
     */
    schoolExternalToolId: string;
    /**
     * Name of the external tool
     * @type {string}
     * @memberof PreferredToolResponse
     */
    name: string;
    /**
     * Name of the icon to be rendered when displaying it as a preferred tool
     * @type {string}
     * @memberof PreferredToolResponse
     */
    iconName: string;
}
/**
 * 
 * @export
 * @interface ProviderConfigResponse
 */
export interface ProviderConfigResponse {
    /**
     * 
     * @type {string}
     * @memberof ProviderConfigResponse
     */
    provider: string;
}
/**
 * 
 * @export
 * @interface PseudonymResponse
 */
export interface PseudonymResponse {
    /**
     * 
     * @type {string}
     * @memberof PseudonymResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PseudonymResponse
     */
    toolId: string;
    /**
     * 
     * @type {string}
     * @memberof PseudonymResponse
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface PublicSystemListResponse
 */
export interface PublicSystemListResponse {
    /**
     * 
     * @type {Array<PublicSystemResponse>}
     * @memberof PublicSystemListResponse
     */
    data: Array<PublicSystemResponse>;
}
/**
 * 
 * @export
 * @interface PublicSystemResponse
 */
export interface PublicSystemResponse {
    /**
     * Id of the system.
     * @type {string}
     * @memberof PublicSystemResponse
     */
    id: string;
    /**
     * Flag to request only systems with oauth-config.
     * @type {string}
     * @memberof PublicSystemResponse
     */
    type?: string | null;
    /**
     * Alias of the system.
     * @type {string}
     * @memberof PublicSystemResponse
     */
    alias?: string | null;
    /**
     * Display name of the system.
     * @type {string}
     * @memberof PublicSystemResponse
     */
    displayName?: string | null;
    /**
     * Oauth config of the system.
     * @type {OauthConfigResponse}
     * @memberof PublicSystemResponse
     */
    oauthConfig?: OauthConfigResponse | null;
}
/**
 * 
 * @export
 * @interface RedirectResponse
 */
export interface RedirectResponse {
    /**
     * RedirectURL is the URL which you should redirect the user to once the authentication process is completed.
     * @type {string}
     * @memberof RedirectResponse
     */
    redirect_to: string;
}
/**
 * 
 * @export
 * @interface RemoveRoomMembersBodyParams
 */
export interface RemoveRoomMembersBodyParams {
    /**
     * The IDs of the users
     * @type {Array<string>}
     * @memberof RemoveRoomMembersBodyParams
     */
    userIds: Array<string>;
}
/**
 * 
 * @export
 * @interface RenameBodyParams
 */
export interface RenameBodyParams {
    /**
     * 
     * @type {string}
     * @memberof RenameBodyParams
     */
    title: string;
}
/**
 * 
 * @export
 * @interface ResolvedUserResponse
 */
export interface ResolvedUserResponse {
    /**
     * 
     * @type {string}
     * @memberof ResolvedUserResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUserResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUserResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUserResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUserResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResolvedUserResponse
     */
    roles: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResolvedUserResponse
     */
    permissions: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResolvedUserResponse
     */
    schoolId: string;
}
/**
 * 
 * @export
 * @interface RichText
 */
export interface RichText {
    /**
     * Content of the rich text element
     * @type {string}
     * @memberof RichText
     */
    content: string;
    /**
     * Input format of the rich text element
     * @type {string}
     * @memberof RichText
     */
    type: RichTextTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RichTextTypeEnum {
    PlainText = 'plainText',
    RichTextCk5Simple = 'richTextCk5Simple',
    RichTextCk4 = 'richTextCk4',
    RichTextCk5 = 'richTextCk5'
}

/**
 * 
 * @export
 * @interface RichTextContentBody
 */
export interface RichTextContentBody {
    /**
     * 
     * @type {string}
     * @memberof RichTextContentBody
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof RichTextContentBody
     */
    inputFormat: string;
}
/**
 * 
 * @export
 * @interface RichTextElementContent
 */
export interface RichTextElementContent {
    /**
     * 
     * @type {string}
     * @memberof RichTextElementContent
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof RichTextElementContent
     */
    inputFormat: string;
}
/**
 * 
 * @export
 * @interface RichTextElementContentBody
 */
export interface RichTextElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof RichTextElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {RichTextContentBody}
     * @memberof RichTextElementContentBody
     */
    content: RichTextContentBody;
}
/**
 * 
 * @export
 * @interface RichTextElementResponse
 */
export interface RichTextElementResponse {
    /**
     * 
     * @type {string}
     * @memberof RichTextElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof RichTextElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {RichTextElementContent}
     * @memberof RichTextElementResponse
     */
    content: RichTextElementContent;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof RichTextElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RoleName {
    Administrator = 'administrator',
    CourseAdministrator = 'courseAdministrator',
    CourseStudent = 'courseStudent',
    CourseSubstitutionTeacher = 'courseSubstitutionTeacher',
    GroupSubstitutionTeacher = 'groupSubstitutionTeacher',
    CourseTeacher = 'courseTeacher',
    Demo = 'demo',
    DemoStudent = 'demoStudent',
    DemoTeacher = 'demoTeacher',
    Expert = 'expert',
    GuestTeacher = 'guestTeacher',
    GuestStudent = 'guestStudent',
    Helpdesk = 'helpdesk',
    Roomviewer = 'roomviewer',
    Roomeditor = 'roomeditor',
    Roomadmin = 'roomadmin',
    Roomowner = 'roomowner',
    Student = 'student',
    Superhero = 'superhero',
    Teacher = 'teacher',
    Teamadministrator = 'teamadministrator',
    Teamexpert = 'teamexpert',
    Teamleader = 'teamleader',
    Teammember = 'teammember',
    Teamowner = 'teamowner',
    User = 'user'
}

/**
 * 
 * @export
 * @interface RoomBoardItemResponse
 */
export interface RoomBoardItemResponse {
    /**
     * 
     * @type {string}
     * @memberof RoomBoardItemResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RoomBoardItemResponse
     */
    title: string;
    /**
     * 
     * @type {BoardLayout}
     * @memberof RoomBoardItemResponse
     */
    layout: BoardLayout;
    /**
     * 
     * @type {boolean}
     * @memberof RoomBoardItemResponse
     */
    isVisible: boolean;
    /**
     * 
     * @type {string}
     * @memberof RoomBoardItemResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof RoomBoardItemResponse
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface RoomBoardListResponse
 */
export interface RoomBoardListResponse {
    /**
     * The items for the current page.
     * @type {Array<RoomBoardItemResponse>}
     * @memberof RoomBoardListResponse
     */
    data: Array<RoomBoardItemResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof RoomBoardListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof RoomBoardListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof RoomBoardListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RoomColor {
    BlueGrey = 'blue-grey',
    Pink = 'pink',
    Red = 'red',
    Orange = 'orange',
    Yellow = 'yellow',
    Olive = 'olive',
    Green = 'green',
    Turquoise = 'turquoise',
    LightBlue = 'light-blue',
    Blue = 'blue',
    Magenta = 'magenta',
    Purple = 'purple',
    Brown = 'brown'
}

/**
 * 
 * @export
 * @interface RoomDetailsResponse
 */
export interface RoomDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    name: string;
    /**
     * 
     * @type {RoomColor}
     * @memberof RoomDetailsResponse
     */
    color: RoomColor;
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    schoolId: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof RoomDetailsResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof RoomDetailsResponse
     */
    permissions: Array<Permission>;
}
/**
 * 
 * @export
 * @interface RoomItemResponse
 */
export interface RoomItemResponse {
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    name: string;
    /**
     * 
     * @type {RoomColor}
     * @memberof RoomItemResponse
     */
    color: RoomColor;
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    schoolId: string;
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof RoomItemResponse
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface RoomListResponse
 */
export interface RoomListResponse {
    /**
     * The items for the current page.
     * @type {Array<RoomItemResponse>}
     * @memberof RoomListResponse
     */
    data: Array<RoomItemResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof RoomListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof RoomListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof RoomListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface RoomMemberListResponse
 */
export interface RoomMemberListResponse {
    /**
     * 
     * @type {Array<RoomMemberResponse>}
     * @memberof RoomMemberListResponse
     */
    data: Array<RoomMemberResponse>;
}
/**
 * 
 * @export
 * @interface RoomMemberResponse
 */
export interface RoomMemberResponse {
    /**
     * 
     * @type {string}
     * @memberof RoomMemberResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof RoomMemberResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof RoomMemberResponse
     */
    roomRoleName: string;
    /**
     * 
     * @type {string}
     * @memberof RoomMemberResponse
     */
    schoolRoleName: string;
    /**
     * 
     * @type {string}
     * @memberof RoomMemberResponse
     */
    schoolName: string;
    /**
     * 
     * @type {string}
     * @memberof RoomMemberResponse
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface RoomRoleResponse
 */
export interface RoomRoleResponse {
    /**
     * 
     * @type {string}
     * @memberof RoomRoleResponse
     */
    roomRoleName: string;
}
/**
 * 
 * @export
 * @interface SchoolExistsResponse
 */
export interface SchoolExistsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SchoolExistsResponse
     */
    exists: boolean;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolConfigurationStatusResponse
 */
export interface SchoolExternalToolConfigurationStatusResponse {
    /**
     * Is the tool outdated on school scope, because of non matching versions or required parameter changes on ExternalTool?
     * @type {boolean}
     * @memberof SchoolExternalToolConfigurationStatusResponse
     */
    isOutdatedOnScopeSchool: boolean;
    /**
     * Is the tool deactivated, because of instance administrator?
     * @type {boolean}
     * @memberof SchoolExternalToolConfigurationStatusResponse
     */
    isGloballyDeactivated: boolean;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolConfigurationTemplateListResponse
 */
export interface SchoolExternalToolConfigurationTemplateListResponse {
    /**
     * 
     * @type {Array<SchoolExternalToolConfigurationTemplateResponse>}
     * @memberof SchoolExternalToolConfigurationTemplateListResponse
     */
    data: Array<SchoolExternalToolConfigurationTemplateResponse>;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolConfigurationTemplateResponse
 */
export interface SchoolExternalToolConfigurationTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolConfigurationTemplateResponse
     */
    externalToolId: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolConfigurationTemplateResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolConfigurationTemplateResponse
     */
    baseUrl: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolConfigurationTemplateResponse
     */
    logoUrl?: string;
    /**
     * 
     * @type {Array<CustomParameterResponse>}
     * @memberof SchoolExternalToolConfigurationTemplateResponse
     */
    parameters: Array<CustomParameterResponse>;
    /**
     * Medium of the external tool
     * @type {ExternalToolMediumResponse}
     * @memberof SchoolExternalToolConfigurationTemplateResponse
     */
    medium?: ExternalToolMediumResponse;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolMediumResponse
 */
export interface SchoolExternalToolMediumResponse {
    /**
     * Id of the medium
     * @type {string}
     * @memberof SchoolExternalToolMediumResponse
     */
    mediumId: string;
    /**
     * The id of the media source
     * @type {string}
     * @memberof SchoolExternalToolMediumResponse
     */
    mediaSourceId?: string;
    /**
     * Name of the media source
     * @type {string}
     * @memberof SchoolExternalToolMediumResponse
     */
    mediaSourceName?: string;
    /**
     * License type of the media source
     * @type {MediaSourceLicenseType}
     * @memberof SchoolExternalToolMediumResponse
     */
    mediaSourceLicenseType?: MediaSourceLicenseType;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolMetadataResponse
 */
export interface SchoolExternalToolMetadataResponse {
    /**
     * 
     * @type {ContextExternalToolCountPerContextResponse}
     * @memberof SchoolExternalToolMetadataResponse
     */
    contextExternalToolCountPerContext: ContextExternalToolCountPerContextResponse;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolPostParams
 */
export interface SchoolExternalToolPostParams {
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolPostParams
     */
    toolId: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolPostParams
     */
    schoolId: string;
    /**
     * 
     * @type {Array<CustomParameterEntryParam>}
     * @memberof SchoolExternalToolPostParams
     */
    parameters?: Array<CustomParameterEntryParam>;
    /**
     * Tool can be deactivated, related tools can not be added to e.g. course or board anymore
     * @type {boolean}
     * @memberof SchoolExternalToolPostParams
     */
    isDeactivated: boolean;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolResponse
 */
export interface SchoolExternalToolResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolResponse
     */
    toolId: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolExternalToolResponse
     */
    schoolId: string;
    /**
     * 
     * @type {boolean}
     * @memberof SchoolExternalToolResponse
     */
    isDeactivated: boolean;
    /**
     * 
     * @type {Array<CustomParameterEntryResponse>}
     * @memberof SchoolExternalToolResponse
     */
    parameters: Array<CustomParameterEntryResponse>;
    /**
     * 
     * @type {SchoolExternalToolConfigurationStatusResponse}
     * @memberof SchoolExternalToolResponse
     */
    status: SchoolExternalToolConfigurationStatusResponse;
    /**
     * 
     * @type {Array<ToolContextType>}
     * @memberof SchoolExternalToolResponse
     */
    restrictToContexts?: Array<ToolContextType>;
    /**
     * 
     * @type {SchoolExternalToolMediumResponse}
     * @memberof SchoolExternalToolResponse
     */
    medium?: SchoolExternalToolMediumResponse;
}
/**
 * 
 * @export
 * @interface SchoolExternalToolSearchListResponse
 */
export interface SchoolExternalToolSearchListResponse {
    /**
     * 
     * @type {Array<SchoolExternalToolResponse>}
     * @memberof SchoolExternalToolSearchListResponse
     */
    data: Array<SchoolExternalToolResponse>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SchoolFeature {
    RocketChat = 'rocketChat',
    Videoconference = 'videoconference',
    Nextcloud = 'nextcloud',
    StudentVisibility = 'studentVisibility',
    LdapUniventionMigrationSchool = 'ldapUniventionMigrationSchool',
    OauthProvisioningEnabled = 'oauthProvisioningEnabled',
    ShowOutdatedUsers = 'showOutdatedUsers',
    EnableLdapSyncDuringMigration = 'enableLdapSyncDuringMigration',
    AiTutor = 'aiTutor'
}

/**
 * 
 * @export
 * @interface SchoolForExternalInviteResponse
 */
export interface SchoolForExternalInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolForExternalInviteResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolForExternalInviteResponse
     */
    name: string;
}
/**
 * 
 * @export
 * @interface SchoolForLdapLoginResponse
 */
export interface SchoolForLdapLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolForLdapLoginResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolForLdapLoginResponse
     */
    name: string;
    /**
     * 
     * @type {Array<SystemForLdapLoginResponse>}
     * @memberof SchoolForLdapLoginResponse
     */
    systems: Array<SystemForLdapLoginResponse>;
}
/**
 * 
 * @export
 * @interface SchoolInfoResponse
 */
export interface SchoolInfoResponse {
    /**
     * The id of the School entity
     * @type {string}
     * @memberof SchoolInfoResponse
     */
    id: string;
    /**
     * The name of the School entity
     * @type {string}
     * @memberof SchoolInfoResponse
     */
    name: string;
}
/**
 * 
 * @export
 * @interface SchoolLogo
 */
export interface SchoolLogo {
    /**
     * 
     * @type {string}
     * @memberof SchoolLogo
     */
    dataUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolLogo
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface SchoolPermissionsParams
 */
export interface SchoolPermissionsParams {
    /**
     * 
     * @type {TeacherPermissionParams}
     * @memberof SchoolPermissionsParams
     */
    teacher?: TeacherPermissionParams;
    /**
     * 
     * @type {StudentPermissionParams}
     * @memberof SchoolPermissionsParams
     */
    student?: StudentPermissionParams;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SchoolPurpose {
    Expert = 'expert',
    Tombstone = 'tombstone',
    Demo = 'demo',
    Test = 'test',
    MintEc = 'MINT-EC'
}

/**
 * 
 * @export
 * @interface SchoolResponse
 */
export interface SchoolResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    officialSchoolNumber?: string;
    /**
     * 
     * @type {SchoolYearResponse}
     * @memberof SchoolResponse
     */
    currentYear?: SchoolYearResponse;
    /**
     * 
     * @type {FederalStateResponse}
     * @memberof SchoolResponse
     */
    federalState?: FederalStateResponse;
    /**
     * 
     * @type {CountyResponse}
     * @memberof SchoolResponse
     */
    county?: CountyResponse;
    /**
     * 
     * @type {SchoolPurpose}
     * @memberof SchoolResponse
     */
    purpose?: SchoolPurpose;
    /**
     * 
     * @type {Array<SchoolFeature>}
     * @memberof SchoolResponse
     */
    features: Array<SchoolFeature>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SchoolResponse
     */
    systemIds: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SchoolResponse
     */
    inUserMigration?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchoolResponse
     */
    inMaintenance: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchoolResponse
     */
    isExternal: boolean;
    /**
     * 
     * @type {SchoolLogo}
     * @memberof SchoolResponse
     */
    logo?: SchoolLogo;
    /**
     * 
     * @type {FileStorageType}
     * @memberof SchoolResponse
     */
    fileStorageType?: FileStorageType;
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolResponse
     */
    timezone?: string;
    /**
     * 
     * @type {object}
     * @memberof SchoolResponse
     */
    permissions?: object;
    /**
     * 
     * @type {YearsResponse}
     * @memberof SchoolResponse
     */
    years: YearsResponse;
    /**
     * 
     * @type {Array<InstanceFeature>}
     * @memberof SchoolResponse
     */
    instanceFeatures: Array<InstanceFeature>;
}
/**
 * 
 * @export
 * @interface SchoolSystemResponse
 */
export interface SchoolSystemResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolSystemResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolSystemResponse
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolSystemResponse
     */
    alias?: string;
    /**
     * 
     * @type {ProviderConfigResponse}
     * @memberof SchoolSystemResponse
     */
    ldapConfig?: ProviderConfigResponse;
    /**
     * 
     * @type {ProviderConfigResponse}
     * @memberof SchoolSystemResponse
     */
    oauthConfig?: ProviderConfigResponse;
}
/**
 * 
 * @export
 * @interface SchoolUpdateBodyParams
 */
export interface SchoolUpdateBodyParams {
    /**
     * 
     * @type {string}
     * @memberof SchoolUpdateBodyParams
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolUpdateBodyParams
     */
    officialSchoolNumber?: string;
    /**
     * 
     * @type {SchoolLogo}
     * @memberof SchoolUpdateBodyParams
     */
    logo?: SchoolLogo;
    /**
     * 
     * @type {string}
     * @memberof SchoolUpdateBodyParams
     */
    fileStorageType?: SchoolUpdateBodyParamsFileStorageTypeEnum;
    /**
     * 
     * @type {LanguageType}
     * @memberof SchoolUpdateBodyParams
     */
    language?: LanguageType;
    /**
     * 
     * @type {Array<SchoolFeature>}
     * @memberof SchoolUpdateBodyParams
     */
    features?: Array<SchoolFeature>;
    /**
     * 
     * @type {SchoolPermissionsParams}
     * @memberof SchoolUpdateBodyParams
     */
    permissions?: SchoolPermissionsParams;
    /**
     * 
     * @type {string}
     * @memberof SchoolUpdateBodyParams
     */
    countyId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SchoolUpdateBodyParams
     */
    enableStudentTeamCreation?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum SchoolUpdateBodyParamsFileStorageTypeEnum {
    AwsS3 = 'awsS3'
}

/**
 * 
 * @export
 * @interface SchoolUserListResponse
 */
export interface SchoolUserListResponse {
    /**
     * 
     * @type {Array<SchoolUserResponse>}
     * @memberof SchoolUserListResponse
     */
    data: Array<SchoolUserResponse>;
}
/**
 * 
 * @export
 * @interface SchoolUserResponse
 */
export interface SchoolUserResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolUserResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolUserResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolUserResponse
     */
    schoolName: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolUserResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SchoolYearQueryType {
    NextYear = 'nextYear',
    CurrentYear = 'currentYear',
    PreviousYears = 'previousYears'
}

/**
 * 
 * @export
 * @interface SchoolYearResponse
 */
export interface SchoolYearResponse {
    /**
     * 
     * @type {string}
     * @memberof SchoolYearResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolYearResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolYearResponse
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof SchoolYearResponse
     */
    endDate: string;
}
/**
 * 
 * @export
 * @interface SchulConneXProvisioningOptionsParams
 */
export interface SchulConneXProvisioningOptionsParams {
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsParams
     */
    groupProvisioningClassesEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsParams
     */
    groupProvisioningCoursesEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsParams
     */
    groupProvisioningOtherEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsParams
     */
    schoolExternalToolProvisioningEnabled: boolean;
}
/**
 * 
 * @export
 * @interface SchulConneXProvisioningOptionsResponse
 */
export interface SchulConneXProvisioningOptionsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsResponse
     */
    groupProvisioningClassesEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsResponse
     */
    groupProvisioningCoursesEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsResponse
     */
    groupProvisioningOtherEnabled: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SchulConneXProvisioningOptionsResponse
     */
    schoolExternalToolProvisioningEnabled: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SchulcloudTheme {
    Brb = 'brb',
    Default = 'default',
    N21 = 'n21',
    Thr = 'thr'
}

/**
 * 
 * @export
 * @interface SetHeightBodyParams
 */
export interface SetHeightBodyParams {
    /**
     * 
     * @type {number}
     * @memberof SetHeightBodyParams
     */
    height: number;
}
/**
 * 
 * @export
 * @interface ShareTokenBodyParams
 */
export interface ShareTokenBodyParams {
    /**
     * the type of the object being shared
     * @type {string}
     * @memberof ShareTokenBodyParams
     */
    parentType: ShareTokenBodyParamsParentTypeEnum;
    /**
     * the id of the object being shared.
     * @type {string}
     * @memberof ShareTokenBodyParams
     */
    parentId: string;
    /**
     * when defined, the sharetoken will expire after the given number of days.
     * @type {number}
     * @memberof ShareTokenBodyParams
     */
    expiresInDays?: number | null;
    /**
     * when defined, the sharetoken will be usable exclusively by members of the users school.
     * @type {boolean}
     * @memberof ShareTokenBodyParams
     */
    schoolExclusive?: boolean | null;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareTokenBodyParamsParentTypeEnum {
    Courses = 'courses',
    Tasks = 'tasks',
    Lessons = 'lessons',
    ColumnBoard = 'columnBoard'
}

/**
 * 
 * @export
 * @interface ShareTokenImportBodyParams
 */
export interface ShareTokenImportBodyParams {
    /**
     * the new name of the imported object.
     * @type {string}
     * @memberof ShareTokenImportBodyParams
     */
    newName: string;
    /**
     * Id of the parent to which the imported object will be added.
     * @type {string}
     * @memberof ShareTokenImportBodyParams
     */
    destinationId?: string | null;
}
/**
 * 
 * @export
 * @interface ShareTokenInfoResponse
 */
export interface ShareTokenInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof ShareTokenInfoResponse
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof ShareTokenInfoResponse
     */
    parentType: ShareTokenInfoResponseParentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ShareTokenInfoResponse
     */
    parentName: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareTokenInfoResponseParentTypeEnum {
    Courses = 'courses',
    Tasks = 'tasks',
    Lessons = 'lessons',
    ColumnBoard = 'columnBoard'
}

/**
 * 
 * @export
 * @interface ShareTokenPayloadResponse
 */
export interface ShareTokenPayloadResponse {
    /**
     * 
     * @type {string}
     * @memberof ShareTokenPayloadResponse
     */
    parentType: ShareTokenPayloadResponseParentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ShareTokenPayloadResponse
     */
    parentId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ShareTokenPayloadResponseParentTypeEnum {
    Courses = 'courses',
    Tasks = 'tasks',
    Lessons = 'lessons',
    ColumnBoard = 'columnBoard'
}

/**
 * 
 * @export
 * @interface ShareTokenResponse
 */
export interface ShareTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ShareTokenResponse
     */
    token: string;
    /**
     * 
     * @type {ShareTokenPayloadResponse}
     * @memberof ShareTokenResponse
     */
    payload: ShareTokenPayloadResponse;
    /**
     * 
     * @type {string}
     * @memberof ShareTokenResponse
     */
    expiresAt?: string;
}
/**
 * 
 * @export
 * @interface SingleColumnBoardResponse
 */
export interface SingleColumnBoardResponse {
    /**
     * The id of the room this board belongs to
     * @type {string}
     * @memberof SingleColumnBoardResponse
     */
    roomId: string;
    /**
     * Title of the Board
     * @type {string}
     * @memberof SingleColumnBoardResponse
     */
    title: string;
    /**
     * Color of the Board
     * @type {string}
     * @memberof SingleColumnBoardResponse
     */
    displayColor: string;
    /**
     * Array of board specific tasks or lessons with matching type property
     * @type {Array<BoardElementResponse>}
     * @memberof SingleColumnBoardResponse
     */
    elements: Array<BoardElementResponse>;
    /**
     * Boolean if the room this board belongs to is archived
     * @type {boolean}
     * @memberof SingleColumnBoardResponse
     */
    isArchived: boolean;
    /**
     * Is the course synchronized with a group?
     * @type {boolean}
     * @memberof SingleColumnBoardResponse
     */
    isSynchronized: boolean;
}
/**
 * 
 * @export
 * @interface StudentPermissionParams
 */
export interface StudentPermissionParams {
    /**
     * 
     * @type {boolean}
     * @memberof StudentPermissionParams
     */
    LERNSTORE_VIEW?: boolean;
}
/**
 * 
 * @export
 * @interface SubmissionContainerContentBody
 */
export interface SubmissionContainerContentBody {
    /**
     * The point in time until when a submission can be handed in.
     * @type {string}
     * @memberof SubmissionContainerContentBody
     */
    dueDate?: string;
}
/**
 * 
 * @export
 * @interface SubmissionContainerElementContent
 */
export interface SubmissionContainerElementContent {
    /**
     * The dueDate as date string or null of not set
     * @type {string}
     * @memberof SubmissionContainerElementContent
     */
    dueDate: string;
}
/**
 * 
 * @export
 * @interface SubmissionContainerElementContentBody
 */
export interface SubmissionContainerElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof SubmissionContainerElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {SubmissionContainerContentBody}
     * @memberof SubmissionContainerElementContentBody
     */
    content: SubmissionContainerContentBody;
}
/**
 * 
 * @export
 * @interface SubmissionContainerElementResponse
 */
export interface SubmissionContainerElementResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmissionContainerElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof SubmissionContainerElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {SubmissionContainerElementContent}
     * @memberof SubmissionContainerElementResponse
     */
    content: SubmissionContainerElementContent;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof SubmissionContainerElementResponse
     */
    timestamps: TimestampsResponse;
}
/**
 * 
 * @export
 * @interface SubmissionItemResponse
 */
export interface SubmissionItemResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmissionItemResponse
     */
    id: string;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof SubmissionItemResponse
     */
    timestamps: TimestampsResponse;
    /**
     * 
     * @type {boolean}
     * @memberof SubmissionItemResponse
     */
    completed: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubmissionItemResponse
     */
    userId: string;
    /**
     * 
     * @type {Array<FileElementResponse | RichTextElementResponse>}
     * @memberof SubmissionItemResponse
     */
    elements: Array<FileElementResponse | RichTextElementResponse>;
}
/**
 * 
 * @export
 * @interface SubmissionStatusListResponse
 */
export interface SubmissionStatusListResponse {
    /**
     * 
     * @type {Array<SubmissionStatusResponse>}
     * @memberof SubmissionStatusListResponse
     */
    data: Array<SubmissionStatusResponse>;
}
/**
 * 
 * @export
 * @interface SubmissionStatusResponse
 */
export interface SubmissionStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof SubmissionStatusResponse
     */
    id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SubmissionStatusResponse
     */
    submitters: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SubmissionStatusResponse
     */
    isSubmitted: boolean;
    /**
     * 
     * @type {number}
     * @memberof SubmissionStatusResponse
     */
    grade?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubmissionStatusResponse
     */
    isGraded: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubmissionStatusResponse
     */
    submittingCourseGroupName?: string;
}
/**
 * 
 * @export
 * @interface SubmissionsResponse
 */
export interface SubmissionsResponse {
    /**
     * 
     * @type {Array<SubmissionItemResponse>}
     * @memberof SubmissionsResponse
     */
    submissionItemsResponse: Array<SubmissionItemResponse>;
    /**
     * 
     * @type {Array<UserDataResponse>}
     * @memberof SubmissionsResponse
     */
    users: Array<UserDataResponse>;
}
/**
 * 
 * @export
 * @interface SuccessfulResponse
 */
export interface SuccessfulResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SuccessfulResponse
     */
    successful: boolean;
}
/**
 * 
 * @export
 * @interface SystemForLdapLoginResponse
 */
export interface SystemForLdapLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof SystemForLdapLoginResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SystemForLdapLoginResponse
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof SystemForLdapLoginResponse
     */
    alias: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SystemType {
    Oauth = 'oauth',
    Ldap = 'ldap',
    Oidc = 'oidc',
    TspBase = 'tsp-base',
    TspSchool = 'tsp-school',
    Local = 'local',
    Iserv = 'iserv',
    Lernsax = 'lernsax',
    Itslearning = 'itslearning',
    Moodle = 'moodle'
}

/**
 * 
 * @export
 * @interface TargetInfoResponse
 */
export interface TargetInfoResponse {
    /**
     * The id of the Target entity
     * @type {string}
     * @memberof TargetInfoResponse
     */
    id: string;
    /**
     * The name of the Target entity
     * @type {string}
     * @memberof TargetInfoResponse
     */
    name: string;
}
/**
 * 
 * @export
 * @interface TargetUserIdParams
 */
export interface TargetUserIdParams {
    /**
     * 
     * @type {string}
     * @memberof TargetUserIdParams
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface TaskCopyApiParams
 */
export interface TaskCopyApiParams {
    /**
     * Destination course parent Id the task is copied to
     * @type {string}
     * @memberof TaskCopyApiParams
     */
    courseId?: string;
    /**
     * Destination lesson parent Id the task is copied to
     * @type {string}
     * @memberof TaskCopyApiParams
     */
    lessonId?: string;
}
/**
 * 
 * @export
 * @interface TaskListResponse
 */
export interface TaskListResponse {
    /**
     * The items for the current page.
     * @type {Array<TaskResponse>}
     * @memberof TaskListResponse
     */
    data: Array<TaskResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof TaskListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof TaskListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof TaskListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface TaskResponse
 */
export interface TaskResponse {
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    availableDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    dueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    courseName: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    lessonName?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    courseId: string;
    /**
     * Task description object, with props content: string and type: input format types
     * @type {RichText}
     * @memberof TaskResponse
     */
    description?: RichText;
    /**
     * 
     * @type {boolean}
     * @memberof TaskResponse
     */
    lessonHidden: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    displayColor?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResponse
     */
    updatedAt: string;
    /**
     * 
     * @type {TaskStatusResponse}
     * @memberof TaskResponse
     */
    status: TaskStatusResponse;
}
/**
 * 
 * @export
 * @interface TaskStatusResponse
 */
export interface TaskStatusResponse {
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponse
     */
    submitted: number;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponse
     */
    maxSubmissions: number;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponse
     */
    graded: number;
    /**
     * 
     * @type {boolean}
     * @memberof TaskStatusResponse
     */
    isDraft: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskStatusResponse
     */
    isSubstitutionTeacher: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskStatusResponse
     */
    isFinished: boolean;
}
/**
 * 
 * @export
 * @interface TeacherPermissionParams
 */
export interface TeacherPermissionParams {
    /**
     * 
     * @type {boolean}
     * @memberof TeacherPermissionParams
     */
    STUDENT_LIST?: boolean;
}
/**
 * 
 * @export
 * @interface TeamPermissionsBody
 */
export interface TeamPermissionsBody {
    /**
     * 
     * @type {boolean}
     * @memberof TeamPermissionsBody
     */
    read: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamPermissionsBody
     */
    write: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamPermissionsBody
     */
    create: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamPermissionsBody
     */
    _delete: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TeamPermissionsBody
     */
    share: boolean;
}
/**
 * 
 * @export
 * @interface TimestampsResponse
 */
export interface TimestampsResponse {
    /**
     * 
     * @type {string}
     * @memberof TimestampsResponse
     */
    lastUpdatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampsResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof TimestampsResponse
     */
    deletedAt?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Timezone {
    EuropeBerlin = 'Europe/Berlin'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ToolConfigType {
    Basic = 'basic',
    Oauth2 = 'oauth2',
    Lti11 = 'lti11'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ToolContextType {
    Course = 'course',
    BoardElement = 'board-element',
    MediaBoard = 'media-board'
}

/**
 * 
 * @export
 * @interface ToolContextTypesListResponse
 */
export interface ToolContextTypesListResponse {
    /**
     * 
     * @type {Array<ToolContextType>}
     * @memberof ToolContextTypesListResponse
     */
    data: Array<ToolContextType>;
}
/**
 * 
 * @export
 * @interface ToolLaunchRequestResponse
 */
export interface ToolLaunchRequestResponse {
    /**
     * The Launch Request method (GET or POST)
     * @type {string}
     * @memberof ToolLaunchRequestResponse
     */
    method: ToolLaunchRequestResponseMethodEnum;
    /**
     * The URL for the Tool Launch Request
     * @type {string}
     * @memberof ToolLaunchRequestResponse
     */
    url: string;
    /**
     * The payload for the Tool Launch Request (optional)
     * @type {string}
     * @memberof ToolLaunchRequestResponse
     */
    payload?: string;
    /**
     * Specifies whether the Tool should be launched in a new tab
     * @type {boolean}
     * @memberof ToolLaunchRequestResponse
     */
    openNewTab?: boolean;
    /**
     * Specifies the underlying type of the request
     * @type {LaunchType}
     * @memberof ToolLaunchRequestResponse
     */
    launchType: LaunchType;
}

/**
    * @export
    * @enum {string}
    */
export enum ToolLaunchRequestResponseMethodEnum {
    Get = 'GET',
    Post = 'POST'
}

/**
 * 
 * @export
 * @interface ToolReferenceListResponse
 */
export interface ToolReferenceListResponse {
    /**
     * 
     * @type {Array<ToolReferenceResponse>}
     * @memberof ToolReferenceListResponse
     */
    data: Array<ToolReferenceResponse>;
}
/**
 * 
 * @export
 * @interface ToolReferenceResponse
 */
export interface ToolReferenceResponse {
    /**
     * The id of the tool in the context
     * @type {string}
     * @memberof ToolReferenceResponse
     */
    contextToolId: string;
    /**
     * The description of the tool
     * @type {string}
     * @memberof ToolReferenceResponse
     */
    description?: string;
    /**
     * The url of the logo which is stored in the db
     * @type {string}
     * @memberof ToolReferenceResponse
     */
    logoUrl?: string;
    /**
     * The url of the thumbnail which is stored in the db
     * @type {string}
     * @memberof ToolReferenceResponse
     */
    thumbnailUrl?: string;
    /**
     * The display name of the tool
     * @type {string}
     * @memberof ToolReferenceResponse
     */
    displayName: string;
    /**
     * Whether the tool should be opened in a new tab
     * @type {boolean}
     * @memberof ToolReferenceResponse
     */
    openInNewTab: boolean;
    /**
     * The status of the tool
     * @type {ContextExternalToolConfigurationStatusResponse}
     * @memberof ToolReferenceResponse
     */
    status: ContextExternalToolConfigurationStatusResponse;
    /**
     * Whether the tool is a lti deep linking tool
     * @type {boolean}
     * @memberof ToolReferenceResponse
     */
    isLtiDeepLinkingTool: boolean;
    /**
     * 
     * @type {LtiDeepLinkResponse}
     * @memberof ToolReferenceResponse
     */
    ltiDeepLink?: LtiDeepLinkResponse;
}
/**
 * 
 * @export
 * @interface UpdateBoardTitleParams
 */
export interface UpdateBoardTitleParams {
    /**
     * 
     * @type {string}
     * @memberof UpdateBoardTitleParams
     */
    title: string;
}
/**
 * 
 * @export
 * @interface UpdateElementContentBodyParams
 */
export interface UpdateElementContentBodyParams {
    /**
     * 
     * @type {FileElementContentBody | LinkElementContentBody | RichTextElementContentBody | SubmissionContainerElementContentBody | ExternalToolElementContentBody | DrawingElementContentBody | VideoConferenceElementContentBody}
     * @memberof UpdateElementContentBodyParams
     */
    data: FileElementContentBody | LinkElementContentBody | RichTextElementContentBody | SubmissionContainerElementContentBody | ExternalToolElementContentBody | DrawingElementContentBody | VideoConferenceElementContentBody;
}
/**
 * 
 * @export
 * @interface UpdateFlagParams
 */
export interface UpdateFlagParams {
    /**
     * updates flag for an import user
     * @type {boolean}
     * @memberof UpdateFlagParams
     */
    flagged: boolean;
}
/**
 * 
 * @export
 * @interface UpdateMatchParams
 */
export interface UpdateMatchParams {
    /**
     * updates local user reference for an import user
     * @type {string}
     * @memberof UpdateMatchParams
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface UpdateNewsParams
 */
export interface UpdateNewsParams {
    /**
     * Title of the News entity
     * @type {string}
     * @memberof UpdateNewsParams
     */
    title?: string;
    /**
     * Content of the News entity
     * @type {string}
     * @memberof UpdateNewsParams
     */
    content?: string;
    /**
     * The point in time from when the News entity schould be displayed
     * @type {string}
     * @memberof UpdateNewsParams
     */
    displayAt?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoomBodyParams
 */
export interface UpdateRoomBodyParams {
    /**
     * The name of the room
     * @type {string}
     * @memberof UpdateRoomBodyParams
     */
    name: string;
    /**
     * The display color of the room
     * @type {RoomColor}
     * @memberof UpdateRoomBodyParams
     */
    color: RoomColor;
    /**
     * Start date of the room
     * @type {string}
     * @memberof UpdateRoomBodyParams
     */
    startDate?: string;
    /**
     * Start date of the room
     * @type {string}
     * @memberof UpdateRoomBodyParams
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface UpdateSubmissionItemBodyParams
 */
export interface UpdateSubmissionItemBodyParams {
    /**
     * Boolean indicating whether the submission is completed.
     * @type {boolean}
     * @memberof UpdateSubmissionItemBodyParams
     */
    completed: boolean;
}
/**
 * 
 * @export
 * @interface UserConsentResponse
 */
export interface UserConsentResponse {
    /**
     * 
     * @type {string}
     * @memberof UserConsentResponse
     */
    form: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserConsentResponse
     */
    privacyConsent: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConsentResponse
     */
    termsOfUseConsent: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserConsentResponse
     */
    dateOfPrivacyConsent: string;
    /**
     * 
     * @type {string}
     * @memberof UserConsentResponse
     */
    dateOfTermsOfUseConsent: string;
}
/**
 * 
 * @export
 * @interface UserDataResponse
 */
export interface UserDataResponse {
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UserDataResponse
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface UserInfoResponse
 */
export interface UserInfoResponse {
    /**
     * The id of the User entity
     * @type {string}
     * @memberof UserInfoResponse
     */
    id: string;
    /**
     * First name of the user
     * @type {string}
     * @memberof UserInfoResponse
     */
    firstName?: string;
    /**
     * Last name of the user
     * @type {string}
     * @memberof UserInfoResponse
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * The items for the current page.
     * @type {Array<UserResponse>}
     * @memberof UserListResponse
     */
    data: Array<UserResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof UserListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof UserListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof UserListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface UserLoginMigrationMandatoryParams
 */
export interface UserLoginMigrationMandatoryParams {
    /**
     * 
     * @type {boolean}
     * @memberof UserLoginMigrationMandatoryParams
     */
    mandatory: boolean;
}
/**
 * 
 * @export
 * @interface UserLoginMigrationResponse
 */
export interface UserLoginMigrationResponse {
    /**
     * Id of the migration
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    id: string;
    /**
     * Id of the system which is the origin of the migration
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    sourceSystemId?: string;
    /**
     * Id of the system which is the target of the migration
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    targetSystemId: string;
    /**
     * Date when the migration was marked as required
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    mandatorySince?: string;
    /**
     * Date when the migration was started
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    startedAt: string;
    /**
     * Date when the migration was completed
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    closedAt?: string;
    /**
     * Date when the migration was completed including the grace period
     * @type {string}
     * @memberof UserLoginMigrationResponse
     */
    finishedAt?: string;
}
/**
 * 
 * @export
 * @interface UserLoginMigrationSearchListResponse
 */
export interface UserLoginMigrationSearchListResponse {
    /**
     * Contains user login migration responses
     * @type {Array<UserLoginMigrationResponse>}
     * @memberof UserLoginMigrationSearchListResponse
     */
    data: Array<UserLoginMigrationResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof UserLoginMigrationSearchListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof UserLoginMigrationSearchListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof UserLoginMigrationSearchListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface UserMatchListResponse
 */
export interface UserMatchListResponse {
    /**
     * The items for the current page.
     * @type {Array<UserMatchResponse>}
     * @memberof UserMatchListResponse
     */
    data: Array<UserMatchResponse>;
    /**
     * The total amount of items.
     * @type {number}
     * @memberof UserMatchListResponse
     */
    total: number;
    /**
     * The amount of items skipped from the start.
     * @type {number}
     * @memberof UserMatchListResponse
     */
    skip: number;
    /**
     * The page size of the response.
     * @type {number}
     * @memberof UserMatchListResponse
     */
    limit: number;
}
/**
 * 
 * @export
 * @interface UserMatchResponse
 */
export interface UserMatchResponse {
    /**
     * local user id
     * @type {string}
     * @memberof UserMatchResponse
     */
    userId: string;
    /**
     * login name of local user
     * @type {string}
     * @memberof UserMatchResponse
     */
    loginName: string;
    /**
     * firstname of local user
     * @type {string}
     * @memberof UserMatchResponse
     */
    firstName: string;
    /**
     * lastname of local user
     * @type {string}
     * @memberof UserMatchResponse
     */
    lastName: string;
    /**
     * list of user roles from external system: student, teacher, admin
     * @type {Array<string>}
     * @memberof UserMatchResponse
     */
    roleNames: Array<UserMatchResponseRoleNamesEnum>;
    /**
     * match type: admin (manual) or auto (set, when names match exactly for a single user
     * @type {string}
     * @memberof UserMatchResponse
     */
    matchedBy?: UserMatchResponseMatchedByEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UserMatchResponseRoleNamesEnum {
    Student = 'student',
    Teacher = 'teacher',
    Admin = 'admin'
}
/**
    * @export
    * @enum {string}
    */
export enum UserMatchResponseMatchedByEnum {
    Auto = 'auto',
    Admin = 'admin'
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    _id: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    birthday: string;
    /**
     * 
     * @type {object}
     * @memberof UserResponse
     */
    preferences: object;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    consentStatus: string;
    /**
     * 
     * @type {ConsentsResponse}
     * @memberof UserResponse
     */
    consent: ConsentsResponse;
    /**
     * 
     * @type {Array<ClassResponse>}
     * @memberof UserResponse
     */
    classes: Array<ClassResponse>;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    importHash: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    lastLoginSystemChange: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    outdatedSince: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * The response status code.
     * @type {number}
     * @memberof ValidationError
     */
    code: number;
    /**
     * The error type.
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
    /**
     * The error title.
     * @type {string}
     * @memberof ValidationError
     */
    title: string;
    /**
     * The error message.
     * @type {string}
     * @memberof ValidationError
     */
    message: string;
    /**
     * The error details.
     * @type {object}
     * @memberof ValidationError
     */
    details?: object;
}
/**
 * 
 * @export
 * @interface VideoConferenceContentBody
 */
export interface VideoConferenceContentBody {
    /**
     * 
     * @type {string}
     * @memberof VideoConferenceContentBody
     */
    title: string;
}
/**
 * 
 * @export
 * @interface VideoConferenceCreateParams
 */
export interface VideoConferenceCreateParams {
    /**
     * 
     * @type {boolean}
     * @memberof VideoConferenceCreateParams
     */
    everyAttendeeJoinsMuted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VideoConferenceCreateParams
     */
    everybodyJoinsAsModerator?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof VideoConferenceCreateParams
     */
    moderatorMustApproveJoinRequests?: boolean;
    /**
     * The URL that the BigBlueButton client will go to after users click the OK button on the You have been logged out or This session was ended message. Has to be a URL from the same domain that the conference is started from.
     * @type {string}
     * @memberof VideoConferenceCreateParams
     */
    logoutUrl?: string;
}
/**
 * 
 * @export
 * @interface VideoConferenceElementContent
 */
export interface VideoConferenceElementContent {
    /**
     * 
     * @type {string}
     * @memberof VideoConferenceElementContent
     */
    title: string;
}
/**
 * 
 * @export
 * @interface VideoConferenceElementContentBody
 */
export interface VideoConferenceElementContentBody {
    /**
     * the type of the updated element
     * @type {ContentElementType}
     * @memberof VideoConferenceElementContentBody
     */
    type: ContentElementType;
    /**
     * 
     * @type {VideoConferenceContentBody}
     * @memberof VideoConferenceElementContentBody
     */
    content: VideoConferenceContentBody;
}
/**
 * 
 * @export
 * @interface VideoConferenceElementResponse
 */
export interface VideoConferenceElementResponse {
    /**
     * 
     * @type {string}
     * @memberof VideoConferenceElementResponse
     */
    id: string;
    /**
     * 
     * @type {ContentElementType}
     * @memberof VideoConferenceElementResponse
     */
    type: ContentElementType;
    /**
     * 
     * @type {TimestampsResponse}
     * @memberof VideoConferenceElementResponse
     */
    timestamps: TimestampsResponse;
    /**
     * 
     * @type {VideoConferenceElementContent}
     * @memberof VideoConferenceElementResponse
     */
    content: VideoConferenceElementContent;
}
/**
 * 
 * @export
 * @interface VideoConferenceInfoResponse
 */
export interface VideoConferenceInfoResponse {
    /**
     * The state of the video conference.
     * @type {VideoConferenceStateResponse}
     * @memberof VideoConferenceInfoResponse
     */
    state: VideoConferenceStateResponse;
    /**
     * The options for the video conference.
     * @type {VideoConferenceOptionsResponse}
     * @memberof VideoConferenceInfoResponse
     */
    options: VideoConferenceOptionsResponse;
}
/**
 * 
 * @export
 * @interface VideoConferenceJoinResponse
 */
export interface VideoConferenceJoinResponse {
    /**
     * The URL to join the video conference.
     * @type {string}
     * @memberof VideoConferenceJoinResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface VideoConferenceOptionsResponse
 */
export interface VideoConferenceOptionsResponse {
    /**
     * Every attendee joins muted
     * @type {boolean}
     * @memberof VideoConferenceOptionsResponse
     */
    everyAttendeeJoinsMuted: boolean;
    /**
     * Every attendee joins as a moderator
     * @type {boolean}
     * @memberof VideoConferenceOptionsResponse
     */
    everybodyJoinsAsModerator: boolean;
    /**
     * Moderator must approve join requests
     * @type {boolean}
     * @memberof VideoConferenceOptionsResponse
     */
    moderatorMustApproveJoinRequests: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum VideoConferenceScope {
    Course = 'course',
    Event = 'event',
    Room = 'room',
    VideoConferenceElement = 'video-conference-element'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum VideoConferenceStateResponse {
    NotStarted = 'NOT_STARTED',
    Running = 'RUNNING',
    Finished = 'FINISHED'
}

/**
 * 
 * @export
 * @interface VisibilityBodyParams
 */
export interface VisibilityBodyParams {
    /**
     * 
     * @type {boolean}
     * @memberof VisibilityBodyParams
     */
    isVisible: boolean;
}
/**
 * 
 * @export
 * @interface VisibilitySettingsResponse
 */
export interface VisibilitySettingsResponse {
    /**
     * 
     * @type {string}
     * @memberof VisibilitySettingsResponse
     */
    publishedAt?: string;
}
/**
 * 
 * @export
 * @interface YearsResponse
 */
export interface YearsResponse {
    /**
     * 
     * @type {Array<SchoolYearResponse>}
     * @memberof YearsResponse
     */
    schoolYears: Array<SchoolYearResponse>;
    /**
     * 
     * @type {SchoolYearResponse}
     * @memberof YearsResponse
     */
    activeYear: SchoolYearResponse;
    /**
     * 
     * @type {SchoolYearResponse}
     * @memberof YearsResponse
     */
    lastYear: SchoolYearResponse;
    /**
     * 
     * @type {SchoolYearResponse}
     * @memberof YearsResponse
     */
    nextYear: SchoolYearResponse;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteAccountById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerDeleteAccountById', 'id', id)
            const localVarPath = `/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindAccountById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerFindAccountById', 'id', id)
            const localVarPath = `/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the the temporary account password for the authenticated user.
         * @param {PatchMyPasswordParams} patchMyPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerReplaceMyPassword: async (patchMyPasswordParams: PatchMyPasswordParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchMyPasswordParams' is not null or undefined
            assertParamExists('accountControllerReplaceMyPassword', 'patchMyPasswordParams', patchMyPasswordParams)
            const localVarPath = `/account/me/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchMyPasswordParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
         * @param {'userId' | 'username'} type The search criteria.
         * @param {string} value The search value.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerSearchAccounts: async (type: 'userId' | 'username', value: string, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('accountControllerSearchAccounts', 'type', type)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('accountControllerSearchAccounts', 'value', value)
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {AccountByIdBodyParams} accountByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountById: async (id: string, accountByIdBodyParams: AccountByIdBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountControllerUpdateAccountById', 'id', id)
            // verify required parameter 'accountByIdBodyParams' is not null or undefined
            assertParamExists('accountControllerUpdateAccountById', 'accountByIdBodyParams', accountByIdBodyParams)
            const localVarPath = `/account/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountByIdBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an account for the authenticated user.
         * @param {PatchMyAccountParams} patchMyAccountParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateMyAccount: async (patchMyAccountParams: PatchMyAccountParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchMyAccountParams' is not null or undefined
            assertParamExists('accountControllerUpdateMyAccount', 'patchMyAccountParams', patchMyAccountParams)
            const localVarPath = `/account/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchMyAccountParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerDeleteAccountById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerDeleteAccountById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerFindAccountById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerFindAccountById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the the temporary account password for the authenticated user.
         * @param {PatchMyPasswordParams} patchMyPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerReplaceMyPassword(patchMyPasswordParams: PatchMyPasswordParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerReplaceMyPassword(patchMyPasswordParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
         * @param {'userId' | 'username'} type The search criteria.
         * @param {string} value The search value.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerSearchAccounts(type: 'userId' | 'username', value: string, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSearchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerSearchAccounts(type, value, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {AccountByIdBodyParams} accountByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccountById(id: string, accountByIdBodyParams: AccountByIdBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccountById(id, accountByIdBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an account for the authenticated user.
         * @param {PatchMyAccountParams} patchMyAccountParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateMyAccount(patchMyAccountParams: PatchMyAccountParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateMyAccount(patchMyAccountParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteAccountById(id: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.accountControllerDeleteAccountById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerFindAccountById(id: string, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.accountControllerFindAccountById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the the temporary account password for the authenticated user.
         * @param {PatchMyPasswordParams} patchMyPasswordParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerReplaceMyPassword(patchMyPasswordParams: PatchMyPasswordParams, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerReplaceMyPassword(patchMyPasswordParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
         * @param {'userId' | 'username'} type The search criteria.
         * @param {string} value The search value.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerSearchAccounts(type: 'userId' | 'username', value: string, skip?: number, limit?: number, options?: any): AxiosPromise<AccountSearchListResponse> {
            return localVarFp.accountControllerSearchAccounts(type, value, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an account with given id. Superhero role is REQUIRED.
         * @param {string} id The id for the account.
         * @param {AccountByIdBodyParams} accountByIdBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountById(id: string, accountByIdBodyParams: AccountByIdBodyParams, options?: any): AxiosPromise<AccountResponse> {
            return localVarFp.accountControllerUpdateAccountById(id, accountByIdBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an account for the authenticated user.
         * @param {PatchMyAccountParams} patchMyAccountParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateMyAccount(patchMyAccountParams: PatchMyAccountParams, options?: any): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateMyAccount(patchMyAccountParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * 
     * @summary Deletes an account with given id. Superhero role is REQUIRED.
     * @param {string} id The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerDeleteAccountById(id: string, options?: any): AxiosPromise<AccountResponse>;

    /**
     * 
     * @summary Returns an account with given id. Superhero role is REQUIRED.
     * @param {string} id The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerFindAccountById(id: string, options?: any): AxiosPromise<AccountResponse>;

    /**
     * 
     * @summary Updates the the temporary account password for the authenticated user.
     * @param {PatchMyPasswordParams} patchMyPasswordParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerReplaceMyPassword(patchMyPasswordParams: PatchMyPasswordParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
     * @param {'userId' | 'username'} type The search criteria.
     * @param {string} value The search value.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerSearchAccounts(type: 'userId' | 'username', value: string, skip?: number, limit?: number, options?: any): AxiosPromise<AccountSearchListResponse>;

    /**
     * 
     * @summary Updates an account with given id. Superhero role is REQUIRED.
     * @param {string} id The id for the account.
     * @param {AccountByIdBodyParams} accountByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerUpdateAccountById(id: string, accountByIdBodyParams: AccountByIdBodyParams, options?: any): AxiosPromise<AccountResponse>;

    /**
     * 
     * @summary Updates an account for the authenticated user.
     * @param {PatchMyAccountParams} patchMyAccountParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountControllerUpdateMyAccount(patchMyAccountParams: PatchMyAccountParams, options?: any): AxiosPromise<void>;

}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
    /**
     * 
     * @summary Deletes an account with given id. Superhero role is REQUIRED.
     * @param {string} id The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerDeleteAccountById(id: string, options?: any) {
        return AccountApiFp(this.configuration).accountControllerDeleteAccountById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an account with given id. Superhero role is REQUIRED.
     * @param {string} id The id for the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerFindAccountById(id: string, options?: any) {
        return AccountApiFp(this.configuration).accountControllerFindAccountById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the the temporary account password for the authenticated user.
     * @param {PatchMyPasswordParams} patchMyPasswordParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerReplaceMyPassword(patchMyPasswordParams: PatchMyPasswordParams, options?: any) {
        return AccountApiFp(this.configuration).accountControllerReplaceMyPassword(patchMyPasswordParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all accounts which satisfies the given criteria. For unlimited access Superhero role is REQUIRED.
     * @param {'userId' | 'username'} type The search criteria.
     * @param {string} value The search value.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerSearchAccounts(type: 'userId' | 'username', value: string, skip?: number, limit?: number, options?: any) {
        return AccountApiFp(this.configuration).accountControllerSearchAccounts(type, value, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an account with given id. Superhero role is REQUIRED.
     * @param {string} id The id for the account.
     * @param {AccountByIdBodyParams} accountByIdBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerUpdateAccountById(id: string, accountByIdBodyParams: AccountByIdBodyParams, options?: any) {
        return AccountApiFp(this.configuration).accountControllerUpdateAccountById(id, accountByIdBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an account for the authenticated user.
     * @param {PatchMyAccountParams} patchMyAccountParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountControllerUpdateMyAccount(patchMyAccountParams: PatchMyAccountParams, options?: any) {
        return AccountApiFp(this.configuration).accountControllerUpdateMyAccount(patchMyAccountParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminStudentsApi - axios parameter creator
 * @export
 */
export const AdminStudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an student with given id.
         * @param {string} id The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiStudentsControllerFindStudentById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminApiStudentsControllerFindStudentById', 'id', id)
            const localVarPath = `/users/admin/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all students which satisfies the given criteria.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {number} [$limit] Page limit, defaults to 25.
         * @param {number} [$skip] Number of elements (not pages) to be skipped
         * @param {object} [$sort] Sort parameter.
         * @param {object} [consentStatus] 
         * @param {Array<string>} [classes] 
         * @param {object} [createdAt] 
         * @param {object} [lastLoginSystemChange] 
         * @param {object} [outdatedSince] 
         * @param {string} [searchQuery] 
         * @param {Array<string>} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiStudentsControllerSearchStudents: async (skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/admin/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($sort !== undefined) {
                localVarQueryParameter['$sort'] = $sort;
            }

            if (consentStatus !== undefined) {
                localVarQueryParameter['consentStatus'] = consentStatus;
            }

            if (classes) {
                localVarQueryParameter['classes'] = classes;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (lastLoginSystemChange !== undefined) {
                localVarQueryParameter['lastLoginSystemChange'] = lastLoginSystemChange;
            }

            if (outdatedSince !== undefined) {
                localVarQueryParameter['outdatedSince'] = outdatedSince;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['searchQuery'] = searchQuery;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminStudentsApi - functional programming interface
 * @export
 */
export const AdminStudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminStudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns an student with given id.
         * @param {string} id The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiStudentsControllerFindStudentById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiStudentsControllerFindStudentById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all students which satisfies the given criteria.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {number} [$limit] Page limit, defaults to 25.
         * @param {number} [$skip] Number of elements (not pages) to be skipped
         * @param {object} [$sort] Sort parameter.
         * @param {object} [consentStatus] 
         * @param {Array<string>} [classes] 
         * @param {object} [createdAt] 
         * @param {object} [lastLoginSystemChange] 
         * @param {object} [outdatedSince] 
         * @param {string} [searchQuery] 
         * @param {Array<string>} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiStudentsControllerSearchStudents(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiStudentsControllerSearchStudents(skip, limit, $limit, $skip, $sort, consentStatus, classes, createdAt, lastLoginSystemChange, outdatedSince, searchQuery, users, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminStudentsApi - factory interface
 * @export
 */
export const AdminStudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminStudentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns an student with given id.
         * @param {string} id The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiStudentsControllerFindStudentById(id: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.adminApiStudentsControllerFindStudentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all students which satisfies the given criteria.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {number} [$limit] Page limit, defaults to 25.
         * @param {number} [$skip] Number of elements (not pages) to be skipped
         * @param {object} [$sort] Sort parameter.
         * @param {object} [consentStatus] 
         * @param {Array<string>} [classes] 
         * @param {object} [createdAt] 
         * @param {object} [lastLoginSystemChange] 
         * @param {object} [outdatedSince] 
         * @param {string} [searchQuery] 
         * @param {Array<string>} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiStudentsControllerSearchStudents(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any): AxiosPromise<UserListResponse> {
            return localVarFp.adminApiStudentsControllerSearchStudents(skip, limit, $limit, $skip, $sort, consentStatus, classes, createdAt, lastLoginSystemChange, outdatedSince, searchQuery, users, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminStudentsApi - interface
 * @export
 * @interface AdminStudentsApi
 */
export interface AdminStudentsApiInterface {
    /**
     * 
     * @summary Returns an student with given id.
     * @param {string} id The id of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminStudentsApiInterface
     */
    adminApiStudentsControllerFindStudentById(id: string, options?: any): AxiosPromise<UserResponse>;

    /**
     * 
     * @summary Returns all students which satisfies the given criteria.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {number} [$limit] Page limit, defaults to 25.
     * @param {number} [$skip] Number of elements (not pages) to be skipped
     * @param {object} [$sort] Sort parameter.
     * @param {object} [consentStatus] 
     * @param {Array<string>} [classes] 
     * @param {object} [createdAt] 
     * @param {object} [lastLoginSystemChange] 
     * @param {object} [outdatedSince] 
     * @param {string} [searchQuery] 
     * @param {Array<string>} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminStudentsApiInterface
     */
    adminApiStudentsControllerSearchStudents(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any): AxiosPromise<UserListResponse>;

}

/**
 * AdminStudentsApi - object-oriented interface
 * @export
 * @class AdminStudentsApi
 * @extends {BaseAPI}
 */
export class AdminStudentsApi extends BaseAPI implements AdminStudentsApiInterface {
    /**
     * 
     * @summary Returns an student with given id.
     * @param {string} id The id of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminStudentsApi
     */
    public adminApiStudentsControllerFindStudentById(id: string, options?: any) {
        return AdminStudentsApiFp(this.configuration).adminApiStudentsControllerFindStudentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all students which satisfies the given criteria.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {number} [$limit] Page limit, defaults to 25.
     * @param {number} [$skip] Number of elements (not pages) to be skipped
     * @param {object} [$sort] Sort parameter.
     * @param {object} [consentStatus] 
     * @param {Array<string>} [classes] 
     * @param {object} [createdAt] 
     * @param {object} [lastLoginSystemChange] 
     * @param {object} [outdatedSince] 
     * @param {string} [searchQuery] 
     * @param {Array<string>} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminStudentsApi
     */
    public adminApiStudentsControllerSearchStudents(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any) {
        return AdminStudentsApiFp(this.configuration).adminApiStudentsControllerSearchStudents(skip, limit, $limit, $skip, $sort, consentStatus, classes, createdAt, lastLoginSystemChange, outdatedSince, searchQuery, users, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AdminTeachersApi - axios parameter creator
 * @export
 */
export const AdminTeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a teacher with given id.
         * @param {string} id The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiTeachersControllerFindTeacherById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('adminApiTeachersControllerFindTeacherById', 'id', id)
            const localVarPath = `/users/admin/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all teachers which satisfies the given criteria.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {number} [$limit] Page limit, defaults to 25.
         * @param {number} [$skip] Number of elements (not pages) to be skipped
         * @param {object} [$sort] Sort parameter.
         * @param {object} [consentStatus] 
         * @param {Array<string>} [classes] 
         * @param {object} [createdAt] 
         * @param {object} [lastLoginSystemChange] 
         * @param {object} [outdatedSince] 
         * @param {string} [searchQuery] 
         * @param {Array<string>} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiTeachersControllerSearchTeachers: async (skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/admin/teachers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($sort !== undefined) {
                localVarQueryParameter['$sort'] = $sort;
            }

            if (consentStatus !== undefined) {
                localVarQueryParameter['consentStatus'] = consentStatus;
            }

            if (classes) {
                localVarQueryParameter['classes'] = classes;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (lastLoginSystemChange !== undefined) {
                localVarQueryParameter['lastLoginSystemChange'] = lastLoginSystemChange;
            }

            if (outdatedSince !== undefined) {
                localVarQueryParameter['outdatedSince'] = outdatedSince;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['searchQuery'] = searchQuery;
            }

            if (users) {
                localVarQueryParameter['users'] = users;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminTeachersApi - functional programming interface
 * @export
 */
export const AdminTeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminTeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a teacher with given id.
         * @param {string} id The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiTeachersControllerFindTeacherById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiTeachersControllerFindTeacherById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all teachers which satisfies the given criteria.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {number} [$limit] Page limit, defaults to 25.
         * @param {number} [$skip] Number of elements (not pages) to be skipped
         * @param {object} [$sort] Sort parameter.
         * @param {object} [consentStatus] 
         * @param {Array<string>} [classes] 
         * @param {object} [createdAt] 
         * @param {object} [lastLoginSystemChange] 
         * @param {object} [outdatedSince] 
         * @param {string} [searchQuery] 
         * @param {Array<string>} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminApiTeachersControllerSearchTeachers(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminApiTeachersControllerSearchTeachers(skip, limit, $limit, $skip, $sort, consentStatus, classes, createdAt, lastLoginSystemChange, outdatedSince, searchQuery, users, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminTeachersApi - factory interface
 * @export
 */
export const AdminTeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminTeachersApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a teacher with given id.
         * @param {string} id The id of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiTeachersControllerFindTeacherById(id: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.adminApiTeachersControllerFindTeacherById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all teachers which satisfies the given criteria.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {number} [$limit] Page limit, defaults to 25.
         * @param {number} [$skip] Number of elements (not pages) to be skipped
         * @param {object} [$sort] Sort parameter.
         * @param {object} [consentStatus] 
         * @param {Array<string>} [classes] 
         * @param {object} [createdAt] 
         * @param {object} [lastLoginSystemChange] 
         * @param {object} [outdatedSince] 
         * @param {string} [searchQuery] 
         * @param {Array<string>} [users] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminApiTeachersControllerSearchTeachers(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any): AxiosPromise<UserListResponse> {
            return localVarFp.adminApiTeachersControllerSearchTeachers(skip, limit, $limit, $skip, $sort, consentStatus, classes, createdAt, lastLoginSystemChange, outdatedSince, searchQuery, users, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminTeachersApi - interface
 * @export
 * @interface AdminTeachersApi
 */
export interface AdminTeachersApiInterface {
    /**
     * 
     * @summary Returns a teacher with given id.
     * @param {string} id The id of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTeachersApiInterface
     */
    adminApiTeachersControllerFindTeacherById(id: string, options?: any): AxiosPromise<UserResponse>;

    /**
     * 
     * @summary Returns all teachers which satisfies the given criteria.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {number} [$limit] Page limit, defaults to 25.
     * @param {number} [$skip] Number of elements (not pages) to be skipped
     * @param {object} [$sort] Sort parameter.
     * @param {object} [consentStatus] 
     * @param {Array<string>} [classes] 
     * @param {object} [createdAt] 
     * @param {object} [lastLoginSystemChange] 
     * @param {object} [outdatedSince] 
     * @param {string} [searchQuery] 
     * @param {Array<string>} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTeachersApiInterface
     */
    adminApiTeachersControllerSearchTeachers(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any): AxiosPromise<UserListResponse>;

}

/**
 * AdminTeachersApi - object-oriented interface
 * @export
 * @class AdminTeachersApi
 * @extends {BaseAPI}
 */
export class AdminTeachersApi extends BaseAPI implements AdminTeachersApiInterface {
    /**
     * 
     * @summary Returns a teacher with given id.
     * @param {string} id The id of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTeachersApi
     */
    public adminApiTeachersControllerFindTeacherById(id: string, options?: any) {
        return AdminTeachersApiFp(this.configuration).adminApiTeachersControllerFindTeacherById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all teachers which satisfies the given criteria.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {number} [$limit] Page limit, defaults to 25.
     * @param {number} [$skip] Number of elements (not pages) to be skipped
     * @param {object} [$sort] Sort parameter.
     * @param {object} [consentStatus] 
     * @param {Array<string>} [classes] 
     * @param {object} [createdAt] 
     * @param {object} [lastLoginSystemChange] 
     * @param {object} [outdatedSince] 
     * @param {string} [searchQuery] 
     * @param {Array<string>} [users] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminTeachersApi
     */
    public adminApiTeachersControllerSearchTeachers(skip?: number, limit?: number, $limit?: number, $skip?: number, $sort?: object, consentStatus?: object, classes?: Array<string>, createdAt?: object, lastLoginSystemChange?: object, outdatedSince?: object, searchQuery?: string, users?: Array<string>, options?: any) {
        return AdminTeachersApiFp(this.configuration).adminApiTeachersControllerSearchTeachers(skip, limit, $limit, $skip, $sort, consentStatus, classes, createdAt, lastLoginSystemChange, outdatedSince, searchQuery, users, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlertApi - axios parameter creator
 * @export
 */
export const AlertApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get allerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFind: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertApi - functional programming interface
 * @export
 */
export const AlertApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get allerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async alertControllerFind(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.alertControllerFind(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlertApi - factory interface
 * @export
 */
export const AlertApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertApiFp(configuration)
    return {
        /**
         * 
         * @summary Get allerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        alertControllerFind(options?: any): AxiosPromise<AlertResponse> {
            return localVarFp.alertControllerFind(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertApi - interface
 * @export
 * @interface AlertApi
 */
export interface AlertApiInterface {
    /**
     * 
     * @summary Get allerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApiInterface
     */
    alertControllerFind(options?: any): AxiosPromise<AlertResponse>;

}

/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
export class AlertApi extends BaseAPI implements AlertApiInterface {
    /**
     * 
     * @summary Get allerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    public alertControllerFind(options?: any) {
        return AlertApiFp(this.configuration).alertControllerFind(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Starts the login process for users which are authenticated via LDAP
         * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginControllerLoginLdap: async (ldapAuthorizationBodyParams: LdapAuthorizationBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ldapAuthorizationBodyParams' is not null or undefined
            assertParamExists('loginControllerLoginLdap', 'ldapAuthorizationBodyParams', ldapAuthorizationBodyParams)
            const localVarPath = `/authentication/ldap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ldapAuthorizationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Starts the login process for users which are locally managed.
         * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginControllerLoginLocal: async (localAuthorizationBodyParams: LocalAuthorizationBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'localAuthorizationBodyParams' is not null or undefined
            assertParamExists('loginControllerLoginLocal', 'localAuthorizationBodyParams', localAuthorizationBodyParams)
            const localVarPath = `/authentication/local`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localAuthorizationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Starts the login process for users which are authenticated via OAuth 2.
         * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginControllerLoginOauth2: async (oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauth2AuthorizationBodyParams' is not null or undefined
            assertParamExists('loginControllerLoginOauth2', 'oauth2AuthorizationBodyParams', oauth2AuthorizationBodyParams)
            const localVarPath = `/authentication/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauth2AuthorizationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out a user from the external system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutControllerExternalSystemLogout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout/external`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutControllerLogout: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out a user for a given logout token from an external oidc system.
         * @param {OidcLogoutBodyParams} oidcLogoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutControllerLogoutOidc: async (oidcLogoutBodyParams: OidcLogoutBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oidcLogoutBodyParams' is not null or undefined
            assertParamExists('logoutControllerLogoutOidc', 'oidcLogoutBodyParams', oidcLogoutBodyParams)
            const localVarPath = `/logout/oidc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oidcLogoutBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Starts the login process for users which are authenticated via LDAP
         * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginControllerLoginLdap(ldapAuthorizationBodyParams: LdapAuthorizationBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginControllerLoginLdap(ldapAuthorizationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Starts the login process for users which are locally managed.
         * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginControllerLoginLocal(localAuthorizationBodyParams: LocalAuthorizationBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginControllerLoginLocal(localAuthorizationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Starts the login process for users which are authenticated via OAuth 2.
         * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginControllerLoginOauth2(oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginControllerLoginOauth2(oauth2AuthorizationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs out a user from the external system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutControllerExternalSystemLogout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutControllerExternalSystemLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs out a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutControllerLogout(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutControllerLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs out a user for a given logout token from an external oidc system.
         * @param {OidcLogoutBodyParams} oidcLogoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutControllerLogoutOidc(oidcLogoutBodyParams: OidcLogoutBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutControllerLogoutOidc(oidcLogoutBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Starts the login process for users which are authenticated via LDAP
         * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginControllerLoginLdap(ldapAuthorizationBodyParams: LdapAuthorizationBodyParams, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.loginControllerLoginLdap(ldapAuthorizationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Starts the login process for users which are locally managed.
         * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginControllerLoginLocal(localAuthorizationBodyParams: LocalAuthorizationBodyParams, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.loginControllerLoginLocal(localAuthorizationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Starts the login process for users which are authenticated via OAuth 2.
         * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginControllerLoginOauth2(oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.loginControllerLoginOauth2(oauth2AuthorizationBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs out a user from the external system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutControllerExternalSystemLogout(options?: any): AxiosPromise<void> {
            return localVarFp.logoutControllerExternalSystemLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs out a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutControllerLogout(options?: any): AxiosPromise<void> {
            return localVarFp.logoutControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs out a user for a given logout token from an external oidc system.
         * @param {OidcLogoutBodyParams} oidcLogoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutControllerLogoutOidc(oidcLogoutBodyParams: OidcLogoutBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.logoutControllerLogoutOidc(oidcLogoutBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @summary Starts the login process for users which are authenticated via LDAP
     * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    loginControllerLoginLdap(ldapAuthorizationBodyParams: LdapAuthorizationBodyParams, options?: any): AxiosPromise<LoginResponse>;

    /**
     * 
     * @summary Starts the login process for users which are locally managed.
     * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    loginControllerLoginLocal(localAuthorizationBodyParams: LocalAuthorizationBodyParams, options?: any): AxiosPromise<LoginResponse>;

    /**
     * 
     * @summary Starts the login process for users which are authenticated via OAuth 2.
     * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    loginControllerLoginOauth2(oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams, options?: any): AxiosPromise<LoginResponse>;

    /**
     * 
     * @summary Logs out a user from the external system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    logoutControllerExternalSystemLogout(options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Logs out a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    logoutControllerLogout(options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Logs out a user for a given logout token from an external oidc system.
     * @param {OidcLogoutBodyParams} oidcLogoutBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    logoutControllerLogoutOidc(oidcLogoutBodyParams: OidcLogoutBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @summary Starts the login process for users which are authenticated via LDAP
     * @param {LdapAuthorizationBodyParams} ldapAuthorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginControllerLoginLdap(ldapAuthorizationBodyParams: LdapAuthorizationBodyParams, options?: any) {
        return AuthenticationApiFp(this.configuration).loginControllerLoginLdap(ldapAuthorizationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Starts the login process for users which are locally managed.
     * @param {LocalAuthorizationBodyParams} localAuthorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginControllerLoginLocal(localAuthorizationBodyParams: LocalAuthorizationBodyParams, options?: any) {
        return AuthenticationApiFp(this.configuration).loginControllerLoginLocal(localAuthorizationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Starts the login process for users which are authenticated via OAuth 2.
     * @param {Oauth2AuthorizationBodyParams} oauth2AuthorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginControllerLoginOauth2(oauth2AuthorizationBodyParams: Oauth2AuthorizationBodyParams, options?: any) {
        return AuthenticationApiFp(this.configuration).loginControllerLoginOauth2(oauth2AuthorizationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs out a user from the external system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutControllerExternalSystemLogout(options?: any) {
        return AuthenticationApiFp(this.configuration).logoutControllerExternalSystemLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs out a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutControllerLogout(options?: any) {
        return AuthenticationApiFp(this.configuration).logoutControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs out a user for a given logout token from an external oidc system.
     * @param {OidcLogoutBodyParams} oidcLogoutBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutControllerLogoutOidc(oidcLogoutBodyParams: OidcLogoutBodyParams, options?: any) {
        return AuthenticationApiFp(this.configuration).logoutControllerLogoutOidc(oidcLogoutBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Checks if user is authorized to perform the given operation.
         * @param {AuthorizationBodyParams} authorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationReferenceControllerAuthorizeByReference: async (authorizationBodyParams: AuthorizationBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationBodyParams' is not null or undefined
            assertParamExists('authorizationReferenceControllerAuthorizeByReference', 'authorizationBodyParams', authorizationBodyParams)
            const localVarPath = `/authorization/by-reference`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Checks if user is authorized to perform the given operation.
         * @param {AuthorizationBodyParams} authorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams: AuthorizationBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizedReponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Checks if user is authorized to perform the given operation.
         * @param {AuthorizationBodyParams} authorizationBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams: AuthorizationBodyParams, options?: any): AxiosPromise<AuthorizedReponse> {
            return localVarFp.authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizationApi - interface
 * @export
 * @interface AuthorizationApi
 */
export interface AuthorizationApiInterface {
    /**
     * 
     * @summary Checks if user is authorized to perform the given operation.
     * @param {AuthorizationBodyParams} authorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApiInterface
     */
    authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams: AuthorizationBodyParams, options?: any): AxiosPromise<AuthorizedReponse>;

}

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI implements AuthorizationApiInterface {
    /**
     * 
     * @summary Checks if user is authorized to perform the given operation.
     * @param {AuthorizationBodyParams} authorizationBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams: AuthorizationBodyParams, options?: any) {
        return AuthorizationApiFp(this.configuration).authorizationReferenceControllerAuthorizeByReference(authorizationBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardApi - axios parameter creator
 * @export
 */
export const BoardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a board copy.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerCopyBoard: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerCopyBoard', 'boardId', boardId)
            const localVarPath = `/boards/{boardId}/copy`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new board.
         * @param {CreateBoardBodyParams} createBoardBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerCreateBoard: async (createBoardBodyParams: CreateBoardBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBoardBodyParams' is not null or undefined
            assertParamExists('boardControllerCreateBoard', 'createBoardBodyParams', createBoardBodyParams)
            const localVarPath = `/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBoardBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new column on a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerCreateColumn: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerCreateColumn', 'boardId', boardId)
            const localVarPath = `/boards/{boardId}/columns`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerDeleteBoard: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerDeleteBoard', 'boardId', boardId)
            const localVarPath = `/boards/{boardId}`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the context of a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerGetBoardContext: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerGetBoardContext', 'boardId', boardId)
            const localVarPath = `/boards/{boardId}/context`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the skeleton of a a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerGetBoardSkeleton: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerGetBoardSkeleton', 'boardId', boardId)
            const localVarPath = `/boards/{boardId}`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the title of a board.
         * @param {string} boardId The id of the board.
         * @param {UpdateBoardTitleParams} updateBoardTitleParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerUpdateBoardTitle: async (boardId: string, updateBoardTitleParams: UpdateBoardTitleParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerUpdateBoardTitle', 'boardId', boardId)
            // verify required parameter 'updateBoardTitleParams' is not null or undefined
            assertParamExists('boardControllerUpdateBoardTitle', 'updateBoardTitleParams', updateBoardTitleParams)
            const localVarPath = `/boards/{boardId}/title`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBoardTitleParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the layout of a board.
         * @param {string} boardId The id of the board.
         * @param {LayoutBodyParams} layoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerUpdateLayout: async (boardId: string, layoutBodyParams: LayoutBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerUpdateLayout', 'boardId', boardId)
            // verify required parameter 'layoutBodyParams' is not null or undefined
            assertParamExists('boardControllerUpdateLayout', 'layoutBodyParams', layoutBodyParams)
            const localVarPath = `/boards/{boardId}/layout`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(layoutBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the visibility of a board.
         * @param {string} boardId The id of the board.
         * @param {VisibilityBodyParams} visibilityBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerUpdateVisibility: async (boardId: string, visibilityBodyParams: VisibilityBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardControllerUpdateVisibility', 'boardId', boardId)
            // verify required parameter 'visibilityBodyParams' is not null or undefined
            assertParamExists('boardControllerUpdateVisibility', 'visibilityBodyParams', visibilityBodyParams)
            const localVarPath = `/boards/{boardId}/visibility`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(visibilityBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardApi - functional programming interface
 * @export
 */
export const BoardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a board copy.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerCopyBoard(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CopyApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerCopyBoard(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new board.
         * @param {CreateBoardBodyParams} createBoardBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerCreateBoard(createBoardBodyParams: CreateBoardBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBoardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerCreateBoard(createBoardBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new column on a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerCreateColumn(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ColumnResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerCreateColumn(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerDeleteBoard(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerDeleteBoard(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the context of a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerGetBoardContext(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerGetBoardContext(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the skeleton of a a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerGetBoardSkeleton(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerGetBoardSkeleton(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the title of a board.
         * @param {string} boardId The id of the board.
         * @param {UpdateBoardTitleParams} updateBoardTitleParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerUpdateBoardTitle(boardId: string, updateBoardTitleParams: UpdateBoardTitleParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerUpdateBoardTitle(boardId, updateBoardTitleParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the layout of a board.
         * @param {string} boardId The id of the board.
         * @param {LayoutBodyParams} layoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerUpdateLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerUpdateLayout(boardId, layoutBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the visibility of a board.
         * @param {string} boardId The id of the board.
         * @param {VisibilityBodyParams} visibilityBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardControllerUpdateVisibility(boardId: string, visibilityBodyParams: VisibilityBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardControllerUpdateVisibility(boardId, visibilityBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardApi - factory interface
 * @export
 */
export const BoardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a board copy.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerCopyBoard(boardId: string, options?: any): AxiosPromise<CopyApiResponse> {
            return localVarFp.boardControllerCopyBoard(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new board.
         * @param {CreateBoardBodyParams} createBoardBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerCreateBoard(createBoardBodyParams: CreateBoardBodyParams, options?: any): AxiosPromise<CreateBoardResponse> {
            return localVarFp.boardControllerCreateBoard(createBoardBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new column on a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerCreateColumn(boardId: string, options?: any): AxiosPromise<ColumnResponse> {
            return localVarFp.boardControllerCreateColumn(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerDeleteBoard(boardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.boardControllerDeleteBoard(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the context of a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerGetBoardContext(boardId: string, options?: any): AxiosPromise<BoardContextResponse> {
            return localVarFp.boardControllerGetBoardContext(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the skeleton of a a board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerGetBoardSkeleton(boardId: string, options?: any): AxiosPromise<BoardResponse> {
            return localVarFp.boardControllerGetBoardSkeleton(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the title of a board.
         * @param {string} boardId The id of the board.
         * @param {UpdateBoardTitleParams} updateBoardTitleParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerUpdateBoardTitle(boardId: string, updateBoardTitleParams: UpdateBoardTitleParams, options?: any): AxiosPromise<void> {
            return localVarFp.boardControllerUpdateBoardTitle(boardId, updateBoardTitleParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the layout of a board.
         * @param {string} boardId The id of the board.
         * @param {LayoutBodyParams} layoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerUpdateLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.boardControllerUpdateLayout(boardId, layoutBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the visibility of a board.
         * @param {string} boardId The id of the board.
         * @param {VisibilityBodyParams} visibilityBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardControllerUpdateVisibility(boardId: string, visibilityBodyParams: VisibilityBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.boardControllerUpdateVisibility(boardId, visibilityBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardApi - interface
 * @export
 * @interface BoardApi
 */
export interface BoardApiInterface {
    /**
     * 
     * @summary Create a board copy.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerCopyBoard(boardId: string, options?: any): AxiosPromise<CopyApiResponse>;

    /**
     * 
     * @summary Create a new board.
     * @param {CreateBoardBodyParams} createBoardBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerCreateBoard(createBoardBodyParams: CreateBoardBodyParams, options?: any): AxiosPromise<CreateBoardResponse>;

    /**
     * 
     * @summary Create a new column on a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerCreateColumn(boardId: string, options?: any): AxiosPromise<ColumnResponse>;

    /**
     * 
     * @summary Delete a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerDeleteBoard(boardId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Get the context of a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerGetBoardContext(boardId: string, options?: any): AxiosPromise<BoardContextResponse>;

    /**
     * 
     * @summary Get the skeleton of a a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerGetBoardSkeleton(boardId: string, options?: any): AxiosPromise<BoardResponse>;

    /**
     * 
     * @summary Update the title of a board.
     * @param {string} boardId The id of the board.
     * @param {UpdateBoardTitleParams} updateBoardTitleParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerUpdateBoardTitle(boardId: string, updateBoardTitleParams: UpdateBoardTitleParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the layout of a board.
     * @param {string} boardId The id of the board.
     * @param {LayoutBodyParams} layoutBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerUpdateLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the visibility of a board.
     * @param {string} boardId The id of the board.
     * @param {VisibilityBodyParams} visibilityBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApiInterface
     */
    boardControllerUpdateVisibility(boardId: string, visibilityBodyParams: VisibilityBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * BoardApi - object-oriented interface
 * @export
 * @class BoardApi
 * @extends {BaseAPI}
 */
export class BoardApi extends BaseAPI implements BoardApiInterface {
    /**
     * 
     * @summary Create a board copy.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerCopyBoard(boardId: string, options?: any) {
        return BoardApiFp(this.configuration).boardControllerCopyBoard(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new board.
     * @param {CreateBoardBodyParams} createBoardBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerCreateBoard(createBoardBodyParams: CreateBoardBodyParams, options?: any) {
        return BoardApiFp(this.configuration).boardControllerCreateBoard(createBoardBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new column on a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerCreateColumn(boardId: string, options?: any) {
        return BoardApiFp(this.configuration).boardControllerCreateColumn(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerDeleteBoard(boardId: string, options?: any) {
        return BoardApiFp(this.configuration).boardControllerDeleteBoard(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the context of a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerGetBoardContext(boardId: string, options?: any) {
        return BoardApiFp(this.configuration).boardControllerGetBoardContext(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the skeleton of a a board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerGetBoardSkeleton(boardId: string, options?: any) {
        return BoardApiFp(this.configuration).boardControllerGetBoardSkeleton(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the title of a board.
     * @param {string} boardId The id of the board.
     * @param {UpdateBoardTitleParams} updateBoardTitleParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerUpdateBoardTitle(boardId: string, updateBoardTitleParams: UpdateBoardTitleParams, options?: any) {
        return BoardApiFp(this.configuration).boardControllerUpdateBoardTitle(boardId, updateBoardTitleParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the layout of a board.
     * @param {string} boardId The id of the board.
     * @param {LayoutBodyParams} layoutBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerUpdateLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any) {
        return BoardApiFp(this.configuration).boardControllerUpdateLayout(boardId, layoutBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the visibility of a board.
     * @param {string} boardId The id of the board.
     * @param {VisibilityBodyParams} visibilityBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardApi
     */
    public boardControllerUpdateVisibility(boardId: string, visibilityBodyParams: VisibilityBodyParams, options?: any) {
        return BoardApiFp(this.configuration).boardControllerUpdateVisibility(boardId, visibilityBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardCardApi - axios parameter creator
 * @export
 */
export const BoardCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new element on a card.
         * @param {string} cardId The id of the card.
         * @param {CreateContentElementBodyParams} createContentElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerCreateElement: async (cardId: string, createContentElementBodyParams: CreateContentElementBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('cardControllerCreateElement', 'cardId', cardId)
            // verify required parameter 'createContentElementBodyParams' is not null or undefined
            assertParamExists('cardControllerCreateElement', 'createContentElementBodyParams', createContentElementBodyParams)
            const localVarPath = `/cards/{cardId}/elements`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContentElementBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single card.
         * @param {string} cardId The id of the card.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerDeleteCard: async (cardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('cardControllerDeleteCard', 'cardId', cardId)
            const localVarPath = `/cards/{cardId}`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of cards by their ids.
         * @param {Array<string>} ids Array of Ids to be loaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerGetCards: async (ids: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('cardControllerGetCards', 'ids', ids)
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a single card.
         * @param {string} cardId The id of the card.
         * @param {MoveCardBodyParams} moveCardBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerMoveCard: async (cardId: string, moveCardBodyParams: MoveCardBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('cardControllerMoveCard', 'cardId', cardId)
            // verify required parameter 'moveCardBodyParams' is not null or undefined
            assertParamExists('cardControllerMoveCard', 'moveCardBodyParams', moveCardBodyParams)
            const localVarPath = `/cards/{cardId}/position`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveCardBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the height of a single card.
         * @param {string} cardId The id of the card.
         * @param {SetHeightBodyParams} setHeightBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerUpdateCardHeight: async (cardId: string, setHeightBodyParams: SetHeightBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('cardControllerUpdateCardHeight', 'cardId', cardId)
            // verify required parameter 'setHeightBodyParams' is not null or undefined
            assertParamExists('cardControllerUpdateCardHeight', 'setHeightBodyParams', setHeightBodyParams)
            const localVarPath = `/cards/{cardId}/height`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setHeightBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the title of a single card.
         * @param {string} cardId The id of the card.
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerUpdateCardTitle: async (cardId: string, renameBodyParams: RenameBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('cardControllerUpdateCardTitle', 'cardId', cardId)
            // verify required parameter 'renameBodyParams' is not null or undefined
            assertParamExists('cardControllerUpdateCardTitle', 'renameBodyParams', renameBodyParams)
            const localVarPath = `/cards/{cardId}/title`
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardCardApi - functional programming interface
 * @export
 */
export const BoardCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardCardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new element on a card.
         * @param {string} cardId The id of the card.
         * @param {CreateContentElementBodyParams} createContentElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardControllerCreateElement(cardId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | DeletedElementResponse | VideoConferenceElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardControllerCreateElement(cardId, createContentElementBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a single card.
         * @param {string} cardId The id of the card.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardControllerDeleteCard(cardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardControllerDeleteCard(cardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of cards by their ids.
         * @param {Array<string>} ids Array of Ids to be loaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardControllerGetCards(ids: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardControllerGetCards(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move a single card.
         * @param {string} cardId The id of the card.
         * @param {MoveCardBodyParams} moveCardBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardControllerMoveCard(cardId: string, moveCardBodyParams: MoveCardBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardControllerMoveCard(cardId, moveCardBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the height of a single card.
         * @param {string} cardId The id of the card.
         * @param {SetHeightBodyParams} setHeightBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardControllerUpdateCardHeight(cardId: string, setHeightBodyParams: SetHeightBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardControllerUpdateCardHeight(cardId, setHeightBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the title of a single card.
         * @param {string} cardId The id of the card.
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cardControllerUpdateCardTitle(cardId: string, renameBodyParams: RenameBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cardControllerUpdateCardTitle(cardId, renameBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardCardApi - factory interface
 * @export
 */
export const BoardCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardCardApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new element on a card.
         * @param {string} cardId The id of the card.
         * @param {CreateContentElementBodyParams} createContentElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerCreateElement(cardId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any): AxiosPromise<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | DeletedElementResponse | VideoConferenceElementResponse> {
            return localVarFp.cardControllerCreateElement(cardId, createContentElementBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single card.
         * @param {string} cardId The id of the card.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerDeleteCard(cardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cardControllerDeleteCard(cardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of cards by their ids.
         * @param {Array<string>} ids Array of Ids to be loaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerGetCards(ids: Array<string>, options?: any): AxiosPromise<CardListResponse> {
            return localVarFp.cardControllerGetCards(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a single card.
         * @param {string} cardId The id of the card.
         * @param {MoveCardBodyParams} moveCardBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerMoveCard(cardId: string, moveCardBodyParams: MoveCardBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.cardControllerMoveCard(cardId, moveCardBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the height of a single card.
         * @param {string} cardId The id of the card.
         * @param {SetHeightBodyParams} setHeightBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerUpdateCardHeight(cardId: string, setHeightBodyParams: SetHeightBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.cardControllerUpdateCardHeight(cardId, setHeightBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the title of a single card.
         * @param {string} cardId The id of the card.
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardControllerUpdateCardTitle(cardId: string, renameBodyParams: RenameBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.cardControllerUpdateCardTitle(cardId, renameBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardCardApi - interface
 * @export
 * @interface BoardCardApi
 */
export interface BoardCardApiInterface {
    /**
     * 
     * @summary Create a new element on a card.
     * @param {string} cardId The id of the card.
     * @param {CreateContentElementBodyParams} createContentElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApiInterface
     */
    cardControllerCreateElement(cardId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any): AxiosPromise<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | DeletedElementResponse | VideoConferenceElementResponse>;

    /**
     * 
     * @summary Delete a single card.
     * @param {string} cardId The id of the card.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApiInterface
     */
    cardControllerDeleteCard(cardId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Get a list of cards by their ids.
     * @param {Array<string>} ids Array of Ids to be loaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApiInterface
     */
    cardControllerGetCards(ids: Array<string>, options?: any): AxiosPromise<CardListResponse>;

    /**
     * 
     * @summary Move a single card.
     * @param {string} cardId The id of the card.
     * @param {MoveCardBodyParams} moveCardBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApiInterface
     */
    cardControllerMoveCard(cardId: string, moveCardBodyParams: MoveCardBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the height of a single card.
     * @param {string} cardId The id of the card.
     * @param {SetHeightBodyParams} setHeightBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApiInterface
     */
    cardControllerUpdateCardHeight(cardId: string, setHeightBodyParams: SetHeightBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the title of a single card.
     * @param {string} cardId The id of the card.
     * @param {RenameBodyParams} renameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApiInterface
     */
    cardControllerUpdateCardTitle(cardId: string, renameBodyParams: RenameBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * BoardCardApi - object-oriented interface
 * @export
 * @class BoardCardApi
 * @extends {BaseAPI}
 */
export class BoardCardApi extends BaseAPI implements BoardCardApiInterface {
    /**
     * 
     * @summary Create a new element on a card.
     * @param {string} cardId The id of the card.
     * @param {CreateContentElementBodyParams} createContentElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApi
     */
    public cardControllerCreateElement(cardId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any) {
        return BoardCardApiFp(this.configuration).cardControllerCreateElement(cardId, createContentElementBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single card.
     * @param {string} cardId The id of the card.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApi
     */
    public cardControllerDeleteCard(cardId: string, options?: any) {
        return BoardCardApiFp(this.configuration).cardControllerDeleteCard(cardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of cards by their ids.
     * @param {Array<string>} ids Array of Ids to be loaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApi
     */
    public cardControllerGetCards(ids: Array<string>, options?: any) {
        return BoardCardApiFp(this.configuration).cardControllerGetCards(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a single card.
     * @param {string} cardId The id of the card.
     * @param {MoveCardBodyParams} moveCardBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApi
     */
    public cardControllerMoveCard(cardId: string, moveCardBodyParams: MoveCardBodyParams, options?: any) {
        return BoardCardApiFp(this.configuration).cardControllerMoveCard(cardId, moveCardBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the height of a single card.
     * @param {string} cardId The id of the card.
     * @param {SetHeightBodyParams} setHeightBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApi
     */
    public cardControllerUpdateCardHeight(cardId: string, setHeightBodyParams: SetHeightBodyParams, options?: any) {
        return BoardCardApiFp(this.configuration).cardControllerUpdateCardHeight(cardId, setHeightBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the title of a single card.
     * @param {string} cardId The id of the card.
     * @param {RenameBodyParams} renameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardCardApi
     */
    public cardControllerUpdateCardTitle(cardId: string, renameBodyParams: RenameBodyParams, options?: any) {
        return BoardCardApiFp(this.configuration).cardControllerUpdateCardTitle(cardId, renameBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardColumnApi - axios parameter creator
 * @export
 */
export const BoardColumnApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new card on a column.
         * @param {string} columnId The id of the column.
         * @param {CreateCardBodyParams} [createCardBodyParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerCreateCard: async (columnId: string, createCardBodyParams?: CreateCardBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('columnControllerCreateCard', 'columnId', columnId)
            const localVarPath = `/columns/{columnId}/cards`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCardBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single column.
         * @param {string} columnId The id of the column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerDeleteColumn: async (columnId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('columnControllerDeleteColumn', 'columnId', columnId)
            const localVarPath = `/columns/{columnId}`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a single column.
         * @param {string} columnId The id of the column.
         * @param {MoveColumnBodyParams} moveColumnBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerMoveColumn: async (columnId: string, moveColumnBodyParams: MoveColumnBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('columnControllerMoveColumn', 'columnId', columnId)
            // verify required parameter 'moveColumnBodyParams' is not null or undefined
            assertParamExists('columnControllerMoveColumn', 'moveColumnBodyParams', moveColumnBodyParams)
            const localVarPath = `/columns/{columnId}/position`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveColumnBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the title of a single column.
         * @param {string} columnId The id of the column.
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerUpdateColumnTitle: async (columnId: string, renameBodyParams: RenameBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'columnId' is not null or undefined
            assertParamExists('columnControllerUpdateColumnTitle', 'columnId', columnId)
            // verify required parameter 'renameBodyParams' is not null or undefined
            assertParamExists('columnControllerUpdateColumnTitle', 'renameBodyParams', renameBodyParams)
            const localVarPath = `/columns/{columnId}/title`
                .replace(`{${"columnId"}}`, encodeURIComponent(String(columnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardColumnApi - functional programming interface
 * @export
 */
export const BoardColumnApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardColumnApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new card on a column.
         * @param {string} columnId The id of the column.
         * @param {CreateCardBodyParams} [createCardBodyParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnControllerCreateCard(columnId: string, createCardBodyParams?: CreateCardBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnControllerCreateCard(columnId, createCardBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a single column.
         * @param {string} columnId The id of the column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnControllerDeleteColumn(columnId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnControllerDeleteColumn(columnId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move a single column.
         * @param {string} columnId The id of the column.
         * @param {MoveColumnBodyParams} moveColumnBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnControllerMoveColumn(columnId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnControllerMoveColumn(columnId, moveColumnBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the title of a single column.
         * @param {string} columnId The id of the column.
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnControllerUpdateColumnTitle(columnId: string, renameBodyParams: RenameBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnControllerUpdateColumnTitle(columnId, renameBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardColumnApi - factory interface
 * @export
 */
export const BoardColumnApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardColumnApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new card on a column.
         * @param {string} columnId The id of the column.
         * @param {CreateCardBodyParams} [createCardBodyParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerCreateCard(columnId: string, createCardBodyParams?: CreateCardBodyParams, options?: any): AxiosPromise<CardResponse> {
            return localVarFp.columnControllerCreateCard(columnId, createCardBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single column.
         * @param {string} columnId The id of the column.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerDeleteColumn(columnId: string, options?: any): AxiosPromise<void> {
            return localVarFp.columnControllerDeleteColumn(columnId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a single column.
         * @param {string} columnId The id of the column.
         * @param {MoveColumnBodyParams} moveColumnBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerMoveColumn(columnId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.columnControllerMoveColumn(columnId, moveColumnBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the title of a single column.
         * @param {string} columnId The id of the column.
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnControllerUpdateColumnTitle(columnId: string, renameBodyParams: RenameBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.columnControllerUpdateColumnTitle(columnId, renameBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardColumnApi - interface
 * @export
 * @interface BoardColumnApi
 */
export interface BoardColumnApiInterface {
    /**
     * 
     * @summary Create a new card on a column.
     * @param {string} columnId The id of the column.
     * @param {CreateCardBodyParams} [createCardBodyParams] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApiInterface
     */
    columnControllerCreateCard(columnId: string, createCardBodyParams?: CreateCardBodyParams, options?: any): AxiosPromise<CardResponse>;

    /**
     * 
     * @summary Delete a single column.
     * @param {string} columnId The id of the column.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApiInterface
     */
    columnControllerDeleteColumn(columnId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Move a single column.
     * @param {string} columnId The id of the column.
     * @param {MoveColumnBodyParams} moveColumnBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApiInterface
     */
    columnControllerMoveColumn(columnId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the title of a single column.
     * @param {string} columnId The id of the column.
     * @param {RenameBodyParams} renameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApiInterface
     */
    columnControllerUpdateColumnTitle(columnId: string, renameBodyParams: RenameBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * BoardColumnApi - object-oriented interface
 * @export
 * @class BoardColumnApi
 * @extends {BaseAPI}
 */
export class BoardColumnApi extends BaseAPI implements BoardColumnApiInterface {
    /**
     * 
     * @summary Create a new card on a column.
     * @param {string} columnId The id of the column.
     * @param {CreateCardBodyParams} [createCardBodyParams] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApi
     */
    public columnControllerCreateCard(columnId: string, createCardBodyParams?: CreateCardBodyParams, options?: any) {
        return BoardColumnApiFp(this.configuration).columnControllerCreateCard(columnId, createCardBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single column.
     * @param {string} columnId The id of the column.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApi
     */
    public columnControllerDeleteColumn(columnId: string, options?: any) {
        return BoardColumnApiFp(this.configuration).columnControllerDeleteColumn(columnId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a single column.
     * @param {string} columnId The id of the column.
     * @param {MoveColumnBodyParams} moveColumnBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApi
     */
    public columnControllerMoveColumn(columnId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any) {
        return BoardColumnApiFp(this.configuration).columnControllerMoveColumn(columnId, moveColumnBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the title of a single column.
     * @param {string} columnId The id of the column.
     * @param {RenameBodyParams} renameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardColumnApi
     */
    public columnControllerUpdateColumnTitle(columnId: string, renameBodyParams: RenameBodyParams, options?: any) {
        return BoardColumnApiFp(this.configuration).columnControllerUpdateColumnTitle(columnId, renameBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardElementApi - axios parameter creator
 * @export
 */
export const BoardElementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new submission item having parent a submission container element.
         * @param {string} contentElementId The id of the element.
         * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerCreateSubmissionItem: async (contentElementId: string, createSubmissionItemBodyParams: CreateSubmissionItemBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentElementId' is not null or undefined
            assertParamExists('elementControllerCreateSubmissionItem', 'contentElementId', contentElementId)
            // verify required parameter 'createSubmissionItemBodyParams' is not null or undefined
            assertParamExists('elementControllerCreateSubmissionItem', 'createSubmissionItemBodyParams', createSubmissionItemBodyParams)
            const localVarPath = `/elements/{contentElementId}/submissions`
                .replace(`{${"contentElementId"}}`, encodeURIComponent(String(contentElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubmissionItemBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerDeleteElement: async (contentElementId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentElementId' is not null or undefined
            assertParamExists('elementControllerDeleteElement', 'contentElementId', contentElementId)
            const localVarPath = `/elements/{contentElementId}`
                .replace(`{${"contentElementId"}}`, encodeURIComponent(String(contentElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {MoveContentElementBody} moveContentElementBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerMoveElement: async (contentElementId: string, moveContentElementBody: MoveContentElementBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentElementId' is not null or undefined
            assertParamExists('elementControllerMoveElement', 'contentElementId', contentElementId)
            // verify required parameter 'moveContentElementBody' is not null or undefined
            assertParamExists('elementControllerMoveElement', 'moveContentElementBody', moveContentElementBody)
            const localVarPath = `/elements/{contentElementId}/position`
                .replace(`{${"contentElementId"}}`, encodeURIComponent(String(contentElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveContentElementBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if user has read permission for any board element.
         * @param {string} contentElementId The id of the element.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerReadPermission: async (contentElementId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentElementId' is not null or undefined
            assertParamExists('elementControllerReadPermission', 'contentElementId', contentElementId)
            const localVarPath = `/elements/{contentElementId}/permission`
                .replace(`{${"contentElementId"}}`, encodeURIComponent(String(contentElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {UpdateElementContentBodyParams} updateElementContentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerUpdateElement: async (contentElementId: string, updateElementContentBodyParams: UpdateElementContentBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentElementId' is not null or undefined
            assertParamExists('elementControllerUpdateElement', 'contentElementId', contentElementId)
            // verify required parameter 'updateElementContentBodyParams' is not null or undefined
            assertParamExists('elementControllerUpdateElement', 'updateElementContentBodyParams', updateElementContentBodyParams)
            const localVarPath = `/elements/{contentElementId}/content`
                .replace(`{${"contentElementId"}}`, encodeURIComponent(String(contentElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateElementContentBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardElementApi - functional programming interface
 * @export
 */
export const BoardElementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardElementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new submission item having parent a submission container element.
         * @param {string} contentElementId The id of the element.
         * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async elementControllerCreateSubmissionItem(contentElementId: string, createSubmissionItemBodyParams: CreateSubmissionItemBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.elementControllerCreateSubmissionItem(contentElementId, createSubmissionItemBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async elementControllerDeleteElement(contentElementId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.elementControllerDeleteElement(contentElementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {MoveContentElementBody} moveContentElementBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async elementControllerMoveElement(contentElementId: string, moveContentElementBody: MoveContentElementBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.elementControllerMoveElement(contentElementId, moveContentElementBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if user has read permission for any board element.
         * @param {string} contentElementId The id of the element.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async elementControllerReadPermission(contentElementId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.elementControllerReadPermission(contentElementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {UpdateElementContentBodyParams} updateElementContentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async elementControllerUpdateElement(contentElementId: string, updateElementContentBodyParams: UpdateElementContentBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | VideoConferenceElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.elementControllerUpdateElement(contentElementId, updateElementContentBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardElementApi - factory interface
 * @export
 */
export const BoardElementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardElementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new submission item having parent a submission container element.
         * @param {string} contentElementId The id of the element.
         * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerCreateSubmissionItem(contentElementId: string, createSubmissionItemBodyParams: CreateSubmissionItemBodyParams, options?: any): AxiosPromise<SubmissionItemResponse> {
            return localVarFp.elementControllerCreateSubmissionItem(contentElementId, createSubmissionItemBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerDeleteElement(contentElementId: string, options?: any): AxiosPromise<void> {
            return localVarFp.elementControllerDeleteElement(contentElementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {MoveContentElementBody} moveContentElementBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerMoveElement(contentElementId: string, moveContentElementBody: MoveContentElementBody, options?: any): AxiosPromise<void> {
            return localVarFp.elementControllerMoveElement(contentElementId, moveContentElementBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if user has read permission for any board element.
         * @param {string} contentElementId The id of the element.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerReadPermission(contentElementId: string, options?: any): AxiosPromise<void> {
            return localVarFp.elementControllerReadPermission(contentElementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a single content element.
         * @param {string} contentElementId The id of the element.
         * @param {UpdateElementContentBodyParams} updateElementContentBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        elementControllerUpdateElement(contentElementId: string, updateElementContentBodyParams: UpdateElementContentBodyParams, options?: any): AxiosPromise<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | VideoConferenceElementResponse> {
            return localVarFp.elementControllerUpdateElement(contentElementId, updateElementContentBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardElementApi - interface
 * @export
 * @interface BoardElementApi
 */
export interface BoardElementApiInterface {
    /**
     * 
     * @summary Create a new submission item having parent a submission container element.
     * @param {string} contentElementId The id of the element.
     * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApiInterface
     */
    elementControllerCreateSubmissionItem(contentElementId: string, createSubmissionItemBodyParams: CreateSubmissionItemBodyParams, options?: any): AxiosPromise<SubmissionItemResponse>;

    /**
     * 
     * @summary Delete a single content element.
     * @param {string} contentElementId The id of the element.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApiInterface
     */
    elementControllerDeleteElement(contentElementId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Move a single content element.
     * @param {string} contentElementId The id of the element.
     * @param {MoveContentElementBody} moveContentElementBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApiInterface
     */
    elementControllerMoveElement(contentElementId: string, moveContentElementBody: MoveContentElementBody, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Check if user has read permission for any board element.
     * @param {string} contentElementId The id of the element.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApiInterface
     */
    elementControllerReadPermission(contentElementId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update a single content element.
     * @param {string} contentElementId The id of the element.
     * @param {UpdateElementContentBodyParams} updateElementContentBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApiInterface
     */
    elementControllerUpdateElement(contentElementId: string, updateElementContentBodyParams: UpdateElementContentBodyParams, options?: any): AxiosPromise<ExternalToolElementResponse | FileElementResponse | LinkElementResponse | RichTextElementResponse | SubmissionContainerElementResponse | DrawingElementResponse | VideoConferenceElementResponse>;

}

/**
 * BoardElementApi - object-oriented interface
 * @export
 * @class BoardElementApi
 * @extends {BaseAPI}
 */
export class BoardElementApi extends BaseAPI implements BoardElementApiInterface {
    /**
     * 
     * @summary Create a new submission item having parent a submission container element.
     * @param {string} contentElementId The id of the element.
     * @param {CreateSubmissionItemBodyParams} createSubmissionItemBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApi
     */
    public elementControllerCreateSubmissionItem(contentElementId: string, createSubmissionItemBodyParams: CreateSubmissionItemBodyParams, options?: any) {
        return BoardElementApiFp(this.configuration).elementControllerCreateSubmissionItem(contentElementId, createSubmissionItemBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single content element.
     * @param {string} contentElementId The id of the element.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApi
     */
    public elementControllerDeleteElement(contentElementId: string, options?: any) {
        return BoardElementApiFp(this.configuration).elementControllerDeleteElement(contentElementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a single content element.
     * @param {string} contentElementId The id of the element.
     * @param {MoveContentElementBody} moveContentElementBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApi
     */
    public elementControllerMoveElement(contentElementId: string, moveContentElementBody: MoveContentElementBody, options?: any) {
        return BoardElementApiFp(this.configuration).elementControllerMoveElement(contentElementId, moveContentElementBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if user has read permission for any board element.
     * @param {string} contentElementId The id of the element.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApi
     */
    public elementControllerReadPermission(contentElementId: string, options?: any) {
        return BoardElementApiFp(this.configuration).elementControllerReadPermission(contentElementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a single content element.
     * @param {string} contentElementId The id of the element.
     * @param {UpdateElementContentBodyParams} updateElementContentBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardElementApi
     */
    public elementControllerUpdateElement(contentElementId: string, updateElementContentBodyParams: UpdateElementContentBodyParams, options?: any) {
        return BoardElementApiFp(this.configuration).elementControllerUpdateElement(contentElementId, updateElementContentBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardSubmissionApi - axios parameter creator
 * @export
 */
export const BoardSubmissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new element in a submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {CreateContentElementBodyParams} createContentElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerCreateElement: async (submissionItemId: string, createContentElementBodyParams: CreateContentElementBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionItemId' is not null or undefined
            assertParamExists('boardSubmissionControllerCreateElement', 'submissionItemId', submissionItemId)
            // verify required parameter 'createContentElementBodyParams' is not null or undefined
            assertParamExists('boardSubmissionControllerCreateElement', 'createContentElementBodyParams', createContentElementBodyParams)
            const localVarPath = `/board-submissions/{submissionItemId}/elements`
                .replace(`{${"submissionItemId"}}`, encodeURIComponent(String(submissionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContentElementBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerDeleteSubmissionItem: async (submissionItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionItemId' is not null or undefined
            assertParamExists('boardSubmissionControllerDeleteSubmissionItem', 'submissionItemId', submissionItemId)
            const localVarPath = `/board-submissions/{submissionItemId}`
                .replace(`{${"submissionItemId"}}`, encodeURIComponent(String(submissionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of submission items by their parent container.
         * @param {string} submissionContainerId The id of the submission container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerGetSubmissionItems: async (submissionContainerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionContainerId' is not null or undefined
            assertParamExists('boardSubmissionControllerGetSubmissionItems', 'submissionContainerId', submissionContainerId)
            const localVarPath = `/board-submissions/{submissionContainerId}`
                .replace(`{${"submissionContainerId"}}`, encodeURIComponent(String(submissionContainerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a single submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {UpdateSubmissionItemBodyParams} updateSubmissionItemBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerUpdateSubmissionItem: async (submissionItemId: string, updateSubmissionItemBodyParams: UpdateSubmissionItemBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionItemId' is not null or undefined
            assertParamExists('boardSubmissionControllerUpdateSubmissionItem', 'submissionItemId', submissionItemId)
            // verify required parameter 'updateSubmissionItemBodyParams' is not null or undefined
            assertParamExists('boardSubmissionControllerUpdateSubmissionItem', 'updateSubmissionItemBodyParams', updateSubmissionItemBodyParams)
            const localVarPath = `/board-submissions/{submissionItemId}`
                .replace(`{${"submissionItemId"}}`, encodeURIComponent(String(submissionItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubmissionItemBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardSubmissionApi - functional programming interface
 * @export
 */
export const BoardSubmissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardSubmissionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new element in a submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {CreateContentElementBodyParams} createContentElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSubmissionControllerCreateElement(submissionItemId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RichTextElementResponse | FileElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSubmissionControllerCreateElement(submissionItemId, createContentElementBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a single submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSubmissionControllerDeleteSubmissionItem(submissionItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSubmissionControllerDeleteSubmissionItem(submissionItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of submission items by their parent container.
         * @param {string} submissionContainerId The id of the submission container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSubmissionControllerGetSubmissionItems(submissionContainerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSubmissionControllerGetSubmissionItems(submissionContainerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a single submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {UpdateSubmissionItemBodyParams} updateSubmissionItemBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSubmissionControllerUpdateSubmissionItem(submissionItemId: string, updateSubmissionItemBodyParams: UpdateSubmissionItemBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSubmissionControllerUpdateSubmissionItem(submissionItemId, updateSubmissionItemBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardSubmissionApi - factory interface
 * @export
 */
export const BoardSubmissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardSubmissionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new element in a submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {CreateContentElementBodyParams} createContentElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerCreateElement(submissionItemId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any): AxiosPromise<RichTextElementResponse | FileElementResponse> {
            return localVarFp.boardSubmissionControllerCreateElement(submissionItemId, createContentElementBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerDeleteSubmissionItem(submissionItemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.boardSubmissionControllerDeleteSubmissionItem(submissionItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of submission items by their parent container.
         * @param {string} submissionContainerId The id of the submission container.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerGetSubmissionItems(submissionContainerId: string, options?: any): AxiosPromise<SubmissionsResponse> {
            return localVarFp.boardSubmissionControllerGetSubmissionItems(submissionContainerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a single submission item.
         * @param {string} submissionItemId The id of the submission item.
         * @param {UpdateSubmissionItemBodyParams} updateSubmissionItemBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSubmissionControllerUpdateSubmissionItem(submissionItemId: string, updateSubmissionItemBodyParams: UpdateSubmissionItemBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.boardSubmissionControllerUpdateSubmissionItem(submissionItemId, updateSubmissionItemBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardSubmissionApi - interface
 * @export
 * @interface BoardSubmissionApi
 */
export interface BoardSubmissionApiInterface {
    /**
     * 
     * @summary Create a new element in a submission item.
     * @param {string} submissionItemId The id of the submission item.
     * @param {CreateContentElementBodyParams} createContentElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApiInterface
     */
    boardSubmissionControllerCreateElement(submissionItemId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any): AxiosPromise<RichTextElementResponse | FileElementResponse>;

    /**
     * 
     * @summary Delete a single submission item.
     * @param {string} submissionItemId The id of the submission item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApiInterface
     */
    boardSubmissionControllerDeleteSubmissionItem(submissionItemId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Get a list of submission items by their parent container.
     * @param {string} submissionContainerId The id of the submission container.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApiInterface
     */
    boardSubmissionControllerGetSubmissionItems(submissionContainerId: string, options?: any): AxiosPromise<SubmissionsResponse>;

    /**
     * 
     * @summary Update a single submission item.
     * @param {string} submissionItemId The id of the submission item.
     * @param {UpdateSubmissionItemBodyParams} updateSubmissionItemBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApiInterface
     */
    boardSubmissionControllerUpdateSubmissionItem(submissionItemId: string, updateSubmissionItemBodyParams: UpdateSubmissionItemBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * BoardSubmissionApi - object-oriented interface
 * @export
 * @class BoardSubmissionApi
 * @extends {BaseAPI}
 */
export class BoardSubmissionApi extends BaseAPI implements BoardSubmissionApiInterface {
    /**
     * 
     * @summary Create a new element in a submission item.
     * @param {string} submissionItemId The id of the submission item.
     * @param {CreateContentElementBodyParams} createContentElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApi
     */
    public boardSubmissionControllerCreateElement(submissionItemId: string, createContentElementBodyParams: CreateContentElementBodyParams, options?: any) {
        return BoardSubmissionApiFp(this.configuration).boardSubmissionControllerCreateElement(submissionItemId, createContentElementBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single submission item.
     * @param {string} submissionItemId The id of the submission item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApi
     */
    public boardSubmissionControllerDeleteSubmissionItem(submissionItemId: string, options?: any) {
        return BoardSubmissionApiFp(this.configuration).boardSubmissionControllerDeleteSubmissionItem(submissionItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of submission items by their parent container.
     * @param {string} submissionContainerId The id of the submission container.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApi
     */
    public boardSubmissionControllerGetSubmissionItems(submissionContainerId: string, options?: any) {
        return BoardSubmissionApiFp(this.configuration).boardSubmissionControllerGetSubmissionItems(submissionContainerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a single submission item.
     * @param {string} submissionItemId The id of the submission item.
     * @param {UpdateSubmissionItemBodyParams} updateSubmissionItemBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardSubmissionApi
     */
    public boardSubmissionControllerUpdateSubmissionItem(submissionItemId: string, updateSubmissionItemBodyParams: UpdateSubmissionItemBodyParams, options?: any) {
        return BoardSubmissionApiFp(this.configuration).boardSubmissionControllerUpdateSubmissionItem(submissionItemId, updateSubmissionItemBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollaborativeStorageApi - axios parameter creator
 * @export
 */
export const CollaborativeStorageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates the CRUD Permissions(+Share) for a specific Role in a Team
         * @param {string} teamId 
         * @param {string} roleId 
         * @param {TeamPermissionsBody} teamPermissionsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collaborativeStorageControllerUpdateTeamPermissionsForRole: async (teamId: string, roleId: string, teamPermissionsBody: TeamPermissionsBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('collaborativeStorageControllerUpdateTeamPermissionsForRole', 'teamId', teamId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('collaborativeStorageControllerUpdateTeamPermissionsForRole', 'roleId', roleId)
            // verify required parameter 'teamPermissionsBody' is not null or undefined
            assertParamExists('collaborativeStorageControllerUpdateTeamPermissionsForRole', 'teamPermissionsBody', teamPermissionsBody)
            const localVarPath = `/collaborative-storage/team/{teamId}/role/{roleId}/permissions`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamPermissionsBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollaborativeStorageApi - functional programming interface
 * @export
 */
export const CollaborativeStorageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollaborativeStorageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates the CRUD Permissions(+Share) for a specific Role in a Team
         * @param {string} teamId 
         * @param {string} roleId 
         * @param {TeamPermissionsBody} teamPermissionsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId: string, roleId: string, teamPermissionsBody: TeamPermissionsBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId, roleId, teamPermissionsBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollaborativeStorageApi - factory interface
 * @export
 */
export const CollaborativeStorageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollaborativeStorageApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates the CRUD Permissions(+Share) for a specific Role in a Team
         * @param {string} teamId 
         * @param {string} roleId 
         * @param {TeamPermissionsBody} teamPermissionsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId: string, roleId: string, teamPermissionsBody: TeamPermissionsBody, options?: any): AxiosPromise<void> {
            return localVarFp.collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId, roleId, teamPermissionsBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollaborativeStorageApi - interface
 * @export
 * @interface CollaborativeStorageApi
 */
export interface CollaborativeStorageApiInterface {
    /**
     * 
     * @summary Updates the CRUD Permissions(+Share) for a specific Role in a Team
     * @param {string} teamId 
     * @param {string} roleId 
     * @param {TeamPermissionsBody} teamPermissionsBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollaborativeStorageApiInterface
     */
    collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId: string, roleId: string, teamPermissionsBody: TeamPermissionsBody, options?: any): AxiosPromise<void>;

}

/**
 * CollaborativeStorageApi - object-oriented interface
 * @export
 * @class CollaborativeStorageApi
 * @extends {BaseAPI}
 */
export class CollaborativeStorageApi extends BaseAPI implements CollaborativeStorageApiInterface {
    /**
     * 
     * @summary Updates the CRUD Permissions(+Share) for a specific Role in a Team
     * @param {string} teamId 
     * @param {string} roleId 
     * @param {TeamPermissionsBody} teamPermissionsBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollaborativeStorageApi
     */
    public collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId: string, roleId: string, teamPermissionsBody: TeamPermissionsBody, options?: any) {
        return CollaborativeStorageApiFp(this.configuration).collaborativeStorageControllerUpdateTeamPermissionsForRole(teamId, roleId, teamPermissionsBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollaborativeTextEditorApi - axios parameter creator
 * @export
 */
export const CollaborativeTextEditorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete all etherpad sessions for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collaborativeTextEditorControllerDeleteSessionsByUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/collaborative-text-editor/delete-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get or create CollaborativeTextEditor for parent
         * @param {string} parentId 
         * @param {CollaborativeTextEditorParentType} parentType Parent type of the collaborative text editor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent: async (parentId: string, parentType: CollaborativeTextEditorParentType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentId' is not null or undefined
            assertParamExists('collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent', 'parentId', parentId)
            // verify required parameter 'parentType' is not null or undefined
            assertParamExists('collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent', 'parentType', parentType)
            const localVarPath = `/collaborative-text-editor/{parentType}/{parentId}`
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"parentType"}}`, encodeURIComponent(String(parentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollaborativeTextEditorApi - functional programming interface
 * @export
 */
export const CollaborativeTextEditorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollaborativeTextEditorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete all etherpad sessions for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collaborativeTextEditorControllerDeleteSessionsByUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collaborativeTextEditorControllerDeleteSessionsByUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get or create CollaborativeTextEditor for parent
         * @param {string} parentId 
         * @param {CollaborativeTextEditorParentType} parentType Parent type of the collaborative text editor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId: string, parentType: CollaborativeTextEditorParentType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollaborativeTextEditorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId, parentType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollaborativeTextEditorApi - factory interface
 * @export
 */
export const CollaborativeTextEditorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollaborativeTextEditorApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete all etherpad sessions for user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collaborativeTextEditorControllerDeleteSessionsByUser(options?: any): AxiosPromise<void> {
            return localVarFp.collaborativeTextEditorControllerDeleteSessionsByUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get or create CollaborativeTextEditor for parent
         * @param {string} parentId 
         * @param {CollaborativeTextEditorParentType} parentType Parent type of the collaborative text editor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId: string, parentType: CollaborativeTextEditorParentType, options?: any): AxiosPromise<CollaborativeTextEditorResponse> {
            return localVarFp.collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId, parentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollaborativeTextEditorApi - interface
 * @export
 * @interface CollaborativeTextEditorApi
 */
export interface CollaborativeTextEditorApiInterface {
    /**
     * 
     * @summary Delete all etherpad sessions for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollaborativeTextEditorApiInterface
     */
    collaborativeTextEditorControllerDeleteSessionsByUser(options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Get or create CollaborativeTextEditor for parent
     * @param {string} parentId 
     * @param {CollaborativeTextEditorParentType} parentType Parent type of the collaborative text editor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollaborativeTextEditorApiInterface
     */
    collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId: string, parentType: CollaborativeTextEditorParentType, options?: any): AxiosPromise<CollaborativeTextEditorResponse>;

}

/**
 * CollaborativeTextEditorApi - object-oriented interface
 * @export
 * @class CollaborativeTextEditorApi
 * @extends {BaseAPI}
 */
export class CollaborativeTextEditorApi extends BaseAPI implements CollaborativeTextEditorApiInterface {
    /**
     * 
     * @summary Delete all etherpad sessions for user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollaborativeTextEditorApi
     */
    public collaborativeTextEditorControllerDeleteSessionsByUser(options?: any) {
        return CollaborativeTextEditorApiFp(this.configuration).collaborativeTextEditorControllerDeleteSessionsByUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get or create CollaborativeTextEditor for parent
     * @param {string} parentId 
     * @param {CollaborativeTextEditorParentType} parentType Parent type of the collaborative text editor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollaborativeTextEditorApi
     */
    public collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId: string, parentType: CollaborativeTextEditorParentType, options?: any) {
        return CollaborativeTextEditorApiFp(this.configuration).collaborativeTextEditorControllerGetOrCreateCollaborativeTextEditorForParent(parentId, parentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseInfoApi - axios parameter creator
 * @export
 */
export const CourseInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get course information.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {CourseSortProps} [sortBy] 
         * @param {CourseStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseInfoControllerGetCourseInfo: async (skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: CourseSortProps, status?: CourseStatus, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/course-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseInfoApi - functional programming interface
 * @export
 */
export const CourseInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get course information.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {CourseSortProps} [sortBy] 
         * @param {CourseStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseInfoControllerGetCourseInfo(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: CourseSortProps, status?: CourseStatus, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseInfoControllerGetCourseInfo(skip, limit, sortOrder, sortBy, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseInfoApi - factory interface
 * @export
 */
export const CourseInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get course information.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {CourseSortProps} [sortBy] 
         * @param {CourseStatus} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseInfoControllerGetCourseInfo(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: CourseSortProps, status?: CourseStatus, options?: any): AxiosPromise<CourseInfoListResponse> {
            return localVarFp.courseInfoControllerGetCourseInfo(skip, limit, sortOrder, sortBy, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseInfoApi - interface
 * @export
 * @interface CourseInfoApi
 */
export interface CourseInfoApiInterface {
    /**
     * 
     * @summary Get course information.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {CourseSortProps} [sortBy] 
     * @param {CourseStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInfoApiInterface
     */
    courseInfoControllerGetCourseInfo(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: CourseSortProps, status?: CourseStatus, options?: any): AxiosPromise<CourseInfoListResponse>;

}

/**
 * CourseInfoApi - object-oriented interface
 * @export
 * @class CourseInfoApi
 * @extends {BaseAPI}
 */
export class CourseInfoApi extends BaseAPI implements CourseInfoApiInterface {
    /**
     * 
     * @summary Get course information.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {CourseSortProps} [sortBy] 
     * @param {CourseStatus} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInfoApi
     */
    public courseInfoControllerGetCourseInfo(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: CourseSortProps, status?: CourseStatus, options?: any) {
        return CourseInfoApiFp(this.configuration).courseInfoControllerGetCourseInfo(skip, limit, sortOrder, sortBy, status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CourseRoomsApi - axios parameter creator
 * @export
 */
export const CourseRoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerCopyCourse: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('courseRoomsControllerCopyCourse', 'roomId', roomId)
            const localVarPath = `/course-rooms/{roomId}/copy`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {LessonCopyApiParams} lessonCopyApiParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerCopyLesson: async (lessonId: string, lessonCopyApiParams: LessonCopyApiParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('courseRoomsControllerCopyLesson', 'lessonId', lessonId)
            // verify required parameter 'lessonCopyApiParams' is not null or undefined
            assertParamExists('courseRoomsControllerCopyLesson', 'lessonCopyApiParams', lessonCopyApiParams)
            const localVarPath = `/course-rooms/lessons/{lessonId}/copy`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lessonCopyApiParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerGetRoomBoard: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('courseRoomsControllerGetRoomBoard', 'roomId', roomId)
            const localVarPath = `/course-rooms/{roomId}/board`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {string} elementId The id of the element within the room.
         * @param {PatchVisibilityParams} patchVisibilityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerPatchElementVisibility: async (roomId: string, elementId: string, patchVisibilityParams: PatchVisibilityParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('courseRoomsControllerPatchElementVisibility', 'roomId', roomId)
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('courseRoomsControllerPatchElementVisibility', 'elementId', elementId)
            // verify required parameter 'patchVisibilityParams' is not null or undefined
            assertParamExists('courseRoomsControllerPatchElementVisibility', 'patchVisibilityParams', patchVisibilityParams)
            const localVarPath = `/course-rooms/{roomId}/elements/{elementId}/visibility`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"elementId"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchVisibilityParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {PatchOrderParams} patchOrderParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerPatchOrderingOfElements: async (roomId: string, patchOrderParams: PatchOrderParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('courseRoomsControllerPatchOrderingOfElements', 'roomId', roomId)
            // verify required parameter 'patchOrderParams' is not null or undefined
            assertParamExists('courseRoomsControllerPatchOrderingOfElements', 'patchOrderParams', patchOrderParams)
            const localVarPath = `/course-rooms/{roomId}/board/order`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchOrderParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseRoomsApi - functional programming interface
 * @export
 */
export const CourseRoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseRoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRoomsControllerCopyCourse(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CopyApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRoomsControllerCopyCourse(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {LessonCopyApiParams} lessonCopyApiParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRoomsControllerCopyLesson(lessonId: string, lessonCopyApiParams: LessonCopyApiParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CopyApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRoomsControllerCopyLesson(lessonId, lessonCopyApiParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRoomsControllerGetRoomBoard(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleColumnBoardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRoomsControllerGetRoomBoard(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {string} elementId The id of the element within the room.
         * @param {PatchVisibilityParams} patchVisibilityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRoomsControllerPatchElementVisibility(roomId: string, elementId: string, patchVisibilityParams: PatchVisibilityParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRoomsControllerPatchElementVisibility(roomId, elementId, patchVisibilityParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {PatchOrderParams} patchOrderParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseRoomsControllerPatchOrderingOfElements(roomId: string, patchOrderParams: PatchOrderParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseRoomsControllerPatchOrderingOfElements(roomId, patchOrderParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CourseRoomsApi - factory interface
 * @export
 */
export const CourseRoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseRoomsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerCopyCourse(roomId: string, options?: any): AxiosPromise<CopyApiResponse> {
            return localVarFp.courseRoomsControllerCopyCourse(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {LessonCopyApiParams} lessonCopyApiParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerCopyLesson(lessonId: string, lessonCopyApiParams: LessonCopyApiParams, options?: any): AxiosPromise<CopyApiResponse> {
            return localVarFp.courseRoomsControllerCopyLesson(lessonId, lessonCopyApiParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerGetRoomBoard(roomId: string, options?: any): AxiosPromise<SingleColumnBoardResponse> {
            return localVarFp.courseRoomsControllerGetRoomBoard(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {string} elementId The id of the element within the room.
         * @param {PatchVisibilityParams} patchVisibilityParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerPatchElementVisibility(roomId: string, elementId: string, patchVisibilityParams: PatchVisibilityParams, options?: any): AxiosPromise<void> {
            return localVarFp.courseRoomsControllerPatchElementVisibility(roomId, elementId, patchVisibilityParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roomId The id of the room.
         * @param {PatchOrderParams} patchOrderParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRoomsControllerPatchOrderingOfElements(roomId: string, patchOrderParams: PatchOrderParams, options?: any): AxiosPromise<void> {
            return localVarFp.courseRoomsControllerPatchOrderingOfElements(roomId, patchOrderParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseRoomsApi - interface
 * @export
 * @interface CourseRoomsApi
 */
export interface CourseRoomsApiInterface {
    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApiInterface
     */
    courseRoomsControllerCopyCourse(roomId: string, options?: any): AxiosPromise<CopyApiResponse>;

    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {LessonCopyApiParams} lessonCopyApiParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApiInterface
     */
    courseRoomsControllerCopyLesson(lessonId: string, lessonCopyApiParams: LessonCopyApiParams, options?: any): AxiosPromise<CopyApiResponse>;

    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApiInterface
     */
    courseRoomsControllerGetRoomBoard(roomId: string, options?: any): AxiosPromise<SingleColumnBoardResponse>;

    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {string} elementId The id of the element within the room.
     * @param {PatchVisibilityParams} patchVisibilityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApiInterface
     */
    courseRoomsControllerPatchElementVisibility(roomId: string, elementId: string, patchVisibilityParams: PatchVisibilityParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {PatchOrderParams} patchOrderParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApiInterface
     */
    courseRoomsControllerPatchOrderingOfElements(roomId: string, patchOrderParams: PatchOrderParams, options?: any): AxiosPromise<void>;

}

/**
 * CourseRoomsApi - object-oriented interface
 * @export
 * @class CourseRoomsApi
 * @extends {BaseAPI}
 */
export class CourseRoomsApi extends BaseAPI implements CourseRoomsApiInterface {
    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApi
     */
    public courseRoomsControllerCopyCourse(roomId: string, options?: any) {
        return CourseRoomsApiFp(this.configuration).courseRoomsControllerCopyCourse(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {LessonCopyApiParams} lessonCopyApiParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApi
     */
    public courseRoomsControllerCopyLesson(lessonId: string, lessonCopyApiParams: LessonCopyApiParams, options?: any) {
        return CourseRoomsApiFp(this.configuration).courseRoomsControllerCopyLesson(lessonId, lessonCopyApiParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApi
     */
    public courseRoomsControllerGetRoomBoard(roomId: string, options?: any) {
        return CourseRoomsApiFp(this.configuration).courseRoomsControllerGetRoomBoard(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {string} elementId The id of the element within the room.
     * @param {PatchVisibilityParams} patchVisibilityParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApi
     */
    public courseRoomsControllerPatchElementVisibility(roomId: string, elementId: string, patchVisibilityParams: PatchVisibilityParams, options?: any) {
        return CourseRoomsApiFp(this.configuration).courseRoomsControllerPatchElementVisibility(roomId, elementId, patchVisibilityParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roomId The id of the room.
     * @param {PatchOrderParams} patchOrderParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRoomsApi
     */
    public courseRoomsControllerPatchOrderingOfElements(roomId: string, patchOrderParams: PatchOrderParams, options?: any) {
        return CourseRoomsApiFp(this.configuration).courseRoomsControllerPatchOrderingOfElements(roomId, patchOrderParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new course.
         * @param {CreateCourseBodyParams} createCourseBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerCreateCourse: async (createCourseBodyParams: CreateCourseBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCourseBodyParams' is not null or undefined
            assertParamExists('courseControllerCreateCourse', 'createCourseBodyParams', createCourseBodyParams)
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCourseBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerFindForUser: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get common cartridge metadata of a course by Id.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerGetCourseCcMetadataById: async (courseId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseControllerGetCourseCcMetadataById', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/cc-metadata`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get permissions for a user in a course.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerGetUserPermissions: async (courseId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseControllerGetUserPermissions', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/user-permissions`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports a course from a Common Cartridge file.
         * @param {any} file The Common Cartridge file to import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerImportCourse: async (file: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('courseControllerImportCourse', 'file', file)
            const localVarPath = `/courses/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start the synchronization of a course with a group.
         * @param {string} courseId The id of the course
         * @param {CourseSyncBodyParams} courseSyncBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerStartSynchronization: async (courseId: string, courseSyncBodyParams: CourseSyncBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseControllerStartSynchronization', 'courseId', courseId)
            // verify required parameter 'courseSyncBodyParams' is not null or undefined
            assertParamExists('courseControllerStartSynchronization', 'courseSyncBodyParams', courseSyncBodyParams)
            const localVarPath = `/courses/{courseId}/start-sync`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseSyncBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the synchronization of a course with a group.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerStopSynchronization: async (courseId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseControllerStopSynchronization', 'courseId', courseId)
            const localVarPath = `/courses/{courseId}/stop-sync`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new course.
         * @param {CreateCourseBodyParams} createCourseBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerCreateCourse(createCourseBodyParams: CreateCourseBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCourseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerCreateCourse(createCourseBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerFindForUser(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMetadataListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerFindForUser(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get common cartridge metadata of a course by Id.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerGetCourseCcMetadataById(courseId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseCommonCartridgeMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerGetCourseCcMetadataById(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get permissions for a user in a course.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerGetUserPermissions(courseId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerGetUserPermissions(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Imports a course from a Common Cartridge file.
         * @param {any} file The Common Cartridge file to import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerImportCourse(file: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerImportCourse(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start the synchronization of a course with a group.
         * @param {string} courseId The id of the course
         * @param {CourseSyncBodyParams} courseSyncBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerStartSynchronization(courseId: string, courseSyncBodyParams: CourseSyncBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerStartSynchronization(courseId, courseSyncBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop the synchronization of a course with a group.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseControllerStopSynchronization(courseId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseControllerStopSynchronization(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoursesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new course.
         * @param {CreateCourseBodyParams} createCourseBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerCreateCourse(createCourseBodyParams: CreateCourseBodyParams, options?: any): AxiosPromise<CreateCourseResponse> {
            return localVarFp.courseControllerCreateCourse(createCourseBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerFindForUser(skip?: number, limit?: number, options?: any): AxiosPromise<CourseMetadataListResponse> {
            return localVarFp.courseControllerFindForUser(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get common cartridge metadata of a course by Id.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerGetCourseCcMetadataById(courseId: string, options?: any): AxiosPromise<CourseCommonCartridgeMetadataResponse> {
            return localVarFp.courseControllerGetCourseCcMetadataById(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get permissions for a user in a course.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerGetUserPermissions(courseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.courseControllerGetUserPermissions(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Imports a course from a Common Cartridge file.
         * @param {any} file The Common Cartridge file to import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerImportCourse(file: any, options?: any): AxiosPromise<void> {
            return localVarFp.courseControllerImportCourse(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start the synchronization of a course with a group.
         * @param {string} courseId The id of the course
         * @param {CourseSyncBodyParams} courseSyncBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerStartSynchronization(courseId: string, courseSyncBodyParams: CourseSyncBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.courseControllerStartSynchronization(courseId, courseSyncBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the synchronization of a course with a group.
         * @param {string} courseId The id of the course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseControllerStopSynchronization(courseId: string, options?: any): AxiosPromise<void> {
            return localVarFp.courseControllerStopSynchronization(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoursesApi - interface
 * @export
 * @interface CoursesApi
 */
export interface CoursesApiInterface {
    /**
     * 
     * @summary Create a new course.
     * @param {CreateCourseBodyParams} createCourseBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerCreateCourse(createCourseBodyParams: CreateCourseBodyParams, options?: any): AxiosPromise<CreateCourseResponse>;

    /**
     * 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerFindForUser(skip?: number, limit?: number, options?: any): AxiosPromise<CourseMetadataListResponse>;

    /**
     * 
     * @summary Get common cartridge metadata of a course by Id.
     * @param {string} courseId The id of the course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerGetCourseCcMetadataById(courseId: string, options?: any): AxiosPromise<CourseCommonCartridgeMetadataResponse>;

    /**
     * 
     * @summary Get permissions for a user in a course.
     * @param {string} courseId The id of the course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerGetUserPermissions(courseId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Imports a course from a Common Cartridge file.
     * @param {any} file The Common Cartridge file to import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerImportCourse(file: any, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Start the synchronization of a course with a group.
     * @param {string} courseId The id of the course
     * @param {CourseSyncBodyParams} courseSyncBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerStartSynchronization(courseId: string, courseSyncBodyParams: CourseSyncBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Stop the synchronization of a course with a group.
     * @param {string} courseId The id of the course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApiInterface
     */
    courseControllerStopSynchronization(courseId: string, options?: any): AxiosPromise<void>;

}

/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI implements CoursesApiInterface {
    /**
     * 
     * @summary Create a new course.
     * @param {CreateCourseBodyParams} createCourseBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerCreateCourse(createCourseBodyParams: CreateCourseBodyParams, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerCreateCourse(createCourseBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerFindForUser(skip?: number, limit?: number, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerFindForUser(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get common cartridge metadata of a course by Id.
     * @param {string} courseId The id of the course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerGetCourseCcMetadataById(courseId: string, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerGetCourseCcMetadataById(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get permissions for a user in a course.
     * @param {string} courseId The id of the course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerGetUserPermissions(courseId: string, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerGetUserPermissions(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Imports a course from a Common Cartridge file.
     * @param {any} file The Common Cartridge file to import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerImportCourse(file: any, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerImportCourse(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start the synchronization of a course with a group.
     * @param {string} courseId The id of the course
     * @param {CourseSyncBodyParams} courseSyncBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerStartSynchronization(courseId: string, courseSyncBodyParams: CourseSyncBodyParams, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerStartSynchronization(courseId, courseSyncBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the synchronization of a course with a group.
     * @param {string} courseId The id of the course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    public courseControllerStopSynchronization(courseId: string, options?: any) {
        return CoursesApiFp(this.configuration).courseControllerStopSynchronization(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerFindForUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dashboardId The id of the dashboard.
         * @param {MoveElementParams} moveElementParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerMoveElement: async (dashboardId: string, moveElementParams: MoveElementParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('dashboardControllerMoveElement', 'dashboardId', dashboardId)
            // verify required parameter 'moveElementParams' is not null or undefined
            assertParamExists('dashboardControllerMoveElement', 'moveElementParams', moveElementParams)
            const localVarPath = `/dashboard/{dashboardId}/moveElement`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveElementParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dashboardId The id of the dashboard.
         * @param {number} x 
         * @param {number} y 
         * @param {PatchGroupParams} patchGroupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerPatchGroup: async (dashboardId: string, x: number, y: number, patchGroupParams: PatchGroupParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('dashboardControllerPatchGroup', 'dashboardId', dashboardId)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('dashboardControllerPatchGroup', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('dashboardControllerPatchGroup', 'y', y)
            // verify required parameter 'patchGroupParams' is not null or undefined
            assertParamExists('dashboardControllerPatchGroup', 'patchGroupParams', patchGroupParams)
            const localVarPath = `/dashboard/{dashboardId}/element`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (x !== undefined) {
                localVarQueryParameter['x'] = x;
            }

            if (y !== undefined) {
                localVarQueryParameter['y'] = y;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchGroupParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardControllerFindForUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardControllerFindForUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dashboardId The id of the dashboard.
         * @param {MoveElementParams} moveElementParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardControllerMoveElement(dashboardId: string, moveElementParams: MoveElementParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardControllerMoveElement(dashboardId, moveElementParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dashboardId The id of the dashboard.
         * @param {number} x 
         * @param {number} y 
         * @param {PatchGroupParams} patchGroupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardControllerPatchGroup(dashboardId: string, x: number, y: number, patchGroupParams: PatchGroupParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardControllerPatchGroup(dashboardId, x, y, patchGroupParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerFindForUser(options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.dashboardControllerFindForUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dashboardId The id of the dashboard.
         * @param {MoveElementParams} moveElementParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerMoveElement(dashboardId: string, moveElementParams: MoveElementParams, options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.dashboardControllerMoveElement(dashboardId, moveElementParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dashboardId The id of the dashboard.
         * @param {number} x 
         * @param {number} y 
         * @param {PatchGroupParams} patchGroupParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerPatchGroup(dashboardId: string, x: number, y: number, patchGroupParams: PatchGroupParams, options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.dashboardControllerPatchGroup(dashboardId, x, y, patchGroupParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - interface
 * @export
 * @interface DashboardApi
 */
export interface DashboardApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApiInterface
     */
    dashboardControllerFindForUser(options?: any): AxiosPromise<DashboardResponse>;

    /**
     * 
     * @param {string} dashboardId The id of the dashboard.
     * @param {MoveElementParams} moveElementParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApiInterface
     */
    dashboardControllerMoveElement(dashboardId: string, moveElementParams: MoveElementParams, options?: any): AxiosPromise<DashboardResponse>;

    /**
     * 
     * @param {string} dashboardId The id of the dashboard.
     * @param {number} x 
     * @param {number} y 
     * @param {PatchGroupParams} patchGroupParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApiInterface
     */
    dashboardControllerPatchGroup(dashboardId: string, x: number, y: number, patchGroupParams: PatchGroupParams, options?: any): AxiosPromise<DashboardResponse>;

}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI implements DashboardApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public dashboardControllerFindForUser(options?: any) {
        return DashboardApiFp(this.configuration).dashboardControllerFindForUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dashboardId The id of the dashboard.
     * @param {MoveElementParams} moveElementParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public dashboardControllerMoveElement(dashboardId: string, moveElementParams: MoveElementParams, options?: any) {
        return DashboardApiFp(this.configuration).dashboardControllerMoveElement(dashboardId, moveElementParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dashboardId The id of the dashboard.
     * @param {number} x 
     * @param {number} y 
     * @param {PatchGroupParams} patchGroupParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public dashboardControllerPatchGroup(dashboardId: string, x: number, y: number, patchGroupParams: PatchGroupParams, options?: any) {
        return DashboardApiFp(this.configuration).dashboardControllerPatchGroup(dashboardId, x, y, patchGroupParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of classes and groups of type class for the current user.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {ClassSortQueryType} [sortBy] 
         * @param {SchoolYearQueryType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerFindClasses: async (skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: ClassSortQueryType, type?: SchoolYearQueryType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all groups.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {boolean} [availableGroupsForCourseSync] if true only available groups for a course sync are returned.
         * @param {string} [nameQuery] search string for group names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetAllGroups: async (skip?: number, limit?: number, availableGroupsForCourseSync?: boolean, nameQuery?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (availableGroupsForCourseSync !== undefined) {
                localVarQueryParameter['availableGroupsForCourseSync'] = availableGroupsForCourseSync;
            }

            if (nameQuery !== undefined) {
                localVarQueryParameter['nameQuery'] = nameQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a group by id.
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupControllerGetGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a list of classes and groups of type class for the current user.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {ClassSortQueryType} [sortBy] 
         * @param {SchoolYearQueryType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerFindClasses(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: ClassSortQueryType, type?: SchoolYearQueryType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassInfoSearchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerFindClasses(skip, limit, sortOrder, sortBy, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all groups.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {boolean} [availableGroupsForCourseSync] if true only available groups for a course sync are returned.
         * @param {string} [nameQuery] search string for group names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetAllGroups(skip?: number, limit?: number, availableGroupsForCourseSync?: boolean, nameQuery?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetAllGroups(skip, limit, availableGroupsForCourseSync, nameQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a group by id.
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupControllerGetGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupControllerGetGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a list of classes and groups of type class for the current user.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {ClassSortQueryType} [sortBy] 
         * @param {SchoolYearQueryType} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerFindClasses(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: ClassSortQueryType, type?: SchoolYearQueryType, options?: any): AxiosPromise<ClassInfoSearchListResponse> {
            return localVarFp.groupControllerFindClasses(skip, limit, sortOrder, sortBy, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all groups.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {boolean} [availableGroupsForCourseSync] if true only available groups for a course sync are returned.
         * @param {string} [nameQuery] search string for group names.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetAllGroups(skip?: number, limit?: number, availableGroupsForCourseSync?: boolean, nameQuery?: string, options?: any): AxiosPromise<GroupListResponse> {
            return localVarFp.groupControllerGetAllGroups(skip, limit, availableGroupsForCourseSync, nameQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a group by id.
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupControllerGetGroup(groupId: string, options?: any): AxiosPromise<GroupResponse> {
            return localVarFp.groupControllerGetGroup(groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - interface
 * @export
 * @interface GroupApi
 */
export interface GroupApiInterface {
    /**
     * 
     * @summary Get a list of classes and groups of type class for the current user.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {ClassSortQueryType} [sortBy] 
     * @param {SchoolYearQueryType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    groupControllerFindClasses(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: ClassSortQueryType, type?: SchoolYearQueryType, options?: any): AxiosPromise<ClassInfoSearchListResponse>;

    /**
     * 
     * @summary Get a list of all groups.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {boolean} [availableGroupsForCourseSync] if true only available groups for a course sync are returned.
     * @param {string} [nameQuery] search string for group names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    groupControllerGetAllGroups(skip?: number, limit?: number, availableGroupsForCourseSync?: boolean, nameQuery?: string, options?: any): AxiosPromise<GroupListResponse>;

    /**
     * 
     * @summary Get a group by id.
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApiInterface
     */
    groupControllerGetGroup(groupId: string, options?: any): AxiosPromise<GroupResponse>;

}

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI implements GroupApiInterface {
    /**
     * 
     * @summary Get a list of classes and groups of type class for the current user.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {ClassSortQueryType} [sortBy] 
     * @param {SchoolYearQueryType} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerFindClasses(skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: ClassSortQueryType, type?: SchoolYearQueryType, options?: any) {
        return GroupApiFp(this.configuration).groupControllerFindClasses(skip, limit, sortOrder, sortBy, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all groups.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {boolean} [availableGroupsForCourseSync] if true only available groups for a course sync are returned.
     * @param {string} [nameQuery] search string for group names.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetAllGroups(skip?: number, limit?: number, availableGroupsForCourseSync?: boolean, nameQuery?: string, options?: any) {
        return GroupApiFp(this.configuration).groupControllerGetAllGroups(skip, limit, availableGroupsForCourseSync, nameQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a group by id.
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public groupControllerGetGroup(groupId: string, options?: any) {
        return GroupApiFp(this.configuration).groupControllerGetGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LessonApi - axios parameter creator
 * @export
 */
export const LessonApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerDelete: async (lessonId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('lessonControllerDelete', 'lessonId', lessonId)
            const localVarPath = `/lessons/{lessonId}`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} courseId The id of the course the lesson belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetCourseLessons: async (courseId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('lessonControllerGetCourseLessons', 'courseId', courseId)
            const localVarPath = `/lessons/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLesson: async (lessonId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('lessonControllerGetLesson', 'lessonId', lessonId)
            const localVarPath = `/lessons/{lessonId}`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLessonTasks: async (lessonId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lessonId' is not null or undefined
            assertParamExists('lessonControllerGetLessonTasks', 'lessonId', lessonId)
            const localVarPath = `/lessons/{lessonId}/tasks`
                .replace(`{${"lessonId"}}`, encodeURIComponent(String(lessonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LessonApi - functional programming interface
 * @export
 */
export const LessonApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LessonApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerDelete(lessonId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerDelete(lessonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} courseId The id of the course the lesson belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerGetCourseLessons(courseId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonMetadataListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerGetCourseLessons(courseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerGetLesson(lessonId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LessonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerGetLesson(lessonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lessonControllerGetLessonTasks(lessonId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LessonLinkedTaskResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lessonControllerGetLessonTasks(lessonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LessonApi - factory interface
 * @export
 */
export const LessonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LessonApiFp(configuration)
    return {
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerDelete(lessonId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.lessonControllerDelete(lessonId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} courseId The id of the course the lesson belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetCourseLessons(courseId: string, options?: any): AxiosPromise<LessonMetadataListResponse> {
            return localVarFp.lessonControllerGetCourseLessons(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLesson(lessonId: string, options?: any): AxiosPromise<LessonResponse> {
            return localVarFp.lessonControllerGetLesson(lessonId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lessonId The id of the lesson.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lessonControllerGetLessonTasks(lessonId: string, options?: any): AxiosPromise<Array<LessonLinkedTaskResponse>> {
            return localVarFp.lessonControllerGetLessonTasks(lessonId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LessonApi - interface
 * @export
 * @interface LessonApi
 */
export interface LessonApiInterface {
    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApiInterface
     */
    lessonControllerDelete(lessonId: string, options?: any): AxiosPromise<boolean>;

    /**
     * 
     * @param {string} courseId The id of the course the lesson belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApiInterface
     */
    lessonControllerGetCourseLessons(courseId: string, options?: any): AxiosPromise<LessonMetadataListResponse>;

    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApiInterface
     */
    lessonControllerGetLesson(lessonId: string, options?: any): AxiosPromise<LessonResponse>;

    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApiInterface
     */
    lessonControllerGetLessonTasks(lessonId: string, options?: any): AxiosPromise<Array<LessonLinkedTaskResponse>>;

}

/**
 * LessonApi - object-oriented interface
 * @export
 * @class LessonApi
 * @extends {BaseAPI}
 */
export class LessonApi extends BaseAPI implements LessonApiInterface {
    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonControllerDelete(lessonId: string, options?: any) {
        return LessonApiFp(this.configuration).lessonControllerDelete(lessonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} courseId The id of the course the lesson belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonControllerGetCourseLessons(courseId: string, options?: any) {
        return LessonApiFp(this.configuration).lessonControllerGetCourseLessons(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonControllerGetLesson(lessonId: string, options?: any) {
        return LessonApiFp(this.configuration).lessonControllerGetLesson(lessonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lessonId The id of the lesson.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LessonApi
     */
    public lessonControllerGetLessonTasks(lessonId: string, options?: any) {
        return LessonApiFp(this.configuration).lessonControllerGetLessonTasks(lessonId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Resolve jwt and response informations about the owner of the jwt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meControllerMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Resolve jwt and response informations about the owner of the jwt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meControllerMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meControllerMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * 
         * @summary Resolve jwt and response informations about the owner of the jwt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meControllerMe(options?: any): AxiosPromise<MeResponse> {
            return localVarFp.meControllerMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - interface
 * @export
 * @interface MeApi
 */
export interface MeApiInterface {
    /**
     * 
     * @summary Resolve jwt and response informations about the owner of the jwt.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiInterface
     */
    meControllerMe(options?: any): AxiosPromise<MeResponse>;

}

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI implements MeApiInterface {
    /**
     * 
     * @summary Resolve jwt and response informations about the owner of the jwt.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public meControllerMe(options?: any) {
        return MeApiFp(this.configuration).meControllerMe(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaBoardApi - axios parameter creator
 * @export
 */
export const MediaBoardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Collapse available line in media board.
         * @param {string} boardId The id of the board.
         * @param {CollapsableBodyParams} collapsableBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerCollapseMediaAvailableLine: async (boardId: string, collapsableBodyParams: CollapsableBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('mediaBoardControllerCollapseMediaAvailableLine', 'boardId', boardId)
            // verify required parameter 'collapsableBodyParams' is not null or undefined
            assertParamExists('mediaBoardControllerCollapseMediaAvailableLine', 'collapsableBodyParams', collapsableBodyParams)
            const localVarPath = `/media-boards/{boardId}/media-available-line/collapse`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collapsableBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new line on a media board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerCreateLine: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('mediaBoardControllerCreateLine', 'boardId', boardId)
            const localVarPath = `/media-boards/{boardId}/media-lines`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the media available line for the board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerGetMediaAvailableLine: async (boardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('mediaBoardControllerGetMediaAvailableLine', 'boardId', boardId)
            const localVarPath = `/media-boards/{boardId}/media-available-line`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the media shelf of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerGetMediaBoardForUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/media-boards/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set layout for media board.
         * @param {string} boardId The id of the board.
         * @param {LayoutBodyParams} layoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerSetMediaBoardLayout: async (boardId: string, layoutBodyParams: LayoutBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('mediaBoardControllerSetMediaBoardLayout', 'boardId', boardId)
            // verify required parameter 'layoutBodyParams' is not null or undefined
            assertParamExists('mediaBoardControllerSetMediaBoardLayout', 'layoutBodyParams', layoutBodyParams)
            const localVarPath = `/media-boards/{boardId}/layout`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(layoutBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the color of available line in media board.
         * @param {string} boardId The id of the board.
         * @param {ColorBodyParams} colorBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerUpdateMediaAvailableLineColor: async (boardId: string, colorBodyParams: ColorBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('mediaBoardControllerUpdateMediaAvailableLineColor', 'boardId', boardId)
            // verify required parameter 'colorBodyParams' is not null or undefined
            assertParamExists('mediaBoardControllerUpdateMediaAvailableLineColor', 'colorBodyParams', colorBodyParams)
            const localVarPath = `/media-boards/{boardId}/media-available-line/color`
                .replace(`{${"boardId"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(colorBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaBoardApi - functional programming interface
 * @export
 */
export const MediaBoardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaBoardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Collapse available line in media board.
         * @param {string} boardId The id of the board.
         * @param {CollapsableBodyParams} collapsableBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaBoardControllerCollapseMediaAvailableLine(boardId: string, collapsableBodyParams: CollapsableBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaBoardControllerCollapseMediaAvailableLine(boardId, collapsableBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new line on a media board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaBoardControllerCreateLine(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaLineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaBoardControllerCreateLine(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the media available line for the board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaBoardControllerGetMediaAvailableLine(boardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaAvailableLineResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaBoardControllerGetMediaAvailableLine(boardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the media shelf of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaBoardControllerGetMediaBoardForUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaBoardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaBoardControllerGetMediaBoardForUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set layout for media board.
         * @param {string} boardId The id of the board.
         * @param {LayoutBodyParams} layoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaBoardControllerSetMediaBoardLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaBoardControllerSetMediaBoardLayout(boardId, layoutBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the color of available line in media board.
         * @param {string} boardId The id of the board.
         * @param {ColorBodyParams} colorBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaBoardControllerUpdateMediaAvailableLineColor(boardId: string, colorBodyParams: ColorBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaBoardControllerUpdateMediaAvailableLineColor(boardId, colorBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaBoardApi - factory interface
 * @export
 */
export const MediaBoardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaBoardApiFp(configuration)
    return {
        /**
         * 
         * @summary Collapse available line in media board.
         * @param {string} boardId The id of the board.
         * @param {CollapsableBodyParams} collapsableBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerCollapseMediaAvailableLine(boardId: string, collapsableBodyParams: CollapsableBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaBoardControllerCollapseMediaAvailableLine(boardId, collapsableBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new line on a media board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerCreateLine(boardId: string, options?: any): AxiosPromise<MediaLineResponse> {
            return localVarFp.mediaBoardControllerCreateLine(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the media available line for the board.
         * @param {string} boardId The id of the board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerGetMediaAvailableLine(boardId: string, options?: any): AxiosPromise<MediaAvailableLineResponse> {
            return localVarFp.mediaBoardControllerGetMediaAvailableLine(boardId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the media shelf of the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerGetMediaBoardForUser(options?: any): AxiosPromise<MediaBoardResponse> {
            return localVarFp.mediaBoardControllerGetMediaBoardForUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set layout for media board.
         * @param {string} boardId The id of the board.
         * @param {LayoutBodyParams} layoutBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerSetMediaBoardLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaBoardControllerSetMediaBoardLayout(boardId, layoutBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the color of available line in media board.
         * @param {string} boardId The id of the board.
         * @param {ColorBodyParams} colorBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaBoardControllerUpdateMediaAvailableLineColor(boardId: string, colorBodyParams: ColorBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaBoardControllerUpdateMediaAvailableLineColor(boardId, colorBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaBoardApi - interface
 * @export
 * @interface MediaBoardApi
 */
export interface MediaBoardApiInterface {
    /**
     * 
     * @summary Collapse available line in media board.
     * @param {string} boardId The id of the board.
     * @param {CollapsableBodyParams} collapsableBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApiInterface
     */
    mediaBoardControllerCollapseMediaAvailableLine(boardId: string, collapsableBodyParams: CollapsableBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Create a new line on a media board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApiInterface
     */
    mediaBoardControllerCreateLine(boardId: string, options?: any): AxiosPromise<MediaLineResponse>;

    /**
     * 
     * @summary Get the media available line for the board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApiInterface
     */
    mediaBoardControllerGetMediaAvailableLine(boardId: string, options?: any): AxiosPromise<MediaAvailableLineResponse>;

    /**
     * 
     * @summary Get the media shelf of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApiInterface
     */
    mediaBoardControllerGetMediaBoardForUser(options?: any): AxiosPromise<MediaBoardResponse>;

    /**
     * 
     * @summary Set layout for media board.
     * @param {string} boardId The id of the board.
     * @param {LayoutBodyParams} layoutBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApiInterface
     */
    mediaBoardControllerSetMediaBoardLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the color of available line in media board.
     * @param {string} boardId The id of the board.
     * @param {ColorBodyParams} colorBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApiInterface
     */
    mediaBoardControllerUpdateMediaAvailableLineColor(boardId: string, colorBodyParams: ColorBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * MediaBoardApi - object-oriented interface
 * @export
 * @class MediaBoardApi
 * @extends {BaseAPI}
 */
export class MediaBoardApi extends BaseAPI implements MediaBoardApiInterface {
    /**
     * 
     * @summary Collapse available line in media board.
     * @param {string} boardId The id of the board.
     * @param {CollapsableBodyParams} collapsableBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApi
     */
    public mediaBoardControllerCollapseMediaAvailableLine(boardId: string, collapsableBodyParams: CollapsableBodyParams, options?: any) {
        return MediaBoardApiFp(this.configuration).mediaBoardControllerCollapseMediaAvailableLine(boardId, collapsableBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new line on a media board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApi
     */
    public mediaBoardControllerCreateLine(boardId: string, options?: any) {
        return MediaBoardApiFp(this.configuration).mediaBoardControllerCreateLine(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the media available line for the board.
     * @param {string} boardId The id of the board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApi
     */
    public mediaBoardControllerGetMediaAvailableLine(boardId: string, options?: any) {
        return MediaBoardApiFp(this.configuration).mediaBoardControllerGetMediaAvailableLine(boardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the media shelf of the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApi
     */
    public mediaBoardControllerGetMediaBoardForUser(options?: any) {
        return MediaBoardApiFp(this.configuration).mediaBoardControllerGetMediaBoardForUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set layout for media board.
     * @param {string} boardId The id of the board.
     * @param {LayoutBodyParams} layoutBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApi
     */
    public mediaBoardControllerSetMediaBoardLayout(boardId: string, layoutBodyParams: LayoutBodyParams, options?: any) {
        return MediaBoardApiFp(this.configuration).mediaBoardControllerSetMediaBoardLayout(boardId, layoutBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the color of available line in media board.
     * @param {string} boardId The id of the board.
     * @param {ColorBodyParams} colorBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaBoardApi
     */
    public mediaBoardControllerUpdateMediaAvailableLineColor(boardId: string, colorBodyParams: ColorBodyParams, options?: any) {
        return MediaBoardApiFp(this.configuration).mediaBoardControllerUpdateMediaAvailableLineColor(boardId, colorBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaElementApi - axios parameter creator
 * @export
 */
export const MediaElementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new element.
         * @param {CreateMediaElementBodyParams} createMediaElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaElementControllerCreateElement: async (createMediaElementBodyParams: CreateMediaElementBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMediaElementBodyParams' is not null or undefined
            assertParamExists('mediaElementControllerCreateElement', 'createMediaElementBodyParams', createMediaElementBodyParams)
            const localVarPath = `/media-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMediaElementBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single element.
         * @param {string} elementId The id of the element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaElementControllerDeleteElement: async (elementId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('mediaElementControllerDeleteElement', 'elementId', elementId)
            const localVarPath = `/media-elements/{elementId}`
                .replace(`{${"elementId"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a single element.
         * @param {string} elementId The id of the element
         * @param {MoveElementBodyParams} moveElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaElementControllerMoveElement: async (elementId: string, moveElementBodyParams: MoveElementBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'elementId' is not null or undefined
            assertParamExists('mediaElementControllerMoveElement', 'elementId', elementId)
            // verify required parameter 'moveElementBodyParams' is not null or undefined
            assertParamExists('mediaElementControllerMoveElement', 'moveElementBodyParams', moveElementBodyParams)
            const localVarPath = `/media-elements/{elementId}/position`
                .replace(`{${"elementId"}}`, encodeURIComponent(String(elementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveElementBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaElementApi - functional programming interface
 * @export
 */
export const MediaElementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaElementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new element.
         * @param {CreateMediaElementBodyParams} createMediaElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaElementControllerCreateElement(createMediaElementBodyParams: CreateMediaElementBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaExternalToolElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaElementControllerCreateElement(createMediaElementBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a single element.
         * @param {string} elementId The id of the element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaElementControllerDeleteElement(elementId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaElementControllerDeleteElement(elementId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move a single element.
         * @param {string} elementId The id of the element
         * @param {MoveElementBodyParams} moveElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaElementControllerMoveElement(elementId: string, moveElementBodyParams: MoveElementBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaElementControllerMoveElement(elementId, moveElementBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaElementApi - factory interface
 * @export
 */
export const MediaElementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaElementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new element.
         * @param {CreateMediaElementBodyParams} createMediaElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaElementControllerCreateElement(createMediaElementBodyParams: CreateMediaElementBodyParams, options?: any): AxiosPromise<MediaExternalToolElementResponse> {
            return localVarFp.mediaElementControllerCreateElement(createMediaElementBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single element.
         * @param {string} elementId The id of the element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaElementControllerDeleteElement(elementId: string, options?: any): AxiosPromise<void> {
            return localVarFp.mediaElementControllerDeleteElement(elementId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a single element.
         * @param {string} elementId The id of the element
         * @param {MoveElementBodyParams} moveElementBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaElementControllerMoveElement(elementId: string, moveElementBodyParams: MoveElementBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaElementControllerMoveElement(elementId, moveElementBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaElementApi - interface
 * @export
 * @interface MediaElementApi
 */
export interface MediaElementApiInterface {
    /**
     * 
     * @summary Create a new element.
     * @param {CreateMediaElementBodyParams} createMediaElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaElementApiInterface
     */
    mediaElementControllerCreateElement(createMediaElementBodyParams: CreateMediaElementBodyParams, options?: any): AxiosPromise<MediaExternalToolElementResponse>;

    /**
     * 
     * @summary Delete a single element.
     * @param {string} elementId The id of the element
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaElementApiInterface
     */
    mediaElementControllerDeleteElement(elementId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Move a single element.
     * @param {string} elementId The id of the element
     * @param {MoveElementBodyParams} moveElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaElementApiInterface
     */
    mediaElementControllerMoveElement(elementId: string, moveElementBodyParams: MoveElementBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * MediaElementApi - object-oriented interface
 * @export
 * @class MediaElementApi
 * @extends {BaseAPI}
 */
export class MediaElementApi extends BaseAPI implements MediaElementApiInterface {
    /**
     * 
     * @summary Create a new element.
     * @param {CreateMediaElementBodyParams} createMediaElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaElementApi
     */
    public mediaElementControllerCreateElement(createMediaElementBodyParams: CreateMediaElementBodyParams, options?: any) {
        return MediaElementApiFp(this.configuration).mediaElementControllerCreateElement(createMediaElementBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single element.
     * @param {string} elementId The id of the element
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaElementApi
     */
    public mediaElementControllerDeleteElement(elementId: string, options?: any) {
        return MediaElementApiFp(this.configuration).mediaElementControllerDeleteElement(elementId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a single element.
     * @param {string} elementId The id of the element
     * @param {MoveElementBodyParams} moveElementBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaElementApi
     */
    public mediaElementControllerMoveElement(elementId: string, moveElementBodyParams: MoveElementBodyParams, options?: any) {
        return MediaElementApiFp(this.configuration).mediaElementControllerMoveElement(elementId, moveElementBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaLineApi - axios parameter creator
 * @export
 */
export const MediaLineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Collapse available line in media board.
         * @param {string} lineId The id of the line
         * @param {CollapsableBodyParams} collapsableBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerCollapseMediaLine: async (lineId: string, collapsableBodyParams: CollapsableBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('mediaLineControllerCollapseMediaLine', 'lineId', lineId)
            // verify required parameter 'collapsableBodyParams' is not null or undefined
            assertParamExists('mediaLineControllerCollapseMediaLine', 'collapsableBodyParams', collapsableBodyParams)
            const localVarPath = `/media-lines/{lineId}/collapse`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(collapsableBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single line.
         * @param {string} lineId The id of the line
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerDeleteLine: async (lineId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('mediaLineControllerDeleteLine', 'lineId', lineId)
            const localVarPath = `/media-lines/{lineId}`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move a single line.
         * @param {string} lineId The id of the line
         * @param {MoveColumnBodyParams} moveColumnBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerMoveLine: async (lineId: string, moveColumnBodyParams: MoveColumnBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('mediaLineControllerMoveLine', 'lineId', lineId)
            // verify required parameter 'moveColumnBodyParams' is not null or undefined
            assertParamExists('mediaLineControllerMoveLine', 'moveColumnBodyParams', moveColumnBodyParams)
            const localVarPath = `/media-lines/{lineId}/position`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveColumnBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the color of a single line.
         * @param {string} lineId The id of the line
         * @param {ColorBodyParams} colorBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerUpdateBackgroundColor: async (lineId: string, colorBodyParams: ColorBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('mediaLineControllerUpdateBackgroundColor', 'lineId', lineId)
            // verify required parameter 'colorBodyParams' is not null or undefined
            assertParamExists('mediaLineControllerUpdateBackgroundColor', 'colorBodyParams', colorBodyParams)
            const localVarPath = `/media-lines/{lineId}/color`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(colorBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the title of a single line.
         * @param {string} lineId The id of the line
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerUpdateLineTitle: async (lineId: string, renameBodyParams: RenameBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('mediaLineControllerUpdateLineTitle', 'lineId', lineId)
            // verify required parameter 'renameBodyParams' is not null or undefined
            assertParamExists('mediaLineControllerUpdateLineTitle', 'renameBodyParams', renameBodyParams)
            const localVarPath = `/media-lines/{lineId}/title`
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaLineApi - functional programming interface
 * @export
 */
export const MediaLineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaLineApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Collapse available line in media board.
         * @param {string} lineId The id of the line
         * @param {CollapsableBodyParams} collapsableBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaLineControllerCollapseMediaLine(lineId: string, collapsableBodyParams: CollapsableBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaLineControllerCollapseMediaLine(lineId, collapsableBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a single line.
         * @param {string} lineId The id of the line
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaLineControllerDeleteLine(lineId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaLineControllerDeleteLine(lineId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Move a single line.
         * @param {string} lineId The id of the line
         * @param {MoveColumnBodyParams} moveColumnBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaLineControllerMoveLine(lineId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaLineControllerMoveLine(lineId, moveColumnBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the color of a single line.
         * @param {string} lineId The id of the line
         * @param {ColorBodyParams} colorBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaLineControllerUpdateBackgroundColor(lineId: string, colorBodyParams: ColorBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaLineControllerUpdateBackgroundColor(lineId, colorBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the title of a single line.
         * @param {string} lineId The id of the line
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaLineControllerUpdateLineTitle(lineId: string, renameBodyParams: RenameBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaLineControllerUpdateLineTitle(lineId, renameBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaLineApi - factory interface
 * @export
 */
export const MediaLineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaLineApiFp(configuration)
    return {
        /**
         * 
         * @summary Collapse available line in media board.
         * @param {string} lineId The id of the line
         * @param {CollapsableBodyParams} collapsableBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerCollapseMediaLine(lineId: string, collapsableBodyParams: CollapsableBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaLineControllerCollapseMediaLine(lineId, collapsableBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single line.
         * @param {string} lineId The id of the line
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerDeleteLine(lineId: string, options?: any): AxiosPromise<void> {
            return localVarFp.mediaLineControllerDeleteLine(lineId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move a single line.
         * @param {string} lineId The id of the line
         * @param {MoveColumnBodyParams} moveColumnBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerMoveLine(lineId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaLineControllerMoveLine(lineId, moveColumnBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the color of a single line.
         * @param {string} lineId The id of the line
         * @param {ColorBodyParams} colorBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerUpdateBackgroundColor(lineId: string, colorBodyParams: ColorBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaLineControllerUpdateBackgroundColor(lineId, colorBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the title of a single line.
         * @param {string} lineId The id of the line
         * @param {RenameBodyParams} renameBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaLineControllerUpdateLineTitle(lineId: string, renameBodyParams: RenameBodyParams, options?: any): AxiosPromise<void> {
            return localVarFp.mediaLineControllerUpdateLineTitle(lineId, renameBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaLineApi - interface
 * @export
 * @interface MediaLineApi
 */
export interface MediaLineApiInterface {
    /**
     * 
     * @summary Collapse available line in media board.
     * @param {string} lineId The id of the line
     * @param {CollapsableBodyParams} collapsableBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApiInterface
     */
    mediaLineControllerCollapseMediaLine(lineId: string, collapsableBodyParams: CollapsableBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a single line.
     * @param {string} lineId The id of the line
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApiInterface
     */
    mediaLineControllerDeleteLine(lineId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Move a single line.
     * @param {string} lineId The id of the line
     * @param {MoveColumnBodyParams} moveColumnBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApiInterface
     */
    mediaLineControllerMoveLine(lineId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the color of a single line.
     * @param {string} lineId The id of the line
     * @param {ColorBodyParams} colorBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApiInterface
     */
    mediaLineControllerUpdateBackgroundColor(lineId: string, colorBodyParams: ColorBodyParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Update the title of a single line.
     * @param {string} lineId The id of the line
     * @param {RenameBodyParams} renameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApiInterface
     */
    mediaLineControllerUpdateLineTitle(lineId: string, renameBodyParams: RenameBodyParams, options?: any): AxiosPromise<void>;

}

/**
 * MediaLineApi - object-oriented interface
 * @export
 * @class MediaLineApi
 * @extends {BaseAPI}
 */
export class MediaLineApi extends BaseAPI implements MediaLineApiInterface {
    /**
     * 
     * @summary Collapse available line in media board.
     * @param {string} lineId The id of the line
     * @param {CollapsableBodyParams} collapsableBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApi
     */
    public mediaLineControllerCollapseMediaLine(lineId: string, collapsableBodyParams: CollapsableBodyParams, options?: any) {
        return MediaLineApiFp(this.configuration).mediaLineControllerCollapseMediaLine(lineId, collapsableBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single line.
     * @param {string} lineId The id of the line
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApi
     */
    public mediaLineControllerDeleteLine(lineId: string, options?: any) {
        return MediaLineApiFp(this.configuration).mediaLineControllerDeleteLine(lineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move a single line.
     * @param {string} lineId The id of the line
     * @param {MoveColumnBodyParams} moveColumnBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApi
     */
    public mediaLineControllerMoveLine(lineId: string, moveColumnBodyParams: MoveColumnBodyParams, options?: any) {
        return MediaLineApiFp(this.configuration).mediaLineControllerMoveLine(lineId, moveColumnBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the color of a single line.
     * @param {string} lineId The id of the line
     * @param {ColorBodyParams} colorBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApi
     */
    public mediaLineControllerUpdateBackgroundColor(lineId: string, colorBodyParams: ColorBodyParams, options?: any) {
        return MediaLineApiFp(this.configuration).mediaLineControllerUpdateBackgroundColor(lineId, colorBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the title of a single line.
     * @param {string} lineId The id of the line
     * @param {RenameBodyParams} renameBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaLineApi
     */
    public mediaLineControllerUpdateLineTitle(lineId: string, renameBodyParams: RenameBodyParams, options?: any) {
        return MediaLineApiFp(this.configuration).mediaLineControllerUpdateLineTitle(lineId, renameBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetaTagExtractorApi - axios parameter creator
 * @export
 */
export const MetaTagExtractorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary return extract meta tags
         * @param {GetMetaTagDataBody} getMetaTagDataBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaTagExtractorControllerGetMetaTags: async (getMetaTagDataBody: GetMetaTagDataBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getMetaTagDataBody' is not null or undefined
            assertParamExists('metaTagExtractorControllerGetMetaTags', 'getMetaTagDataBody', getMetaTagDataBody)
            const localVarPath = `/meta-tag-extractor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetaTagDataBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaTagExtractorApi - functional programming interface
 * @export
 */
export const MetaTagExtractorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaTagExtractorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary return extract meta tags
         * @param {GetMetaTagDataBody} getMetaTagDataBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaTagExtractorControllerGetMetaTags(getMetaTagDataBody: GetMetaTagDataBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetaTagExtractorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaTagExtractorControllerGetMetaTags(getMetaTagDataBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetaTagExtractorApi - factory interface
 * @export
 */
export const MetaTagExtractorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaTagExtractorApiFp(configuration)
    return {
        /**
         * 
         * @summary return extract meta tags
         * @param {GetMetaTagDataBody} getMetaTagDataBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaTagExtractorControllerGetMetaTags(getMetaTagDataBody: GetMetaTagDataBody, options?: any): AxiosPromise<MetaTagExtractorResponse> {
            return localVarFp.metaTagExtractorControllerGetMetaTags(getMetaTagDataBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaTagExtractorApi - interface
 * @export
 * @interface MetaTagExtractorApi
 */
export interface MetaTagExtractorApiInterface {
    /**
     * 
     * @summary return extract meta tags
     * @param {GetMetaTagDataBody} getMetaTagDataBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaTagExtractorApiInterface
     */
    metaTagExtractorControllerGetMetaTags(getMetaTagDataBody: GetMetaTagDataBody, options?: any): AxiosPromise<MetaTagExtractorResponse>;

}

/**
 * MetaTagExtractorApi - object-oriented interface
 * @export
 * @class MetaTagExtractorApi
 * @extends {BaseAPI}
 */
export class MetaTagExtractorApi extends BaseAPI implements MetaTagExtractorApiInterface {
    /**
     * 
     * @summary return extract meta tags
     * @param {GetMetaTagDataBody} getMetaTagDataBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaTagExtractorApi
     */
    public metaTagExtractorControllerGetMetaTags(getMetaTagDataBody: GetMetaTagDataBody, options?: any) {
        return MetaTagExtractorApiFp(this.configuration).metaTagExtractorControllerGetMetaTags(getMetaTagDataBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NewsApi - axios parameter creator
 * @export
 */
export const NewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a news by a user in a given scope (school or team).
         * @param {CreateNewsParams} createNewsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerCreate: async (createNewsParams: CreateNewsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createNewsParams' is not null or undefined
            assertParamExists('newsControllerCreate', 'createNewsParams', createNewsParams)
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createNewsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a news.
         * @param {string} newsId The id of the news.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerDelete: async (newsId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newsId' is not null or undefined
            assertParamExists('newsControllerDelete', 'newsId', newsId)
            const localVarPath = `/news/{newsId}`
                .replace(`{${"newsId"}}`, encodeURIComponent(String(newsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Responds with all news for a user.
         * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
         * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
         * @param {boolean} [unpublished] Flag that filters if the news should be published or not
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerFindAll: async (targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/news`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (targetModel !== undefined) {
                localVarQueryParameter['targetModel'] = targetModel;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (unpublished !== undefined) {
                localVarQueryParameter['unpublished'] = unpublished;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
         * @param {string} newsId The id of the news.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerFindOne: async (newsId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newsId' is not null or undefined
            assertParamExists('newsControllerFindOne', 'newsId', newsId)
            const localVarPath = `/news/{newsId}`
                .replace(`{${"newsId"}}`, encodeURIComponent(String(newsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update properties of a news.
         * @param {string} newsId The id of the news.
         * @param {UpdateNewsParams} updateNewsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerUpdate: async (newsId: string, updateNewsParams: UpdateNewsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'newsId' is not null or undefined
            assertParamExists('newsControllerUpdate', 'newsId', newsId)
            // verify required parameter 'updateNewsParams' is not null or undefined
            assertParamExists('newsControllerUpdate', 'updateNewsParams', updateNewsParams)
            const localVarPath = `/news/{newsId}`
                .replace(`{${"newsId"}}`, encodeURIComponent(String(newsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNewsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Responds with news of a given team for a user.
         * @param {string} teamId The id of the team.
         * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
         * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
         * @param {boolean} [unpublished] Flag that filters if the news should be published or not
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamNewsControllerFindAllForTeam: async (teamId: string, targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamNewsControllerFindAllForTeam', 'teamId', teamId)
            const localVarPath = `/team/{teamId}/news`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (targetModel !== undefined) {
                localVarQueryParameter['targetModel'] = targetModel;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }

            if (unpublished !== undefined) {
                localVarQueryParameter['unpublished'] = unpublished;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NewsApi - functional programming interface
 * @export
 */
export const NewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a news by a user in a given scope (school or team).
         * @param {CreateNewsParams} createNewsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsControllerCreate(createNewsParams: CreateNewsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsControllerCreate(createNewsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a news.
         * @param {string} newsId The id of the news.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsControllerDelete(newsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsControllerDelete(newsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Responds with all news for a user.
         * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
         * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
         * @param {boolean} [unpublished] Flag that filters if the news should be published or not
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsControllerFindAll(targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsControllerFindAll(targetModel, targetId, unpublished, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
         * @param {string} newsId The id of the news.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsControllerFindOne(newsId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsControllerFindOne(newsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update properties of a news.
         * @param {string} newsId The id of the news.
         * @param {UpdateNewsParams} updateNewsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsControllerUpdate(newsId: string, updateNewsParams: UpdateNewsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsControllerUpdate(newsId, updateNewsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Responds with news of a given team for a user.
         * @param {string} teamId The id of the team.
         * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
         * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
         * @param {boolean} [unpublished] Flag that filters if the news should be published or not
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamNewsControllerFindAllForTeam(teamId: string, targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamNewsControllerFindAllForTeam(teamId, targetModel, targetId, unpublished, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NewsApi - factory interface
 * @export
 */
export const NewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NewsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a news by a user in a given scope (school or team).
         * @param {CreateNewsParams} createNewsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerCreate(createNewsParams: CreateNewsParams, options?: any): AxiosPromise<NewsResponse> {
            return localVarFp.newsControllerCreate(createNewsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a news.
         * @param {string} newsId The id of the news.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerDelete(newsId: string, options?: any): AxiosPromise<string> {
            return localVarFp.newsControllerDelete(newsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Responds with all news for a user.
         * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
         * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
         * @param {boolean} [unpublished] Flag that filters if the news should be published or not
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerFindAll(targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any): AxiosPromise<NewsListResponse> {
            return localVarFp.newsControllerFindAll(targetModel, targetId, unpublished, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
         * @param {string} newsId The id of the news.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerFindOne(newsId: string, options?: any): AxiosPromise<NewsResponse> {
            return localVarFp.newsControllerFindOne(newsId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update properties of a news.
         * @param {string} newsId The id of the news.
         * @param {UpdateNewsParams} updateNewsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsControllerUpdate(newsId: string, updateNewsParams: UpdateNewsParams, options?: any): AxiosPromise<NewsResponse> {
            return localVarFp.newsControllerUpdate(newsId, updateNewsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Responds with news of a given team for a user.
         * @param {string} teamId The id of the team.
         * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
         * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
         * @param {boolean} [unpublished] Flag that filters if the news should be published or not
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamNewsControllerFindAllForTeam(teamId: string, targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any): AxiosPromise<NewsListResponse> {
            return localVarFp.teamNewsControllerFindAllForTeam(teamId, targetModel, targetId, unpublished, skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NewsApi - interface
 * @export
 * @interface NewsApi
 */
export interface NewsApiInterface {
    /**
     * 
     * @summary Create a news by a user in a given scope (school or team).
     * @param {CreateNewsParams} createNewsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApiInterface
     */
    newsControllerCreate(createNewsParams: CreateNewsParams, options?: any): AxiosPromise<NewsResponse>;

    /**
     * 
     * @summary Delete a news.
     * @param {string} newsId The id of the news.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApiInterface
     */
    newsControllerDelete(newsId: string, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Responds with all news for a user.
     * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
     * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
     * @param {boolean} [unpublished] Flag that filters if the news should be published or not
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApiInterface
     */
    newsControllerFindAll(targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any): AxiosPromise<NewsListResponse>;

    /**
     * 
     * @summary Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
     * @param {string} newsId The id of the news.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApiInterface
     */
    newsControllerFindOne(newsId: string, options?: any): AxiosPromise<NewsResponse>;

    /**
     * 
     * @summary Update properties of a news.
     * @param {string} newsId The id of the news.
     * @param {UpdateNewsParams} updateNewsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApiInterface
     */
    newsControllerUpdate(newsId: string, updateNewsParams: UpdateNewsParams, options?: any): AxiosPromise<NewsResponse>;

    /**
     * 
     * @summary Responds with news of a given team for a user.
     * @param {string} teamId The id of the team.
     * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
     * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
     * @param {boolean} [unpublished] Flag that filters if the news should be published or not
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApiInterface
     */
    teamNewsControllerFindAllForTeam(teamId: string, targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any): AxiosPromise<NewsListResponse>;

}

/**
 * NewsApi - object-oriented interface
 * @export
 * @class NewsApi
 * @extends {BaseAPI}
 */
export class NewsApi extends BaseAPI implements NewsApiInterface {
    /**
     * 
     * @summary Create a news by a user in a given scope (school or team).
     * @param {CreateNewsParams} createNewsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsControllerCreate(createNewsParams: CreateNewsParams, options?: any) {
        return NewsApiFp(this.configuration).newsControllerCreate(createNewsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a news.
     * @param {string} newsId The id of the news.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsControllerDelete(newsId: string, options?: any) {
        return NewsApiFp(this.configuration).newsControllerDelete(newsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Responds with all news for a user.
     * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
     * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
     * @param {boolean} [unpublished] Flag that filters if the news should be published or not
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsControllerFindAll(targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any) {
        return NewsApiFp(this.configuration).newsControllerFindAll(targetModel, targetId, unpublished, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a specific news entry by id. A user may only read news of scopes he has the read permission. The news entity has school and user names populated.
     * @param {string} newsId The id of the news.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsControllerFindOne(newsId: string, options?: any) {
        return NewsApiFp(this.configuration).newsControllerFindOne(newsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update properties of a news.
     * @param {string} newsId The id of the news.
     * @param {UpdateNewsParams} updateNewsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public newsControllerUpdate(newsId: string, updateNewsParams: UpdateNewsParams, options?: any) {
        return NewsApiFp(this.configuration).newsControllerUpdate(newsId, updateNewsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Responds with news of a given team for a user.
     * @param {string} teamId The id of the team.
     * @param {'schools' | 'courses' | 'teams'} [targetModel] Target model to which the news are related
     * @param {string} [targetId] Specific target id to which the news are related (works only together with targetModel)
     * @param {boolean} [unpublished] Flag that filters if the news should be published or not
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public teamNewsControllerFindAllForTeam(teamId: string, targetModel?: 'schools' | 'courses' | 'teams', targetId?: string, unpublished?: boolean, skip?: number, limit?: number, options?: any) {
        return NewsApiFp(this.configuration).teamNewsControllerFindAllForTeam(teamId, targetModel, targetId, unpublished, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * Oauth2Api - axios parameter creator
 * @export
 */
export const Oauth2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerAcceptLogoutRequest: async (challenge: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'challenge' is not null or undefined
            assertParamExists('oauthProviderControllerAcceptLogoutRequest', 'challenge', challenge)
            const localVarPath = `/oauth2/logoutRequest/{challenge}`
                .replace(`{${"challenge"}}`, encodeURIComponent(String(challenge)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OauthClientCreateBody} oauthClientCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerCreateOAuth2Client: async (oauthClientCreateBody: OauthClientCreateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauthClientCreateBody' is not null or undefined
            assertParamExists('oauthProviderControllerCreateOAuth2Client', 'oauthClientCreateBody', oauthClientCreateBody)
            const localVarPath = `/oauth2/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauthClientCreateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerDeleteOAuth2Client: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('oauthProviderControllerDeleteOAuth2Client', 'id', id)
            const localVarPath = `/oauth2/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerGetConsentRequest: async (challenge: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'challenge' is not null or undefined
            assertParamExists('oauthProviderControllerGetConsentRequest', 'challenge', challenge)
            const localVarPath = `/oauth2/consentRequest/{challenge}`
                .replace(`{${"challenge"}}`, encodeURIComponent(String(challenge)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerGetLoginRequest: async (challenge: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'challenge' is not null or undefined
            assertParamExists('oauthProviderControllerGetLoginRequest', 'challenge', challenge)
            const localVarPath = `/oauth2/loginRequest/{challenge}`
                .replace(`{${"challenge"}}`, encodeURIComponent(String(challenge)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerGetOAuth2Client: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('oauthProviderControllerGetOAuth2Client', 'id', id)
            const localVarPath = `/oauth2/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerListConsentSessions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/auth/sessions/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
         * @param {number} offset The offset from where to start looking.
         * @param {string} clientName The name of the clients to filter by.
         * @param {string} owner The owner of the clients to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerListOAuth2Clients: async (limit: number, offset: number, clientName: string, owner: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('oauthProviderControllerListOAuth2Clients', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('oauthProviderControllerListOAuth2Clients', 'offset', offset)
            // verify required parameter 'clientName' is not null or undefined
            assertParamExists('oauthProviderControllerListOAuth2Clients', 'clientName', clientName)
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('oauthProviderControllerListOAuth2Clients', 'owner', owner)
            const localVarPath = `/oauth2/clients`
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)))
                .replace(`{${"client_name"}}`, encodeURIComponent(String(clientName)))
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {ConsentRequestBody} consentRequestBody 
         * @param {boolean} [accept] Accepts the login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerPatchConsentRequest: async (challenge: string, consentRequestBody: ConsentRequestBody, accept?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'challenge' is not null or undefined
            assertParamExists('oauthProviderControllerPatchConsentRequest', 'challenge', challenge)
            // verify required parameter 'consentRequestBody' is not null or undefined
            assertParamExists('oauthProviderControllerPatchConsentRequest', 'consentRequestBody', consentRequestBody)
            const localVarPath = `/oauth2/consentRequest/{challenge}`
                .replace(`{${"challenge"}}`, encodeURIComponent(String(challenge)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(consentRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {LoginRequestBody} loginRequestBody 
         * @param {boolean} [accept] Accepts the login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerPatchLoginRequest: async (challenge: string, loginRequestBody: LoginRequestBody, accept?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'challenge' is not null or undefined
            assertParamExists('oauthProviderControllerPatchLoginRequest', 'challenge', challenge)
            // verify required parameter 'loginRequestBody' is not null or undefined
            assertParamExists('oauthProviderControllerPatchLoginRequest', 'loginRequestBody', loginRequestBody)
            const localVarPath = `/oauth2/loginRequest/{challenge}`
                .replace(`{${"challenge"}}`, encodeURIComponent(String(challenge)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accept !== undefined) {
                localVarQueryParameter['accept'] = accept;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} client The Oauth2 client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerRevokeConsentSession: async (client: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('oauthProviderControllerRevokeConsentSession', 'client', client)
            const localVarPath = `/oauth2/auth/sessions/consent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {OauthClientUpdateBody} oauthClientUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerUpdateOAuth2Client: async (id: string, oauthClientUpdateBody: OauthClientUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('oauthProviderControllerUpdateOAuth2Client', 'id', id)
            // verify required parameter 'oauthClientUpdateBody' is not null or undefined
            assertParamExists('oauthProviderControllerUpdateOAuth2Client', 'oauthClientUpdateBody', oauthClientUpdateBody)
            const localVarPath = `/oauth2/clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauthClientUpdateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Oauth2Api - functional programming interface
 * @export
 */
export const Oauth2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Oauth2ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerAcceptLogoutRequest(challenge: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerAcceptLogoutRequest(challenge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {OauthClientCreateBody} oauthClientCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody: OauthClientCreateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerDeleteOAuth2Client(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerDeleteOAuth2Client(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerGetConsentRequest(challenge: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerGetConsentRequest(challenge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerGetLoginRequest(challenge: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthProviderLoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerGetLoginRequest(challenge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerGetOAuth2Client(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerGetOAuth2Client(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerListConsentSessions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConsentSessionResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerListConsentSessions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
         * @param {number} offset The offset from where to start looking.
         * @param {string} clientName The name of the clients to filter by.
         * @param {string} owner The owner of the clients to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerListOAuth2Clients(limit: number, offset: number, clientName: string, owner: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OauthClientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerListOAuth2Clients(limit, offset, clientName, owner, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {ConsentRequestBody} consentRequestBody 
         * @param {boolean} [accept] Accepts the login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerPatchConsentRequest(challenge: string, consentRequestBody: ConsentRequestBody, accept?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerPatchConsentRequest(challenge, consentRequestBody, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {LoginRequestBody} loginRequestBody 
         * @param {boolean} [accept] Accepts the login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerPatchLoginRequest(challenge: string, loginRequestBody: LoginRequestBody, accept?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerPatchLoginRequest(challenge, loginRequestBody, accept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} client The Oauth2 client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerRevokeConsentSession(client: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerRevokeConsentSession(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {OauthClientUpdateBody} oauthClientUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProviderControllerUpdateOAuth2Client(id: string, oauthClientUpdateBody: OauthClientUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthClientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProviderControllerUpdateOAuth2Client(id, oauthClientUpdateBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Oauth2Api - factory interface
 * @export
 */
export const Oauth2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Oauth2ApiFp(configuration)
    return {
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerAcceptLogoutRequest(challenge: string, options?: any): AxiosPromise<RedirectResponse> {
            return localVarFp.oauthProviderControllerAcceptLogoutRequest(challenge, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OauthClientCreateBody} oauthClientCreateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody: OauthClientCreateBody, options?: any): AxiosPromise<OauthClientResponse> {
            return localVarFp.oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerDeleteOAuth2Client(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.oauthProviderControllerDeleteOAuth2Client(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerGetConsentRequest(challenge: string, options?: any): AxiosPromise<ConsentResponse> {
            return localVarFp.oauthProviderControllerGetConsentRequest(challenge, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerGetLoginRequest(challenge: string, options?: any): AxiosPromise<OauthProviderLoginResponse> {
            return localVarFp.oauthProviderControllerGetLoginRequest(challenge, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerGetOAuth2Client(id: string, options?: any): AxiosPromise<OauthClientResponse> {
            return localVarFp.oauthProviderControllerGetOAuth2Client(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerListConsentSessions(options?: any): AxiosPromise<Array<ConsentSessionResponse>> {
            return localVarFp.oauthProviderControllerListConsentSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
         * @param {number} offset The offset from where to start looking.
         * @param {string} clientName The name of the clients to filter by.
         * @param {string} owner The owner of the clients to filter by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerListOAuth2Clients(limit: number, offset: number, clientName: string, owner: string, options?: any): AxiosPromise<Array<OauthClientResponse>> {
            return localVarFp.oauthProviderControllerListOAuth2Clients(limit, offset, clientName, owner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {ConsentRequestBody} consentRequestBody 
         * @param {boolean} [accept] Accepts the login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerPatchConsentRequest(challenge: string, consentRequestBody: ConsentRequestBody, accept?: boolean, options?: any): AxiosPromise<RedirectResponse> {
            return localVarFp.oauthProviderControllerPatchConsentRequest(challenge, consentRequestBody, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} challenge The login challenge.
         * @param {LoginRequestBody} loginRequestBody 
         * @param {boolean} [accept] Accepts the login request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerPatchLoginRequest(challenge: string, loginRequestBody: LoginRequestBody, accept?: boolean, options?: any): AxiosPromise<RedirectResponse> {
            return localVarFp.oauthProviderControllerPatchLoginRequest(challenge, loginRequestBody, accept, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} client The Oauth2 client id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerRevokeConsentSession(client: string, options?: any): AxiosPromise<void> {
            return localVarFp.oauthProviderControllerRevokeConsentSession(client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The Oauth Client Id.
         * @param {OauthClientUpdateBody} oauthClientUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProviderControllerUpdateOAuth2Client(id: string, oauthClientUpdateBody: OauthClientUpdateBody, options?: any): AxiosPromise<OauthClientResponse> {
            return localVarFp.oauthProviderControllerUpdateOAuth2Client(id, oauthClientUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Oauth2Api - interface
 * @export
 * @interface Oauth2Api
 */
export interface Oauth2ApiInterface {
    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerAcceptLogoutRequest(challenge: string, options?: any): AxiosPromise<RedirectResponse>;

    /**
     * 
     * @param {OauthClientCreateBody} oauthClientCreateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody: OauthClientCreateBody, options?: any): AxiosPromise<OauthClientResponse>;

    /**
     * 
     * @param {string} id The Oauth Client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerDeleteOAuth2Client(id: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerGetConsentRequest(challenge: string, options?: any): AxiosPromise<ConsentResponse>;

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerGetLoginRequest(challenge: string, options?: any): AxiosPromise<OauthProviderLoginResponse>;

    /**
     * 
     * @param {string} id The Oauth Client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerGetOAuth2Client(id: string, options?: any): AxiosPromise<OauthClientResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerListConsentSessions(options?: any): AxiosPromise<Array<ConsentSessionResponse>>;

    /**
     * 
     * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
     * @param {number} offset The offset from where to start looking.
     * @param {string} clientName The name of the clients to filter by.
     * @param {string} owner The owner of the clients to filter by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerListOAuth2Clients(limit: number, offset: number, clientName: string, owner: string, options?: any): AxiosPromise<Array<OauthClientResponse>>;

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {ConsentRequestBody} consentRequestBody 
     * @param {boolean} [accept] Accepts the login request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerPatchConsentRequest(challenge: string, consentRequestBody: ConsentRequestBody, accept?: boolean, options?: any): AxiosPromise<RedirectResponse>;

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {LoginRequestBody} loginRequestBody 
     * @param {boolean} [accept] Accepts the login request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerPatchLoginRequest(challenge: string, loginRequestBody: LoginRequestBody, accept?: boolean, options?: any): AxiosPromise<RedirectResponse>;

    /**
     * 
     * @param {string} client The Oauth2 client id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerRevokeConsentSession(client: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} id The Oauth Client Id.
     * @param {OauthClientUpdateBody} oauthClientUpdateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2ApiInterface
     */
    oauthProviderControllerUpdateOAuth2Client(id: string, oauthClientUpdateBody: OauthClientUpdateBody, options?: any): AxiosPromise<OauthClientResponse>;

}

/**
 * Oauth2Api - object-oriented interface
 * @export
 * @class Oauth2Api
 * @extends {BaseAPI}
 */
export class Oauth2Api extends BaseAPI implements Oauth2ApiInterface {
    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerAcceptLogoutRequest(challenge: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerAcceptLogoutRequest(challenge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OauthClientCreateBody} oauthClientCreateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody: OauthClientCreateBody, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerCreateOAuth2Client(oauthClientCreateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The Oauth Client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerDeleteOAuth2Client(id: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerDeleteOAuth2Client(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerGetConsentRequest(challenge: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerGetConsentRequest(challenge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerGetLoginRequest(challenge: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerGetLoginRequest(challenge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The Oauth Client Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerGetOAuth2Client(id: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerGetOAuth2Client(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerListConsentSessions(options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerListConsentSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} limit The maximum amount of clients to returned, upper bound is 500 clients.
     * @param {number} offset The offset from where to start looking.
     * @param {string} clientName The name of the clients to filter by.
     * @param {string} owner The owner of the clients to filter by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerListOAuth2Clients(limit: number, offset: number, clientName: string, owner: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerListOAuth2Clients(limit, offset, clientName, owner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {ConsentRequestBody} consentRequestBody 
     * @param {boolean} [accept] Accepts the login request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerPatchConsentRequest(challenge: string, consentRequestBody: ConsentRequestBody, accept?: boolean, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerPatchConsentRequest(challenge, consentRequestBody, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} challenge The login challenge.
     * @param {LoginRequestBody} loginRequestBody 
     * @param {boolean} [accept] Accepts the login request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerPatchLoginRequest(challenge: string, loginRequestBody: LoginRequestBody, accept?: boolean, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerPatchLoginRequest(challenge, loginRequestBody, accept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} client The Oauth2 client id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerRevokeConsentSession(client: string, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerRevokeConsentSession(client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The Oauth Client Id.
     * @param {OauthClientUpdateBody} oauthClientUpdateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Oauth2Api
     */
    public oauthProviderControllerUpdateOAuth2Client(id: string, oauthClientUpdateBody: OauthClientUpdateBody, options?: any) {
        return Oauth2ApiFp(this.configuration).oauthProviderControllerUpdateOAuth2Client(id, oauthClientUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PseudonymApi - axios parameter creator
 * @export
 */
export const PseudonymApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the related user and tool information to a pseudonym
         * @param {string} pseudonym 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pseudonymControllerGetPseudonym: async (pseudonym: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pseudonym' is not null or undefined
            assertParamExists('pseudonymControllerGetPseudonym', 'pseudonym', pseudonym)
            const localVarPath = `/pseudonyms/{pseudonym}`
                .replace(`{${"pseudonym"}}`, encodeURIComponent(String(pseudonym)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PseudonymApi - functional programming interface
 * @export
 */
export const PseudonymApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PseudonymApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the related user and tool information to a pseudonym
         * @param {string} pseudonym 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pseudonymControllerGetPseudonym(pseudonym: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PseudonymResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pseudonymControllerGetPseudonym(pseudonym, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PseudonymApi - factory interface
 * @export
 */
export const PseudonymApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PseudonymApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the related user and tool information to a pseudonym
         * @param {string} pseudonym 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pseudonymControllerGetPseudonym(pseudonym: string, options?: any): AxiosPromise<PseudonymResponse> {
            return localVarFp.pseudonymControllerGetPseudonym(pseudonym, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PseudonymApi - interface
 * @export
 * @interface PseudonymApi
 */
export interface PseudonymApiInterface {
    /**
     * 
     * @summary Returns the related user and tool information to a pseudonym
     * @param {string} pseudonym 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PseudonymApiInterface
     */
    pseudonymControllerGetPseudonym(pseudonym: string, options?: any): AxiosPromise<PseudonymResponse>;

}

/**
 * PseudonymApi - object-oriented interface
 * @export
 * @class PseudonymApi
 * @extends {BaseAPI}
 */
export class PseudonymApi extends BaseAPI implements PseudonymApiInterface {
    /**
     * 
     * @summary Returns the related user and tool information to a pseudonym
     * @param {string} pseudonym 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PseudonymApi
     */
    public pseudonymControllerGetPseudonym(pseudonym: string, options?: any) {
        return PseudonymApiFp(this.configuration).pseudonymControllerGetPseudonym(pseudonym, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RoomApi - axios parameter creator
 * @export
 */
export const RoomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add members to a room
         * @param {string} roomId 
         * @param {AddRoomMembersBodyParams} addRoomMembersBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerAddMembers: async (roomId: string, addRoomMembersBodyParams: AddRoomMembersBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerAddMembers', 'roomId', roomId)
            // verify required parameter 'addRoomMembersBodyParams' is not null or undefined
            assertParamExists('roomControllerAddMembers', 'addRoomMembersBodyParams', addRoomMembersBodyParams)
            const localVarPath = `/rooms/{roomId}/members/add`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addRoomMembersBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change the roles that members have within the room
         * @param {string} roomId 
         * @param {ChangeRoomRoleBodyParams} changeRoomRoleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerChangeRolesOfMembers: async (roomId: string, changeRoomRoleBodyParams: ChangeRoomRoleBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerChangeRolesOfMembers', 'roomId', roomId)
            // verify required parameter 'changeRoomRoleBodyParams' is not null or undefined
            assertParamExists('roomControllerChangeRolesOfMembers', 'changeRoomRoleBodyParams', changeRoomRoleBodyParams)
            const localVarPath = `/rooms/{roomId}/members/roles`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeRoomRoleBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Passes the ownership of the room to another user. Can only be used if you are the owner, and you will loose the ownership and become a roomadmin instead.
         * @param {string} roomId 
         * @param {PassOwnershipBodyParams} passOwnershipBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerChangeRoomOwner: async (roomId: string, passOwnershipBodyParams: PassOwnershipBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerChangeRoomOwner', 'roomId', roomId)
            // verify required parameter 'passOwnershipBodyParams' is not null or undefined
            assertParamExists('roomControllerChangeRoomOwner', 'passOwnershipBodyParams', passOwnershipBodyParams)
            const localVarPath = `/rooms/{roomId}/members/pass-ownership`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passOwnershipBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomBodyParams} createRoomBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerCreateRoom: async (createRoomBodyParams: CreateRoomBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomBodyParams' is not null or undefined
            assertParamExists('roomControllerCreateRoom', 'createRoomBodyParams', createRoomBodyParams)
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerDeleteRoom: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerDeleteRoom', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of room members.
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetMembers: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerGetMembers', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}/members`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the boards of a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetRoomBoards: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerGetRoomBoards', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}/boards`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetRoomDetails: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerGetRoomDetails', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of rooms.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetRooms: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leaving a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerLeaveRoom: async (roomId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerLeaveRoom', 'roomId', roomId)
            const localVarPath = `/rooms/{roomId}/leave`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove members from a room
         * @param {string} roomId 
         * @param {RemoveRoomMembersBodyParams} removeRoomMembersBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerRemoveMembers: async (roomId: string, removeRoomMembersBodyParams: RemoveRoomMembersBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerRemoveMembers', 'roomId', roomId)
            // verify required parameter 'removeRoomMembersBodyParams' is not null or undefined
            assertParamExists('roomControllerRemoveMembers', 'removeRoomMembersBodyParams', removeRoomMembersBodyParams)
            const localVarPath = `/rooms/{roomId}/members/remove`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeRoomMembersBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing room
         * @param {string} roomId 
         * @param {UpdateRoomBodyParams} updateRoomBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerUpdateRoom: async (roomId: string, updateRoomBodyParams: UpdateRoomBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('roomControllerUpdateRoom', 'roomId', roomId)
            // verify required parameter 'updateRoomBodyParams' is not null or undefined
            assertParamExists('roomControllerUpdateRoom', 'updateRoomBodyParams', updateRoomBodyParams)
            const localVarPath = `/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoomBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomApi - functional programming interface
 * @export
 */
export const RoomApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add members to a room
         * @param {string} roomId 
         * @param {AddRoomMembersBodyParams} addRoomMembersBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerAddMembers(roomId: string, addRoomMembersBodyParams: AddRoomMembersBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomRoleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerAddMembers(roomId, addRoomMembersBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Change the roles that members have within the room
         * @param {string} roomId 
         * @param {ChangeRoomRoleBodyParams} changeRoomRoleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerChangeRolesOfMembers(roomId: string, changeRoomRoleBodyParams: ChangeRoomRoleBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerChangeRolesOfMembers(roomId, changeRoomRoleBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Passes the ownership of the room to another user. Can only be used if you are the owner, and you will loose the ownership and become a roomadmin instead.
         * @param {string} roomId 
         * @param {PassOwnershipBodyParams} passOwnershipBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerChangeRoomOwner(roomId: string, passOwnershipBodyParams: PassOwnershipBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerChangeRoomOwner(roomId, passOwnershipBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomBodyParams} createRoomBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerCreateRoom(createRoomBodyParams: CreateRoomBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerCreateRoom(createRoomBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerDeleteRoom(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerDeleteRoom(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of room members.
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerGetMembers(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomMemberListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerGetMembers(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the boards of a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerGetRoomBoards(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomBoardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerGetRoomBoards(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerGetRoomDetails(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerGetRoomDetails(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of rooms.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerGetRooms(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerGetRooms(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Leaving a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerLeaveRoom(roomId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerLeaveRoom(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove members from a room
         * @param {string} roomId 
         * @param {RemoveRoomMembersBodyParams} removeRoomMembersBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerRemoveMembers(roomId: string, removeRoomMembersBodyParams: RemoveRoomMembersBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerRemoveMembers(roomId, removeRoomMembersBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing room
         * @param {string} roomId 
         * @param {UpdateRoomBodyParams} updateRoomBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roomControllerUpdateRoom(roomId: string, updateRoomBodyParams: UpdateRoomBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roomControllerUpdateRoom(roomId, updateRoomBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoomApi - factory interface
 * @export
 */
export const RoomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomApiFp(configuration)
    return {
        /**
         * 
         * @summary Add members to a room
         * @param {string} roomId 
         * @param {AddRoomMembersBodyParams} addRoomMembersBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerAddMembers(roomId: string, addRoomMembersBodyParams: AddRoomMembersBodyParams, options?: any): AxiosPromise<RoomRoleResponse> {
            return localVarFp.roomControllerAddMembers(roomId, addRoomMembersBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change the roles that members have within the room
         * @param {string} roomId 
         * @param {ChangeRoomRoleBodyParams} changeRoomRoleBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerChangeRolesOfMembers(roomId: string, changeRoomRoleBodyParams: ChangeRoomRoleBodyParams, options?: any): AxiosPromise<string> {
            return localVarFp.roomControllerChangeRolesOfMembers(roomId, changeRoomRoleBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Passes the ownership of the room to another user. Can only be used if you are the owner, and you will loose the ownership and become a roomadmin instead.
         * @param {string} roomId 
         * @param {PassOwnershipBodyParams} passOwnershipBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerChangeRoomOwner(roomId: string, passOwnershipBodyParams: PassOwnershipBodyParams, options?: any): AxiosPromise<string> {
            return localVarFp.roomControllerChangeRoomOwner(roomId, passOwnershipBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomBodyParams} createRoomBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerCreateRoom(createRoomBodyParams: CreateRoomBodyParams, options?: any): AxiosPromise<RoomItemResponse> {
            return localVarFp.roomControllerCreateRoom(createRoomBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerDeleteRoom(roomId: string, options?: any): AxiosPromise<void> {
            return localVarFp.roomControllerDeleteRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of room members.
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetMembers(roomId: string, options?: any): AxiosPromise<RoomMemberListResponse> {
            return localVarFp.roomControllerGetMembers(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the boards of a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetRoomBoards(roomId: string, options?: any): AxiosPromise<RoomBoardListResponse> {
            return localVarFp.roomControllerGetRoomBoards(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetRoomDetails(roomId: string, options?: any): AxiosPromise<RoomDetailsResponse> {
            return localVarFp.roomControllerGetRoomDetails(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of rooms.
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerGetRooms(skip?: number, limit?: number, options?: any): AxiosPromise<RoomListResponse> {
            return localVarFp.roomControllerGetRooms(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leaving a room
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerLeaveRoom(roomId: string, options?: any): AxiosPromise<string> {
            return localVarFp.roomControllerLeaveRoom(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove members from a room
         * @param {string} roomId 
         * @param {RemoveRoomMembersBodyParams} removeRoomMembersBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerRemoveMembers(roomId: string, removeRoomMembersBodyParams: RemoveRoomMembersBodyParams, options?: any): AxiosPromise<string> {
            return localVarFp.roomControllerRemoveMembers(roomId, removeRoomMembersBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing room
         * @param {string} roomId 
         * @param {UpdateRoomBodyParams} updateRoomBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roomControllerUpdateRoom(roomId: string, updateRoomBodyParams: UpdateRoomBodyParams, options?: any): AxiosPromise<RoomDetailsResponse> {
            return localVarFp.roomControllerUpdateRoom(roomId, updateRoomBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomApi - interface
 * @export
 * @interface RoomApi
 */
export interface RoomApiInterface {
    /**
     * 
     * @summary Add members to a room
     * @param {string} roomId 
     * @param {AddRoomMembersBodyParams} addRoomMembersBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerAddMembers(roomId: string, addRoomMembersBodyParams: AddRoomMembersBodyParams, options?: any): AxiosPromise<RoomRoleResponse>;

    /**
     * 
     * @summary Change the roles that members have within the room
     * @param {string} roomId 
     * @param {ChangeRoomRoleBodyParams} changeRoomRoleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerChangeRolesOfMembers(roomId: string, changeRoomRoleBodyParams: ChangeRoomRoleBodyParams, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Passes the ownership of the room to another user. Can only be used if you are the owner, and you will loose the ownership and become a roomadmin instead.
     * @param {string} roomId 
     * @param {PassOwnershipBodyParams} passOwnershipBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerChangeRoomOwner(roomId: string, passOwnershipBodyParams: PassOwnershipBodyParams, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Create a new room
     * @param {CreateRoomBodyParams} createRoomBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerCreateRoom(createRoomBodyParams: CreateRoomBodyParams, options?: any): AxiosPromise<RoomItemResponse>;

    /**
     * 
     * @summary Delete a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerDeleteRoom(roomId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Get a list of room members.
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerGetMembers(roomId: string, options?: any): AxiosPromise<RoomMemberListResponse>;

    /**
     * 
     * @summary Get the boards of a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerGetRoomBoards(roomId: string, options?: any): AxiosPromise<RoomBoardListResponse>;

    /**
     * 
     * @summary Get the details of a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerGetRoomDetails(roomId: string, options?: any): AxiosPromise<RoomDetailsResponse>;

    /**
     * 
     * @summary Get a list of rooms.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerGetRooms(skip?: number, limit?: number, options?: any): AxiosPromise<RoomListResponse>;

    /**
     * 
     * @summary Leaving a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerLeaveRoom(roomId: string, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Remove members from a room
     * @param {string} roomId 
     * @param {RemoveRoomMembersBodyParams} removeRoomMembersBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerRemoveMembers(roomId: string, removeRoomMembersBodyParams: RemoveRoomMembersBodyParams, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Update an existing room
     * @param {string} roomId 
     * @param {UpdateRoomBodyParams} updateRoomBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApiInterface
     */
    roomControllerUpdateRoom(roomId: string, updateRoomBodyParams: UpdateRoomBodyParams, options?: any): AxiosPromise<RoomDetailsResponse>;

}

/**
 * RoomApi - object-oriented interface
 * @export
 * @class RoomApi
 * @extends {BaseAPI}
 */
export class RoomApi extends BaseAPI implements RoomApiInterface {
    /**
     * 
     * @summary Add members to a room
     * @param {string} roomId 
     * @param {AddRoomMembersBodyParams} addRoomMembersBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerAddMembers(roomId: string, addRoomMembersBodyParams: AddRoomMembersBodyParams, options?: any) {
        return RoomApiFp(this.configuration).roomControllerAddMembers(roomId, addRoomMembersBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change the roles that members have within the room
     * @param {string} roomId 
     * @param {ChangeRoomRoleBodyParams} changeRoomRoleBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerChangeRolesOfMembers(roomId: string, changeRoomRoleBodyParams: ChangeRoomRoleBodyParams, options?: any) {
        return RoomApiFp(this.configuration).roomControllerChangeRolesOfMembers(roomId, changeRoomRoleBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Passes the ownership of the room to another user. Can only be used if you are the owner, and you will loose the ownership and become a roomadmin instead.
     * @param {string} roomId 
     * @param {PassOwnershipBodyParams} passOwnershipBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerChangeRoomOwner(roomId: string, passOwnershipBodyParams: PassOwnershipBodyParams, options?: any) {
        return RoomApiFp(this.configuration).roomControllerChangeRoomOwner(roomId, passOwnershipBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new room
     * @param {CreateRoomBodyParams} createRoomBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerCreateRoom(createRoomBodyParams: CreateRoomBodyParams, options?: any) {
        return RoomApiFp(this.configuration).roomControllerCreateRoom(createRoomBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerDeleteRoom(roomId: string, options?: any) {
        return RoomApiFp(this.configuration).roomControllerDeleteRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of room members.
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerGetMembers(roomId: string, options?: any) {
        return RoomApiFp(this.configuration).roomControllerGetMembers(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the boards of a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerGetRoomBoards(roomId: string, options?: any) {
        return RoomApiFp(this.configuration).roomControllerGetRoomBoards(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerGetRoomDetails(roomId: string, options?: any) {
        return RoomApiFp(this.configuration).roomControllerGetRoomDetails(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of rooms.
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerGetRooms(skip?: number, limit?: number, options?: any) {
        return RoomApiFp(this.configuration).roomControllerGetRooms(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leaving a room
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerLeaveRoom(roomId: string, options?: any) {
        return RoomApiFp(this.configuration).roomControllerLeaveRoom(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove members from a room
     * @param {string} roomId 
     * @param {RemoveRoomMembersBodyParams} removeRoomMembersBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerRemoveMembers(roomId: string, removeRoomMembersBodyParams: RemoveRoomMembersBodyParams, options?: any) {
        return RoomApiFp(this.configuration).roomControllerRemoveMembers(roomId, removeRoomMembersBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing room
     * @param {string} roomId 
     * @param {UpdateRoomBodyParams} updateRoomBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomApi
     */
    public roomControllerUpdateRoom(roomId: string, updateRoomBodyParams: UpdateRoomBodyParams, options?: any) {
        return RoomApiFp(this.configuration).roomControllerUpdateRoom(roomId, updateRoomBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchoolApi - axios parameter creator
 * @export
 */
export const SchoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerDoesSchoolExist: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerDoesSchoolExist', 'schoolId', schoolId)
            const localVarPath = `/school/exists/id/{schoolId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all provisioning options for a system at a school
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetProvisioningOptions: async (schoolId: string, systemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerGetProvisioningOptions', 'schoolId', schoolId)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('schoolControllerGetProvisioningOptions', 'systemId', systemId)
            const localVarPath = `/schools/{schoolId}/systems/{systemId}/provisioning-options`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolById: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerGetSchoolById', 'schoolId', schoolId)
            const localVarPath = `/school/id/{schoolId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [federalStateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolListForExternalInvite: async (federalStateId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/school/list-for-external-invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (federalStateId !== undefined) {
                localVarQueryParameter['federalStateId'] = federalStateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolListForLadpLogin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/school/list-for-ldap-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get systems from school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolSystems: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerGetSchoolSystems', 'schoolId', schoolId)
            const localVarPath = `/school/{schoolId}/systems`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetTeachers: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerGetTeachers', 'schoolId', schoolId)
            const localVarPath = `/school/{schoolId}/teachers`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerRemoveSystemFromSchool: async (schoolId: string, systemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerRemoveSystemFromSchool', 'schoolId', schoolId)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('schoolControllerRemoveSystemFromSchool', 'systemId', systemId)
            const localVarPath = `/school/{schoolId}/system/{systemId}/remove`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets all provisioning options for a system at a school
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {SchulConneXProvisioningOptionsParams} schulConneXProvisioningOptionsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerSetProvisioningOptions: async (schoolId: string, systemId: string, schulConneXProvisioningOptionsParams: SchulConneXProvisioningOptionsParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerSetProvisioningOptions', 'schoolId', schoolId)
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('schoolControllerSetProvisioningOptions', 'systemId', systemId)
            // verify required parameter 'schulConneXProvisioningOptionsParams' is not null or undefined
            assertParamExists('schoolControllerSetProvisioningOptions', 'schulConneXProvisioningOptionsParams', schulConneXProvisioningOptionsParams)
            const localVarPath = `/schools/{schoolId}/systems/{systemId}/provisioning-options`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)))
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schulConneXProvisioningOptionsParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updating school props by school administrators
         * @param {string} schoolId 
         * @param {SchoolUpdateBodyParams} schoolUpdateBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerUpdateSchool: async (schoolId: string, schoolUpdateBodyParams: SchoolUpdateBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('schoolControllerUpdateSchool', 'schoolId', schoolId)
            // verify required parameter 'schoolUpdateBodyParams' is not null or undefined
            assertParamExists('schoolControllerUpdateSchool', 'schoolUpdateBodyParams', schoolUpdateBodyParams)
            const localVarPath = `/school/{schoolId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schoolUpdateBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolApi - functional programming interface
 * @export
 */
export const SchoolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerDoesSchoolExist(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerDoesSchoolExist(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all provisioning options for a system at a school
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerGetProvisioningOptions(schoolId: string, systemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchulConneXProvisioningOptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerGetProvisioningOptions(schoolId, systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerGetSchoolById(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerGetSchoolById(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [federalStateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerGetSchoolListForExternalInvite(federalStateId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchoolForExternalInviteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerGetSchoolListForExternalInvite(federalStateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerGetSchoolListForLadpLogin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchoolForLdapLoginResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerGetSchoolListForLadpLogin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get systems from school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerGetSchoolSystems(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchoolSystemResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerGetSchoolSystems(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerGetTeachers(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerGetTeachers(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerRemoveSystemFromSchool(schoolId: string, systemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerRemoveSystemFromSchool(schoolId, systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sets all provisioning options for a system at a school
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {SchulConneXProvisioningOptionsParams} schulConneXProvisioningOptionsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerSetProvisioningOptions(schoolId: string, systemId: string, schulConneXProvisioningOptionsParams: SchulConneXProvisioningOptionsParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchulConneXProvisioningOptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerSetProvisioningOptions(schoolId, systemId, schulConneXProvisioningOptionsParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updating school props by school administrators
         * @param {string} schoolId 
         * @param {SchoolUpdateBodyParams} schoolUpdateBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolControllerUpdateSchool(schoolId: string, schoolUpdateBodyParams: SchoolUpdateBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolControllerUpdateSchool(schoolId, schoolUpdateBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchoolApi - factory interface
 * @export
 */
export const SchoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolApiFp(configuration)
    return {
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerDoesSchoolExist(schoolId: string, options?: any): AxiosPromise<SchoolExistsResponse> {
            return localVarFp.schoolControllerDoesSchoolExist(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all provisioning options for a system at a school
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetProvisioningOptions(schoolId: string, systemId: string, options?: any): AxiosPromise<SchulConneXProvisioningOptionsResponse> {
            return localVarFp.schoolControllerGetProvisioningOptions(schoolId, systemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolById(schoolId: string, options?: any): AxiosPromise<SchoolResponse> {
            return localVarFp.schoolControllerGetSchoolById(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [federalStateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolListForExternalInvite(federalStateId?: string, options?: any): AxiosPromise<Array<SchoolForExternalInviteResponse>> {
            return localVarFp.schoolControllerGetSchoolListForExternalInvite(federalStateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolListForLadpLogin(options?: any): AxiosPromise<Array<SchoolForLdapLoginResponse>> {
            return localVarFp.schoolControllerGetSchoolListForLadpLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get systems from school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetSchoolSystems(schoolId: string, options?: any): AxiosPromise<Array<SchoolSystemResponse>> {
            return localVarFp.schoolControllerGetSchoolSystems(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerGetTeachers(schoolId: string, options?: any): AxiosPromise<SchoolUserListResponse> {
            return localVarFp.schoolControllerGetTeachers(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerRemoveSystemFromSchool(schoolId: string, systemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.schoolControllerRemoveSystemFromSchool(schoolId, systemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets all provisioning options for a system at a school
         * @param {string} schoolId 
         * @param {string} systemId 
         * @param {SchulConneXProvisioningOptionsParams} schulConneXProvisioningOptionsParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerSetProvisioningOptions(schoolId: string, systemId: string, schulConneXProvisioningOptionsParams: SchulConneXProvisioningOptionsParams, options?: any): AxiosPromise<SchulConneXProvisioningOptionsResponse> {
            return localVarFp.schoolControllerSetProvisioningOptions(schoolId, systemId, schulConneXProvisioningOptionsParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updating school props by school administrators
         * @param {string} schoolId 
         * @param {SchoolUpdateBodyParams} schoolUpdateBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolControllerUpdateSchool(schoolId: string, schoolUpdateBodyParams: SchoolUpdateBodyParams, options?: any): AxiosPromise<SchoolResponse> {
            return localVarFp.schoolControllerUpdateSchool(schoolId, schoolUpdateBodyParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolApi - interface
 * @export
 * @interface SchoolApi
 */
export interface SchoolApiInterface {
    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerDoesSchoolExist(schoolId: string, options?: any): AxiosPromise<SchoolExistsResponse>;

    /**
     * Gets all provisioning options for a system at a school
     * @param {string} schoolId 
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerGetProvisioningOptions(schoolId: string, systemId: string, options?: any): AxiosPromise<SchulConneXProvisioningOptionsResponse>;

    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerGetSchoolById(schoolId: string, options?: any): AxiosPromise<SchoolResponse>;

    /**
     * 
     * @param {string} [federalStateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerGetSchoolListForExternalInvite(federalStateId?: string, options?: any): AxiosPromise<Array<SchoolForExternalInviteResponse>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerGetSchoolListForLadpLogin(options?: any): AxiosPromise<Array<SchoolForLdapLoginResponse>>;

    /**
     * 
     * @summary Get systems from school
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerGetSchoolSystems(schoolId: string, options?: any): AxiosPromise<Array<SchoolSystemResponse>>;

    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerGetTeachers(schoolId: string, options?: any): AxiosPromise<SchoolUserListResponse>;

    /**
     * 
     * @param {string} schoolId 
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerRemoveSystemFromSchool(schoolId: string, systemId: string, options?: any): AxiosPromise<void>;

    /**
     * Sets all provisioning options for a system at a school
     * @param {string} schoolId 
     * @param {string} systemId 
     * @param {SchulConneXProvisioningOptionsParams} schulConneXProvisioningOptionsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerSetProvisioningOptions(schoolId: string, systemId: string, schulConneXProvisioningOptionsParams: SchulConneXProvisioningOptionsParams, options?: any): AxiosPromise<SchulConneXProvisioningOptionsResponse>;

    /**
     * 
     * @summary Updating school props by school administrators
     * @param {string} schoolId 
     * @param {SchoolUpdateBodyParams} schoolUpdateBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApiInterface
     */
    schoolControllerUpdateSchool(schoolId: string, schoolUpdateBodyParams: SchoolUpdateBodyParams, options?: any): AxiosPromise<SchoolResponse>;

}

/**
 * SchoolApi - object-oriented interface
 * @export
 * @class SchoolApi
 * @extends {BaseAPI}
 */
export class SchoolApi extends BaseAPI implements SchoolApiInterface {
    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerDoesSchoolExist(schoolId: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerDoesSchoolExist(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all provisioning options for a system at a school
     * @param {string} schoolId 
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerGetProvisioningOptions(schoolId: string, systemId: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerGetProvisioningOptions(schoolId, systemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerGetSchoolById(schoolId: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerGetSchoolById(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [federalStateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerGetSchoolListForExternalInvite(federalStateId?: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerGetSchoolListForExternalInvite(federalStateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerGetSchoolListForLadpLogin(options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerGetSchoolListForLadpLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get systems from school
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerGetSchoolSystems(schoolId: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerGetSchoolSystems(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerGetTeachers(schoolId: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerGetTeachers(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolId 
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerRemoveSystemFromSchool(schoolId: string, systemId: string, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerRemoveSystemFromSchool(schoolId, systemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets all provisioning options for a system at a school
     * @param {string} schoolId 
     * @param {string} systemId 
     * @param {SchulConneXProvisioningOptionsParams} schulConneXProvisioningOptionsParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerSetProvisioningOptions(schoolId: string, systemId: string, schulConneXProvisioningOptionsParams: SchulConneXProvisioningOptionsParams, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerSetProvisioningOptions(schoolId, systemId, schulConneXProvisioningOptionsParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updating school props by school administrators
     * @param {string} schoolId 
     * @param {SchoolUpdateBodyParams} schoolUpdateBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolApi
     */
    public schoolControllerUpdateSchool(schoolId: string, schoolUpdateBodyParams: SchoolUpdateBodyParams, options?: any) {
        return SchoolApiFp(this.configuration).schoolControllerUpdateSchool(schoolId, schoolUpdateBodyParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchoolLicenseApi - axios parameter creator
 * @export
 */
export const SchoolLicenseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all active media licenses for a school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolLicenseControllerGetMediaSchoolLicensesForSchool: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/school-licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update media school licenses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolLicenseControllerUpdateMediaSchoolLicenses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/school-licenses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchoolLicenseApi - functional programming interface
 * @export
 */
export const SchoolLicenseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchoolLicenseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all active media licenses for a school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolLicenseControllerGetMediaSchoolLicensesForSchool(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaSchoolLicenseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolLicenseControllerGetMediaSchoolLicensesForSchool(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update media school licenses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schoolLicenseControllerUpdateMediaSchoolLicenses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schoolLicenseControllerUpdateMediaSchoolLicenses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchoolLicenseApi - factory interface
 * @export
 */
export const SchoolLicenseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchoolLicenseApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all active media licenses for a school
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolLicenseControllerGetMediaSchoolLicensesForSchool(options?: any): AxiosPromise<MediaSchoolLicenseListResponse> {
            return localVarFp.schoolLicenseControllerGetMediaSchoolLicensesForSchool(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update media school licenses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schoolLicenseControllerUpdateMediaSchoolLicenses(options?: any): AxiosPromise<void> {
            return localVarFp.schoolLicenseControllerUpdateMediaSchoolLicenses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchoolLicenseApi - interface
 * @export
 * @interface SchoolLicenseApi
 */
export interface SchoolLicenseApiInterface {
    /**
     * 
     * @summary Get all active media licenses for a school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolLicenseApiInterface
     */
    schoolLicenseControllerGetMediaSchoolLicensesForSchool(options?: any): AxiosPromise<MediaSchoolLicenseListResponse>;

    /**
     * 
     * @summary Update media school licenses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolLicenseApiInterface
     */
    schoolLicenseControllerUpdateMediaSchoolLicenses(options?: any): AxiosPromise<void>;

}

/**
 * SchoolLicenseApi - object-oriented interface
 * @export
 * @class SchoolLicenseApi
 * @extends {BaseAPI}
 */
export class SchoolLicenseApi extends BaseAPI implements SchoolLicenseApiInterface {
    /**
     * 
     * @summary Get all active media licenses for a school
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolLicenseApi
     */
    public schoolLicenseControllerGetMediaSchoolLicensesForSchool(options?: any) {
        return SchoolLicenseApiFp(this.configuration).schoolLicenseControllerGetMediaSchoolLicensesForSchool(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update media school licenses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchoolLicenseApi
     */
    public schoolLicenseControllerUpdateMediaSchoolLicenses(options?: any) {
        return SchoolLicenseApiFp(this.configuration).schoolLicenseControllerUpdateMediaSchoolLicenses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Default route to test public access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetHello: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Default route to test public access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverControllerGetHello(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverControllerGetHello(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * 
         * @summary Default route to test public access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverControllerGetHello(options?: any): AxiosPromise<string> {
            return localVarFp.serverControllerGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - interface
 * @export
 * @interface ServerApi
 */
export interface ServerApiInterface {
    /**
     * 
     * @summary Default route to test public access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApiInterface
     */
    serverControllerGetHello(options?: any): AxiosPromise<string>;

}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI implements ServerApiInterface {
    /**
     * 
     * @summary Default route to test public access
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverControllerGetHello(options?: any) {
        return ServerApiFp(this.configuration).serverControllerGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerConfigApi - axios parameter creator
 * @export
 */
export const ServerConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Useable configuration for clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverConfigControllerPublicConfig: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/config/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerConfigApi - functional programming interface
 * @export
 */
export const ServerConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Useable configuration for clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverConfigControllerPublicConfig(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverConfigControllerPublicConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerConfigApi - factory interface
 * @export
 */
export const ServerConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Useable configuration for clients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverConfigControllerPublicConfig(options?: any): AxiosPromise<ConfigResponse> {
            return localVarFp.serverConfigControllerPublicConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerConfigApi - interface
 * @export
 * @interface ServerConfigApi
 */
export interface ServerConfigApiInterface {
    /**
     * 
     * @summary Useable configuration for clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerConfigApiInterface
     */
    serverConfigControllerPublicConfig(options?: any): AxiosPromise<ConfigResponse>;

}

/**
 * ServerConfigApi - object-oriented interface
 * @export
 * @class ServerConfigApi
 * @extends {BaseAPI}
 */
export class ServerConfigApi extends BaseAPI implements ServerConfigApiInterface {
    /**
     * 
     * @summary Useable configuration for clients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerConfigApi
     */
    public serverConfigControllerPublicConfig(options?: any) {
        return ServerConfigApiFp(this.configuration).serverConfigControllerPublicConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShareTokenApi - axios parameter creator
 * @export
 */
export const ShareTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a share token.
         * @param {ShareTokenBodyParams} shareTokenBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTokenControllerCreateShareToken: async (shareTokenBodyParams: ShareTokenBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shareTokenBodyParams' is not null or undefined
            assertParamExists('shareTokenControllerCreateShareToken', 'shareTokenBodyParams', shareTokenBodyParams)
            const localVarPath = `/sharetoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareTokenBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a share token payload.
         * @param {string} token The token that identifies the shared object
         * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTokenControllerImportShareToken: async (token: string, shareTokenImportBodyParams: ShareTokenImportBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('shareTokenControllerImportShareToken', 'token', token)
            // verify required parameter 'shareTokenImportBodyParams' is not null or undefined
            assertParamExists('shareTokenControllerImportShareToken', 'shareTokenImportBodyParams', shareTokenImportBodyParams)
            const localVarPath = `/sharetoken/{token}/import`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shareTokenImportBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Look up a share token.
         * @param {string} token The token that identifies the shared object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTokenControllerLookupShareToken: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('shareTokenControllerLookupShareToken', 'token', token)
            const localVarPath = `/sharetoken/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShareTokenApi - functional programming interface
 * @export
 */
export const ShareTokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShareTokenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a share token.
         * @param {ShareTokenBodyParams} shareTokenBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareTokenControllerCreateShareToken(shareTokenBodyParams: ShareTokenBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareTokenControllerCreateShareToken(shareTokenBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a share token payload.
         * @param {string} token The token that identifies the shared object
         * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareTokenControllerImportShareToken(token: string, shareTokenImportBodyParams: ShareTokenImportBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CopyApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareTokenControllerImportShareToken(token, shareTokenImportBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Look up a share token.
         * @param {string} token The token that identifies the shared object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shareTokenControllerLookupShareToken(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareTokenInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shareTokenControllerLookupShareToken(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShareTokenApi - factory interface
 * @export
 */
export const ShareTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShareTokenApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a share token.
         * @param {ShareTokenBodyParams} shareTokenBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTokenControllerCreateShareToken(shareTokenBodyParams: ShareTokenBodyParams, options?: any): AxiosPromise<ShareTokenResponse> {
            return localVarFp.shareTokenControllerCreateShareToken(shareTokenBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a share token payload.
         * @param {string} token The token that identifies the shared object
         * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTokenControllerImportShareToken(token: string, shareTokenImportBodyParams: ShareTokenImportBodyParams, options?: any): AxiosPromise<CopyApiResponse> {
            return localVarFp.shareTokenControllerImportShareToken(token, shareTokenImportBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Look up a share token.
         * @param {string} token The token that identifies the shared object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareTokenControllerLookupShareToken(token: string, options?: any): AxiosPromise<ShareTokenInfoResponse> {
            return localVarFp.shareTokenControllerLookupShareToken(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShareTokenApi - interface
 * @export
 * @interface ShareTokenApi
 */
export interface ShareTokenApiInterface {
    /**
     * 
     * @summary Create a share token.
     * @param {ShareTokenBodyParams} shareTokenBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareTokenApiInterface
     */
    shareTokenControllerCreateShareToken(shareTokenBodyParams: ShareTokenBodyParams, options?: any): AxiosPromise<ShareTokenResponse>;

    /**
     * 
     * @summary Import a share token payload.
     * @param {string} token The token that identifies the shared object
     * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareTokenApiInterface
     */
    shareTokenControllerImportShareToken(token: string, shareTokenImportBodyParams: ShareTokenImportBodyParams, options?: any): AxiosPromise<CopyApiResponse>;

    /**
     * 
     * @summary Look up a share token.
     * @param {string} token The token that identifies the shared object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareTokenApiInterface
     */
    shareTokenControllerLookupShareToken(token: string, options?: any): AxiosPromise<ShareTokenInfoResponse>;

}

/**
 * ShareTokenApi - object-oriented interface
 * @export
 * @class ShareTokenApi
 * @extends {BaseAPI}
 */
export class ShareTokenApi extends BaseAPI implements ShareTokenApiInterface {
    /**
     * 
     * @summary Create a share token.
     * @param {ShareTokenBodyParams} shareTokenBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareTokenApi
     */
    public shareTokenControllerCreateShareToken(shareTokenBodyParams: ShareTokenBodyParams, options?: any) {
        return ShareTokenApiFp(this.configuration).shareTokenControllerCreateShareToken(shareTokenBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a share token payload.
     * @param {string} token The token that identifies the shared object
     * @param {ShareTokenImportBodyParams} shareTokenImportBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareTokenApi
     */
    public shareTokenControllerImportShareToken(token: string, shareTokenImportBodyParams: ShareTokenImportBodyParams, options?: any) {
        return ShareTokenApiFp(this.configuration).shareTokenControllerImportShareToken(token, shareTokenImportBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Look up a share token.
     * @param {string} token The token that identifies the shared object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShareTokenApi
     */
    public shareTokenControllerLookupShareToken(token: string, options?: any) {
        return ShareTokenApiFp(this.configuration).shareTokenControllerLookupShareToken(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShdApi - axios parameter creator
 * @export
 */
export const ShdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a support jwt for a user.
         * @param {TargetUserIdParams} targetUserIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shdControllerSupportJwt: async (targetUserIdParams: TargetUserIdParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'targetUserIdParams' is not null or undefined
            assertParamExists('shdControllerSupportJwt', 'targetUserIdParams', targetUserIdParams)
            const localVarPath = `/shd/supportJwt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetUserIdParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShdApi - functional programming interface
 * @export
 */
export const ShdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShdApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a support jwt for a user.
         * @param {TargetUserIdParams} targetUserIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shdControllerSupportJwt(targetUserIdParams: TargetUserIdParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shdControllerSupportJwt(targetUserIdParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShdApi - factory interface
 * @export
 */
export const ShdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShdApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a support jwt for a user.
         * @param {TargetUserIdParams} targetUserIdParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shdControllerSupportJwt(targetUserIdParams: TargetUserIdParams, options?: any): AxiosPromise<string> {
            return localVarFp.shdControllerSupportJwt(targetUserIdParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShdApi - interface
 * @export
 * @interface ShdApi
 */
export interface ShdApiInterface {
    /**
     * 
     * @summary Create a support jwt for a user.
     * @param {TargetUserIdParams} targetUserIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShdApiInterface
     */
    shdControllerSupportJwt(targetUserIdParams: TargetUserIdParams, options?: any): AxiosPromise<string>;

}

/**
 * ShdApi - object-oriented interface
 * @export
 * @class ShdApi
 * @extends {BaseAPI}
 */
export class ShdApi extends BaseAPI implements ShdApiInterface {
    /**
     * 
     * @summary Create a support jwt for a user.
     * @param {TargetUserIdParams} targetUserIdParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShdApi
     */
    public shdControllerSupportJwt(targetUserIdParams: TargetUserIdParams, options?: any) {
        return ShdApiFp(this.configuration).shdControllerSupportJwt(targetUserIdParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubmissionApi - axios parameter creator
 * @export
 */
export const SubmissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} submissionId The id of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionControllerDelete: async (submissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'submissionId' is not null or undefined
            assertParamExists('submissionControllerDelete', 'submissionId', submissionId)
            const localVarPath = `/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionControllerFindStatusesByTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('submissionControllerFindStatusesByTask', 'taskId', taskId)
            const localVarPath = `/submissions/status/task/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionApi - functional programming interface
 * @export
 */
export const SubmissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmissionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} submissionId The id of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionControllerDelete(submissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionControllerDelete(submissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionControllerFindStatusesByTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionStatusListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionControllerFindStatusesByTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubmissionApi - factory interface
 * @export
 */
export const SubmissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmissionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} submissionId The id of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionControllerDelete(submissionId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.submissionControllerDelete(submissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionControllerFindStatusesByTask(taskId: string, options?: any): AxiosPromise<SubmissionStatusListResponse> {
            return localVarFp.submissionControllerFindStatusesByTask(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmissionApi - interface
 * @export
 * @interface SubmissionApi
 */
export interface SubmissionApiInterface {
    /**
     * 
     * @param {string} submissionId The id of the submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApiInterface
     */
    submissionControllerDelete(submissionId: string, options?: any): AxiosPromise<boolean>;

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApiInterface
     */
    submissionControllerFindStatusesByTask(taskId: string, options?: any): AxiosPromise<SubmissionStatusListResponse>;

}

/**
 * SubmissionApi - object-oriented interface
 * @export
 * @class SubmissionApi
 * @extends {BaseAPI}
 */
export class SubmissionApi extends BaseAPI implements SubmissionApiInterface {
    /**
     * 
     * @param {string} submissionId The id of the submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public submissionControllerDelete(submissionId: string, options?: any) {
        return SubmissionApiFp(this.configuration).submissionControllerDelete(submissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionApi
     */
    public submissionControllerFindStatusesByTask(taskId: string, options?: any) {
        return SubmissionApiFp(this.configuration).submissionControllerFindStatusesByTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a system.
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemControllerDeleteSystem: async (systemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('systemControllerDeleteSystem', 'systemId', systemId)
            const localVarPath = `/systems/{systemId}`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds all publicly available systems.
         * @param {SystemType} [types] The type of the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemControllerFind: async (types?: SystemType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds a publicly available system.
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemControllerGetSystem: async (systemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('systemControllerGetSystem', 'systemId', systemId)
            const localVarPath = `/systems/public/{systemId}`
                .replace(`{${"systemId"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a system.
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemControllerDeleteSystem(systemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerDeleteSystem(systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finds all publicly available systems.
         * @param {SystemType} [types] The type of the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemControllerFind(types?: SystemType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicSystemListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerFind(types, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finds a publicly available system.
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemControllerGetSystem(systemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicSystemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemControllerGetSystem(systemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a system.
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemControllerDeleteSystem(systemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemControllerDeleteSystem(systemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds all publicly available systems.
         * @param {SystemType} [types] The type of the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemControllerFind(types?: SystemType, options?: any): AxiosPromise<PublicSystemListResponse> {
            return localVarFp.systemControllerFind(types, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finds a publicly available system.
         * @param {string} systemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemControllerGetSystem(systemId: string, options?: any): AxiosPromise<PublicSystemResponse> {
            return localVarFp.systemControllerGetSystem(systemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - interface
 * @export
 * @interface SystemsApi
 */
export interface SystemsApiInterface {
    /**
     * 
     * @summary Deletes a system.
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApiInterface
     */
    systemControllerDeleteSystem(systemId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Finds all publicly available systems.
     * @param {SystemType} [types] The type of the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApiInterface
     */
    systemControllerFind(types?: SystemType, options?: any): AxiosPromise<PublicSystemListResponse>;

    /**
     * 
     * @summary Finds a publicly available system.
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApiInterface
     */
    systemControllerGetSystem(systemId: string, options?: any): AxiosPromise<PublicSystemResponse>;

}

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI implements SystemsApiInterface {
    /**
     * 
     * @summary Deletes a system.
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systemControllerDeleteSystem(systemId: string, options?: any) {
        return SystemsApiFp(this.configuration).systemControllerDeleteSystem(systemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds all publicly available systems.
     * @param {SystemType} [types] The type of the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systemControllerFind(types?: SystemType, options?: any) {
        return SystemsApiFp(this.configuration).systemControllerFind(types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finds a publicly available system.
     * @param {string} systemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systemControllerGetSystem(systemId: string, options?: any) {
        return SystemsApiFp(this.configuration).systemControllerGetSystem(systemId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {TaskCopyApiParams} taskCopyApiParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerCopyTask: async (taskId: string, taskCopyApiParams: TaskCopyApiParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('taskControllerCopyTask', 'taskId', taskId)
            // verify required parameter 'taskCopyApiParams' is not null or undefined
            assertParamExists('taskControllerCopyTask', 'taskCopyApiParams', taskCopyApiParams)
            const localVarPath = `/tasks/{taskId}/copy`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskCopyApiParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerDelete: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('taskControllerDelete', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerFindAll: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerFindAllFinished: async (skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/finished`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerFinish: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('taskControllerFinish', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}/finish`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerRestore: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('taskControllerRestore', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}/restore`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerRevertPublished: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('taskControllerRevertPublished', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}/revertPublished`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {TaskCopyApiParams} taskCopyApiParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerCopyTask(taskId: string, taskCopyApiParams: TaskCopyApiParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CopyApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerCopyTask(taskId, taskCopyApiParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerDelete(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerDelete(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerFindAll(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerFindAll(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerFindAllFinished(skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerFindAllFinished(skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerFinish(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerFinish(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerRestore(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerRestore(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async taskControllerRevertPublished(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.taskControllerRevertPublished(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {TaskCopyApiParams} taskCopyApiParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerCopyTask(taskId: string, taskCopyApiParams: TaskCopyApiParams, options?: any): AxiosPromise<CopyApiResponse> {
            return localVarFp.taskControllerCopyTask(taskId, taskCopyApiParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerDelete(taskId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.taskControllerDelete(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerFindAll(skip?: number, limit?: number, options?: any): AxiosPromise<TaskListResponse> {
            return localVarFp.taskControllerFindAll(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerFindAllFinished(skip?: number, limit?: number, options?: any): AxiosPromise<TaskListResponse> {
            return localVarFp.taskControllerFindAllFinished(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerFinish(taskId: string, options?: any): AxiosPromise<TaskResponse> {
            return localVarFp.taskControllerFinish(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerRestore(taskId: string, options?: any): AxiosPromise<TaskResponse> {
            return localVarFp.taskControllerRestore(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId The id of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskControllerRevertPublished(taskId: string, options?: any): AxiosPromise<TaskResponse> {
            return localVarFp.taskControllerRevertPublished(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskApi - interface
 * @export
 * @interface TaskApi
 */
export interface TaskApiInterface {
    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {TaskCopyApiParams} taskCopyApiParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerCopyTask(taskId: string, taskCopyApiParams: TaskCopyApiParams, options?: any): AxiosPromise<CopyApiResponse>;

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerDelete(taskId: string, options?: any): AxiosPromise<boolean>;

    /**
     * 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerFindAll(skip?: number, limit?: number, options?: any): AxiosPromise<TaskListResponse>;

    /**
     * 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerFindAllFinished(skip?: number, limit?: number, options?: any): AxiosPromise<TaskListResponse>;

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerFinish(taskId: string, options?: any): AxiosPromise<TaskResponse>;

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerRestore(taskId: string, options?: any): AxiosPromise<TaskResponse>;

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApiInterface
     */
    taskControllerRevertPublished(taskId: string, options?: any): AxiosPromise<TaskResponse>;

}

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI implements TaskApiInterface {
    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {TaskCopyApiParams} taskCopyApiParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerCopyTask(taskId: string, taskCopyApiParams: TaskCopyApiParams, options?: any) {
        return TaskApiFp(this.configuration).taskControllerCopyTask(taskId, taskCopyApiParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerDelete(taskId: string, options?: any) {
        return TaskApiFp(this.configuration).taskControllerDelete(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerFindAll(skip?: number, limit?: number, options?: any) {
        return TaskApiFp(this.configuration).taskControllerFindAll(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerFindAllFinished(skip?: number, limit?: number, options?: any) {
        return TaskApiFp(this.configuration).taskControllerFindAllFinished(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerFinish(taskId: string, options?: any) {
        return TaskApiFp(this.configuration).taskControllerFinish(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerRestore(taskId: string, options?: any) {
        return TaskApiFp(this.configuration).taskControllerRestore(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId The id of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public taskControllerRevertPublished(taskId: string, options?: any) {
        return TaskApiFp(this.configuration).taskControllerRevertPublished(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ToolApi - axios parameter creator
 * @export
 */
export const ToolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all available tools that can be added for a given context
         * @param {any} contextType 
         * @param {string} contextId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetAvailableToolsForContext: async (contextType: any, contextId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextType' is not null or undefined
            assertParamExists('toolConfigurationControllerGetAvailableToolsForContext', 'contextType', contextType)
            // verify required parameter 'contextId' is not null or undefined
            assertParamExists('toolConfigurationControllerGetAvailableToolsForContext', 'contextId', contextId)
            const localVarPath = `/tools/{contextType}/{contextId}/available-tools`
                .replace(`{${"contextType"}}`, encodeURIComponent(String(contextType)))
                .replace(`{${"contextId"}}`, encodeURIComponent(String(contextId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all available tools that can be added for a given school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetAvailableToolsForSchool: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('toolConfigurationControllerGetAvailableToolsForSchool', 'schoolId', schoolId)
            const localVarPath = `/tools/school/{schoolId}/available-tools`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest configuration template for a Context External Tool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetConfigurationTemplateForContext: async (contextExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolConfigurationControllerGetConfigurationTemplateForContext', 'contextExternalToolId', contextExternalToolId)
            const localVarPath = `/tools/context-external-tools/{contextExternalToolId}/configuration-template`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the latest configuration template for a School External Tool
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetConfigurationTemplateForSchool: async (schoolExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolId' is not null or undefined
            assertParamExists('toolConfigurationControllerGetConfigurationTemplateForSchool', 'schoolExternalToolId', schoolExternalToolId)
            const localVarPath = `/tools/school-external-tools/{schoolExternalToolId}/configuration-template`
                .replace(`{${"schoolExternalToolId"}}`, encodeURIComponent(String(schoolExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all preferred tools that can be added for a given context
         * @param {ToolContextType} [contextType] Context types for tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetPreferredToolsForContext: async (contextType?: ToolContextType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools/preferred-tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contextType !== undefined) {
                localVarQueryParameter['contextType'] = contextType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all context types available in the SVS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetToolContextTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools/context-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a ContextExternalTool
         * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerCreateContextExternalTool: async (contextExternalToolPostParams: ContextExternalToolPostParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolPostParams' is not null or undefined
            assertParamExists('toolContextControllerCreateContextExternalTool', 'contextExternalToolPostParams', contextExternalToolPostParams)
            const localVarPath = `/tools/context-external-tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextExternalToolPostParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a ContextExternalTool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerDeleteContextExternalTool: async (contextExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolContextControllerDeleteContextExternalTool', 'contextExternalToolId', contextExternalToolId)
            const localVarPath = `/tools/context-external-tools/{contextExternalToolId}`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searches a ContextExternalTool for the given id
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerGetContextExternalTool: async (contextExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolContextControllerGetContextExternalTool', 'contextExternalToolId', contextExternalToolId)
            const localVarPath = `/tools/context-external-tools/{contextExternalToolId}`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of ContextExternalTools for the given context
         * @param {string} contextId 
         * @param {ToolContextType} contextType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerGetContextExternalToolsForContext: async (contextId: string, contextType: ToolContextType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextId' is not null or undefined
            assertParamExists('toolContextControllerGetContextExternalToolsForContext', 'contextId', contextId)
            // verify required parameter 'contextType' is not null or undefined
            assertParamExists('toolContextControllerGetContextExternalToolsForContext', 'contextType', contextType)
            const localVarPath = `/tools/context-external-tools/{contextType}/{contextId}`
                .replace(`{${"contextId"}}`, encodeURIComponent(String(contextId)))
                .replace(`{${"contextType"}}`, encodeURIComponent(String(contextType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a ContextExternalTool
         * @param {string} contextExternalToolId 
         * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerUpdateContextExternalTool: async (contextExternalToolId: string, contextExternalToolPostParams: ContextExternalToolPostParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolContextControllerUpdateContextExternalTool', 'contextExternalToolId', contextExternalToolId)
            // verify required parameter 'contextExternalToolPostParams' is not null or undefined
            assertParamExists('toolContextControllerUpdateContextExternalTool', 'contextExternalToolPostParams', contextExternalToolPostParams)
            const localVarPath = `/tools/context-external-tools/{contextExternalToolId}`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextExternalToolPostParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an ExternalTool
         * @param {ExternalToolCreateParams} externalToolCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerCreateExternalTool: async (externalToolCreateParams: ExternalToolCreateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolCreateParams' is not null or undefined
            assertParamExists('toolControllerCreateExternalTool', 'externalToolCreateParams', externalToolCreateParams)
            const localVarPath = `/tools/external-tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalToolCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an ExternalTool
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerDeleteExternalTool: async (externalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolId' is not null or undefined
            assertParamExists('toolControllerDeleteExternalTool', 'externalToolId', externalToolId)
            const localVarPath = `/tools/external-tools/{externalToolId}`
                .replace(`{${"externalToolId"}}`, encodeURIComponent(String(externalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of ExternalTools
         * @param {string} [name] Name of the external tool
         * @param {string} [clientId] OAuth2 client id of the external tool
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {'id' | 'name'} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerFindExternalTool: async (name?: string, clientId?: string, skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: 'id' | 'name', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tools/external-tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a pdf of the external tool information
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetDatasheet: async (externalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolId' is not null or undefined
            assertParamExists('toolControllerGetDatasheet', 'externalToolId', externalToolId)
            const localVarPath = `/tools/external-tools/{externalToolId}/datasheet`
                .replace(`{${"externalToolId"}}`, encodeURIComponent(String(externalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an ExternalTool for the given id
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetExternalTool: async (externalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolId' is not null or undefined
            assertParamExists('toolControllerGetExternalTool', 'externalToolId', externalToolId)
            const localVarPath = `/tools/external-tools/{externalToolId}`
                .replace(`{${"externalToolId"}}`, encodeURIComponent(String(externalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the logo of an external tool.
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetExternalToolLogo: async (externalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolId' is not null or undefined
            assertParamExists('toolControllerGetExternalToolLogo', 'externalToolId', externalToolId)
            const localVarPath = `/tools/external-tools/{externalToolId}/logo`
                .replace(`{${"externalToolId"}}`, encodeURIComponent(String(externalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata of an external tool.
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetMetaDataForExternalTool: async (externalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolId' is not null or undefined
            assertParamExists('toolControllerGetMetaDataForExternalTool', 'externalToolId', externalToolId)
            const localVarPath = `/tools/external-tools/{externalToolId}/metadata`
                .replace(`{${"externalToolId"}}`, encodeURIComponent(String(externalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates multiple ExternalTools at the same time.
         * @param {ExternalToolBulkCreateParams} externalToolBulkCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerImportExternalTools: async (externalToolBulkCreateParams: ExternalToolBulkCreateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolBulkCreateParams' is not null or undefined
            assertParamExists('toolControllerImportExternalTools', 'externalToolBulkCreateParams', externalToolBulkCreateParams)
            const localVarPath = `/tools/external-tools/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalToolBulkCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an ExternalTool
         * @param {string} externalToolId 
         * @param {ExternalToolUpdateParams} externalToolUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerUpdateExternalTool: async (externalToolId: string, externalToolUpdateParams: ExternalToolUpdateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalToolId' is not null or undefined
            assertParamExists('toolControllerUpdateExternalTool', 'externalToolId', externalToolId)
            // verify required parameter 'externalToolUpdateParams' is not null or undefined
            assertParamExists('toolControllerUpdateExternalTool', 'externalToolUpdateParams', externalToolUpdateParams)
            const localVarPath = `/tools/external-tools/{externalToolId}`
                .replace(`{${"externalToolId"}}`, encodeURIComponent(String(externalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalToolUpdateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contextExternalToolId 
         * @param {Lti11DeepLinkParamsRaw} lti11DeepLinkParamsRaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolDeepLinkControllerDeepLink: async (contextExternalToolId: string, lti11DeepLinkParamsRaw: Lti11DeepLinkParamsRaw, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolDeepLinkControllerDeepLink', 'contextExternalToolId', contextExternalToolId)
            // verify required parameter 'lti11DeepLinkParamsRaw' is not null or undefined
            assertParamExists('toolDeepLinkControllerDeepLink', 'lti11DeepLinkParamsRaw', lti11DeepLinkParamsRaw)
            const localVarPath = `/tools/context-external-tools/{contextExternalToolId}/lti11-deep-link-callback`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lti11DeepLinkParamsRaw, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tool launch request for a context external tool id
         * @param {string} contextExternalToolId The id of the context external tool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolLaunchControllerGetContextExternalToolLaunchRequest: async (contextExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolLaunchControllerGetContextExternalToolLaunchRequest', 'contextExternalToolId', contextExternalToolId)
            const localVarPath = `/tools/context/{contextExternalToolId}/launch`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tool launch request for a school external tool
         * @param {string} schoolExternalToolId The id of the school external tool
         * @param {ContextExternalToolBodyParams} contextExternalToolBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolLaunchControllerGetSchoolExternalToolLaunchRequest: async (schoolExternalToolId: string, contextExternalToolBodyParams: ContextExternalToolBodyParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolId' is not null or undefined
            assertParamExists('toolLaunchControllerGetSchoolExternalToolLaunchRequest', 'schoolExternalToolId', schoolExternalToolId)
            // verify required parameter 'contextExternalToolBodyParams' is not null or undefined
            assertParamExists('toolLaunchControllerGetSchoolExternalToolLaunchRequest', 'contextExternalToolBodyParams', contextExternalToolBodyParams)
            const localVarPath = `/tools/school/{schoolExternalToolId}/launch`
                .replace(`{${"schoolExternalToolId"}}`, encodeURIComponent(String(schoolExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contextExternalToolBodyParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ExternalTool Reference for a given context external tool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolReferenceControllerGetToolReference: async (contextExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextExternalToolId' is not null or undefined
            assertParamExists('toolReferenceControllerGetToolReference', 'contextExternalToolId', contextExternalToolId)
            const localVarPath = `/tools/tool-references/context-external-tools/{contextExternalToolId}`
                .replace(`{${"contextExternalToolId"}}`, encodeURIComponent(String(contextExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get ExternalTool References for a given context
         * @param {string} contextId 
         * @param {ToolContextType} contextType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolReferenceControllerGetToolReferencesForContext: async (contextId: string, contextType: ToolContextType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'contextId' is not null or undefined
            assertParamExists('toolReferenceControllerGetToolReferencesForContext', 'contextId', contextId)
            // verify required parameter 'contextType' is not null or undefined
            assertParamExists('toolReferenceControllerGetToolReferencesForContext', 'contextType', contextType)
            const localVarPath = `/tools/tool-references/{contextType}/{contextId}`
                .replace(`{${"contextId"}}`, encodeURIComponent(String(contextId)))
                .replace(`{${"contextType"}}`, encodeURIComponent(String(contextType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a SchoolExternalTool
         * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerCreateSchoolExternalTool: async (schoolExternalToolPostParams: SchoolExternalToolPostParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolPostParams' is not null or undefined
            assertParamExists('toolSchoolControllerCreateSchoolExternalTool', 'schoolExternalToolPostParams', schoolExternalToolPostParams)
            const localVarPath = `/tools/school-external-tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schoolExternalToolPostParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a SchoolExternalTool
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerDeleteSchoolExternalTool: async (schoolExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolId' is not null or undefined
            assertParamExists('toolSchoolControllerDeleteSchoolExternalTool', 'schoolExternalToolId', schoolExternalToolId)
            const localVarPath = `/tools/school-external-tools/{schoolExternalToolId}`
                .replace(`{${"schoolExternalToolId"}}`, encodeURIComponent(String(schoolExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the metadata of an school external tool.
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerGetMetaDataForExternalTool: async (schoolExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolId' is not null or undefined
            assertParamExists('toolSchoolControllerGetMetaDataForExternalTool', 'schoolExternalToolId', schoolExternalToolId)
            const localVarPath = `/tools/school-external-tools/{schoolExternalToolId}/metadata`
                .replace(`{${"schoolExternalToolId"}}`, encodeURIComponent(String(schoolExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a SchoolExternalTool for the given id
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerGetSchoolExternalTool: async (schoolExternalToolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolId' is not null or undefined
            assertParamExists('toolSchoolControllerGetSchoolExternalTool', 'schoolExternalToolId', schoolExternalToolId)
            const localVarPath = `/tools/school-external-tools/{schoolExternalToolId}`
                .replace(`{${"schoolExternalToolId"}}`, encodeURIComponent(String(schoolExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of SchoolExternalTools for a given school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerGetSchoolExternalTools: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('toolSchoolControllerGetSchoolExternalTools', 'schoolId', schoolId)
            const localVarPath = `/tools/school-external-tools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (schoolId !== undefined) {
                localVarQueryParameter['schoolId'] = schoolId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a SchoolExternalTool
         * @param {string} schoolExternalToolId 
         * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerUpdateSchoolExternalTool: async (schoolExternalToolId: string, schoolExternalToolPostParams: SchoolExternalToolPostParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolExternalToolId' is not null or undefined
            assertParamExists('toolSchoolControllerUpdateSchoolExternalTool', 'schoolExternalToolId', schoolExternalToolId)
            // verify required parameter 'schoolExternalToolPostParams' is not null or undefined
            assertParamExists('toolSchoolControllerUpdateSchoolExternalTool', 'schoolExternalToolPostParams', schoolExternalToolPostParams)
            const localVarPath = `/tools/school-external-tools/{schoolExternalToolId}`
                .replace(`{${"schoolExternalToolId"}}`, encodeURIComponent(String(schoolExternalToolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schoolExternalToolPostParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ToolApi - functional programming interface
 * @export
 */
export const ToolApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ToolApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all available tools that can be added for a given context
         * @param {any} contextType 
         * @param {string} contextId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolConfigurationControllerGetAvailableToolsForContext(contextType: any, contextId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextExternalToolConfigurationTemplateListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolConfigurationControllerGetAvailableToolsForContext(contextType, contextId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all available tools that can be added for a given school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolConfigurationControllerGetAvailableToolsForSchool(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolConfigurationTemplateListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolConfigurationControllerGetAvailableToolsForSchool(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest configuration template for a Context External Tool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextExternalToolConfigurationTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the latest configuration template for a School External Tool
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolConfigurationTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all preferred tools that can be added for a given context
         * @param {ToolContextType} [contextType] Context types for tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolConfigurationControllerGetPreferredToolsForContext(contextType?: ToolContextType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreferredToolListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolConfigurationControllerGetPreferredToolsForContext(contextType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all context types available in the SVS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolConfigurationControllerGetToolContextTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolContextTypesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolConfigurationControllerGetToolContextTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a ContextExternalTool
         * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolContextControllerCreateContextExternalTool(contextExternalToolPostParams: ContextExternalToolPostParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolContextControllerCreateContextExternalTool(contextExternalToolPostParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a ContextExternalTool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolContextControllerDeleteContextExternalTool(contextExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolContextControllerDeleteContextExternalTool(contextExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Searches a ContextExternalTool for the given id
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolContextControllerGetContextExternalTool(contextExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolContextControllerGetContextExternalTool(contextExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of ContextExternalTools for the given context
         * @param {string} contextId 
         * @param {ToolContextType} contextType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolContextControllerGetContextExternalToolsForContext(contextId: string, contextType: ToolContextType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextExternalToolSearchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolContextControllerGetContextExternalToolsForContext(contextId, contextType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a ContextExternalTool
         * @param {string} contextExternalToolId 
         * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolContextControllerUpdateContextExternalTool(contextExternalToolId: string, contextExternalToolPostParams: ContextExternalToolPostParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolContextControllerUpdateContextExternalTool(contextExternalToolId, contextExternalToolPostParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates an ExternalTool
         * @param {ExternalToolCreateParams} externalToolCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerCreateExternalTool(externalToolCreateParams: ExternalToolCreateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerCreateExternalTool(externalToolCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an ExternalTool
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerDeleteExternalTool(externalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerDeleteExternalTool(externalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of ExternalTools
         * @param {string} [name] Name of the external tool
         * @param {string} [clientId] OAuth2 client id of the external tool
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {'id' | 'name'} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerFindExternalTool(name?: string, clientId?: string, skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: 'id' | 'name', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolSearchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerFindExternalTool(name, clientId, skip, limit, sortOrder, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a pdf of the external tool information
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerGetDatasheet(externalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerGetDatasheet(externalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns an ExternalTool for the given id
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerGetExternalTool(externalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerGetExternalTool(externalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the logo of an external tool.
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerGetExternalToolLogo(externalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerGetExternalToolLogo(externalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata of an external tool.
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerGetMetaDataForExternalTool(externalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerGetMetaDataForExternalTool(externalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates multiple ExternalTools at the same time.
         * @param {ExternalToolBulkCreateParams} externalToolBulkCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerImportExternalTools(externalToolBulkCreateParams: ExternalToolBulkCreateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerImportExternalTools(externalToolBulkCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates an ExternalTool
         * @param {string} externalToolId 
         * @param {ExternalToolUpdateParams} externalToolUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolControllerUpdateExternalTool(externalToolId: string, externalToolUpdateParams: ExternalToolUpdateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolControllerUpdateExternalTool(externalToolId, externalToolUpdateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contextExternalToolId 
         * @param {Lti11DeepLinkParamsRaw} lti11DeepLinkParamsRaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolDeepLinkControllerDeepLink(contextExternalToolId: string, lti11DeepLinkParamsRaw: Lti11DeepLinkParamsRaw, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolDeepLinkControllerDeepLink(contextExternalToolId, lti11DeepLinkParamsRaw, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tool launch request for a context external tool id
         * @param {string} contextExternalToolId The id of the context external tool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolLaunchRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tool launch request for a school external tool
         * @param {string} schoolExternalToolId The id of the school external tool
         * @param {ContextExternalToolBodyParams} contextExternalToolBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId: string, contextExternalToolBodyParams: ContextExternalToolBodyParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolLaunchRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId, contextExternalToolBodyParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get ExternalTool Reference for a given context external tool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolReferenceControllerGetToolReference(contextExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolReferenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolReferenceControllerGetToolReference(contextExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get ExternalTool References for a given context
         * @param {string} contextId 
         * @param {ToolContextType} contextType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolReferenceControllerGetToolReferencesForContext(contextId: string, contextType: ToolContextType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolReferenceListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolReferenceControllerGetToolReferencesForContext(contextId, contextType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a SchoolExternalTool
         * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a SchoolExternalTool
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the metadata of an school external tool.
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a SchoolExternalTool for the given id
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of SchoolExternalTools for a given school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolSchoolControllerGetSchoolExternalTools(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolSearchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolSchoolControllerGetSchoolExternalTools(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a SchoolExternalTool
         * @param {string} schoolExternalToolId 
         * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId: string, schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchoolExternalToolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId, schoolExternalToolPostParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ToolApi - factory interface
 * @export
 */
export const ToolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ToolApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all available tools that can be added for a given context
         * @param {any} contextType 
         * @param {string} contextId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetAvailableToolsForContext(contextType: any, contextId: string, options?: any): AxiosPromise<ContextExternalToolConfigurationTemplateListResponse> {
            return localVarFp.toolConfigurationControllerGetAvailableToolsForContext(contextType, contextId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all available tools that can be added for a given school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetAvailableToolsForSchool(schoolId: string, options?: any): AxiosPromise<SchoolExternalToolConfigurationTemplateListResponse> {
            return localVarFp.toolConfigurationControllerGetAvailableToolsForSchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest configuration template for a Context External Tool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId: string, options?: any): AxiosPromise<ContextExternalToolConfigurationTemplateResponse> {
            return localVarFp.toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the latest configuration template for a School External Tool
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId: string, options?: any): AxiosPromise<SchoolExternalToolConfigurationTemplateResponse> {
            return localVarFp.toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all preferred tools that can be added for a given context
         * @param {ToolContextType} [contextType] Context types for tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetPreferredToolsForContext(contextType?: ToolContextType, options?: any): AxiosPromise<PreferredToolListResponse> {
            return localVarFp.toolConfigurationControllerGetPreferredToolsForContext(contextType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all context types available in the SVS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolConfigurationControllerGetToolContextTypes(options?: any): AxiosPromise<ToolContextTypesListResponse> {
            return localVarFp.toolConfigurationControllerGetToolContextTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a ContextExternalTool
         * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerCreateContextExternalTool(contextExternalToolPostParams: ContextExternalToolPostParams, options?: any): AxiosPromise<ContextExternalToolResponse> {
            return localVarFp.toolContextControllerCreateContextExternalTool(contextExternalToolPostParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a ContextExternalTool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerDeleteContextExternalTool(contextExternalToolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.toolContextControllerDeleteContextExternalTool(contextExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Searches a ContextExternalTool for the given id
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerGetContextExternalTool(contextExternalToolId: string, options?: any): AxiosPromise<ContextExternalToolResponse> {
            return localVarFp.toolContextControllerGetContextExternalTool(contextExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of ContextExternalTools for the given context
         * @param {string} contextId 
         * @param {ToolContextType} contextType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerGetContextExternalToolsForContext(contextId: string, contextType: ToolContextType, options?: any): AxiosPromise<ContextExternalToolSearchListResponse> {
            return localVarFp.toolContextControllerGetContextExternalToolsForContext(contextId, contextType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a ContextExternalTool
         * @param {string} contextExternalToolId 
         * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolContextControllerUpdateContextExternalTool(contextExternalToolId: string, contextExternalToolPostParams: ContextExternalToolPostParams, options?: any): AxiosPromise<ContextExternalToolResponse> {
            return localVarFp.toolContextControllerUpdateContextExternalTool(contextExternalToolId, contextExternalToolPostParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an ExternalTool
         * @param {ExternalToolCreateParams} externalToolCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerCreateExternalTool(externalToolCreateParams: ExternalToolCreateParams, options?: any): AxiosPromise<ExternalToolResponse> {
            return localVarFp.toolControllerCreateExternalTool(externalToolCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an ExternalTool
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerDeleteExternalTool(externalToolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.toolControllerDeleteExternalTool(externalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of ExternalTools
         * @param {string} [name] Name of the external tool
         * @param {string} [clientId] OAuth2 client id of the external tool
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {'id' | 'name'} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerFindExternalTool(name?: string, clientId?: string, skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: 'id' | 'name', options?: any): AxiosPromise<ExternalToolSearchListResponse> {
            return localVarFp.toolControllerFindExternalTool(name, clientId, skip, limit, sortOrder, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a pdf of the external tool information
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetDatasheet(externalToolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.toolControllerGetDatasheet(externalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an ExternalTool for the given id
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetExternalTool(externalToolId: string, options?: any): AxiosPromise<ExternalToolResponse> {
            return localVarFp.toolControllerGetExternalTool(externalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the logo of an external tool.
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetExternalToolLogo(externalToolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.toolControllerGetExternalToolLogo(externalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata of an external tool.
         * @param {string} externalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerGetMetaDataForExternalTool(externalToolId: string, options?: any): AxiosPromise<ExternalToolMetadataResponse> {
            return localVarFp.toolControllerGetMetaDataForExternalTool(externalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates multiple ExternalTools at the same time.
         * @param {ExternalToolBulkCreateParams} externalToolBulkCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerImportExternalTools(externalToolBulkCreateParams: ExternalToolBulkCreateParams, options?: any): AxiosPromise<ExternalToolResponse> {
            return localVarFp.toolControllerImportExternalTools(externalToolBulkCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an ExternalTool
         * @param {string} externalToolId 
         * @param {ExternalToolUpdateParams} externalToolUpdateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolControllerUpdateExternalTool(externalToolId: string, externalToolUpdateParams: ExternalToolUpdateParams, options?: any): AxiosPromise<ExternalToolResponse> {
            return localVarFp.toolControllerUpdateExternalTool(externalToolId, externalToolUpdateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} contextExternalToolId 
         * @param {Lti11DeepLinkParamsRaw} lti11DeepLinkParamsRaw 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolDeepLinkControllerDeepLink(contextExternalToolId: string, lti11DeepLinkParamsRaw: Lti11DeepLinkParamsRaw, options?: any): AxiosPromise<string> {
            return localVarFp.toolDeepLinkControllerDeepLink(contextExternalToolId, lti11DeepLinkParamsRaw, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tool launch request for a context external tool id
         * @param {string} contextExternalToolId The id of the context external tool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId: string, options?: any): AxiosPromise<ToolLaunchRequestResponse> {
            return localVarFp.toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tool launch request for a school external tool
         * @param {string} schoolExternalToolId The id of the school external tool
         * @param {ContextExternalToolBodyParams} contextExternalToolBodyParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId: string, contextExternalToolBodyParams: ContextExternalToolBodyParams, options?: any): AxiosPromise<ToolLaunchRequestResponse> {
            return localVarFp.toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId, contextExternalToolBodyParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ExternalTool Reference for a given context external tool
         * @param {string} contextExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolReferenceControllerGetToolReference(contextExternalToolId: string, options?: any): AxiosPromise<ToolReferenceResponse> {
            return localVarFp.toolReferenceControllerGetToolReference(contextExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get ExternalTool References for a given context
         * @param {string} contextId 
         * @param {ToolContextType} contextType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolReferenceControllerGetToolReferencesForContext(contextId: string, contextType: ToolContextType, options?: any): AxiosPromise<ToolReferenceListResponse> {
            return localVarFp.toolReferenceControllerGetToolReferencesForContext(contextId, contextType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a SchoolExternalTool
         * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any): AxiosPromise<SchoolExternalToolResponse> {
            return localVarFp.toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a SchoolExternalTool
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the metadata of an school external tool.
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId: string, options?: any): AxiosPromise<SchoolExternalToolMetadataResponse> {
            return localVarFp.toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a SchoolExternalTool for the given id
         * @param {string} schoolExternalToolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId: string, options?: any): AxiosPromise<SchoolExternalToolResponse> {
            return localVarFp.toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of SchoolExternalTools for a given school
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerGetSchoolExternalTools(schoolId: string, options?: any): AxiosPromise<SchoolExternalToolSearchListResponse> {
            return localVarFp.toolSchoolControllerGetSchoolExternalTools(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a SchoolExternalTool
         * @param {string} schoolExternalToolId 
         * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId: string, schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any): AxiosPromise<SchoolExternalToolResponse> {
            return localVarFp.toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId, schoolExternalToolPostParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ToolApi - interface
 * @export
 * @interface ToolApi
 */
export interface ToolApiInterface {
    /**
     * 
     * @summary Lists all available tools that can be added for a given context
     * @param {any} contextType 
     * @param {string} contextId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolConfigurationControllerGetAvailableToolsForContext(contextType: any, contextId: string, options?: any): AxiosPromise<ContextExternalToolConfigurationTemplateListResponse>;

    /**
     * 
     * @summary Lists all available tools that can be added for a given school
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolConfigurationControllerGetAvailableToolsForSchool(schoolId: string, options?: any): AxiosPromise<SchoolExternalToolConfigurationTemplateListResponse>;

    /**
     * 
     * @summary Get the latest configuration template for a Context External Tool
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId: string, options?: any): AxiosPromise<ContextExternalToolConfigurationTemplateResponse>;

    /**
     * 
     * @summary Get the latest configuration template for a School External Tool
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId: string, options?: any): AxiosPromise<SchoolExternalToolConfigurationTemplateResponse>;

    /**
     * 
     * @summary Lists all preferred tools that can be added for a given context
     * @param {ToolContextType} [contextType] Context types for tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolConfigurationControllerGetPreferredToolsForContext(contextType?: ToolContextType, options?: any): AxiosPromise<PreferredToolListResponse>;

    /**
     * 
     * @summary Lists all context types available in the SVS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolConfigurationControllerGetToolContextTypes(options?: any): AxiosPromise<ToolContextTypesListResponse>;

    /**
     * 
     * @summary Creates a ContextExternalTool
     * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolContextControllerCreateContextExternalTool(contextExternalToolPostParams: ContextExternalToolPostParams, options?: any): AxiosPromise<ContextExternalToolResponse>;

    /**
     * 
     * @summary Deletes a ContextExternalTool
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolContextControllerDeleteContextExternalTool(contextExternalToolId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Searches a ContextExternalTool for the given id
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolContextControllerGetContextExternalTool(contextExternalToolId: string, options?: any): AxiosPromise<ContextExternalToolResponse>;

    /**
     * 
     * @summary Returns a list of ContextExternalTools for the given context
     * @param {string} contextId 
     * @param {ToolContextType} contextType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolContextControllerGetContextExternalToolsForContext(contextId: string, contextType: ToolContextType, options?: any): AxiosPromise<ContextExternalToolSearchListResponse>;

    /**
     * 
     * @summary Updates a ContextExternalTool
     * @param {string} contextExternalToolId 
     * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolContextControllerUpdateContextExternalTool(contextExternalToolId: string, contextExternalToolPostParams: ContextExternalToolPostParams, options?: any): AxiosPromise<ContextExternalToolResponse>;

    /**
     * 
     * @summary Creates an ExternalTool
     * @param {ExternalToolCreateParams} externalToolCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerCreateExternalTool(externalToolCreateParams: ExternalToolCreateParams, options?: any): AxiosPromise<ExternalToolResponse>;

    /**
     * 
     * @summary Deletes an ExternalTool
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerDeleteExternalTool(externalToolId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Returns a list of ExternalTools
     * @param {string} [name] Name of the external tool
     * @param {string} [clientId] OAuth2 client id of the external tool
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {'id' | 'name'} [sortBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerFindExternalTool(name?: string, clientId?: string, skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: 'id' | 'name', options?: any): AxiosPromise<ExternalToolSearchListResponse>;

    /**
     * 
     * @summary Returns a pdf of the external tool information
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerGetDatasheet(externalToolId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Returns an ExternalTool for the given id
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerGetExternalTool(externalToolId: string, options?: any): AxiosPromise<ExternalToolResponse>;

    /**
     * 
     * @summary Gets the logo of an external tool.
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerGetExternalToolLogo(externalToolId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Gets the metadata of an external tool.
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerGetMetaDataForExternalTool(externalToolId: string, options?: any): AxiosPromise<ExternalToolMetadataResponse>;

    /**
     * 
     * @summary Creates multiple ExternalTools at the same time.
     * @param {ExternalToolBulkCreateParams} externalToolBulkCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerImportExternalTools(externalToolBulkCreateParams: ExternalToolBulkCreateParams, options?: any): AxiosPromise<ExternalToolResponse>;

    /**
     * 
     * @summary Updates an ExternalTool
     * @param {string} externalToolId 
     * @param {ExternalToolUpdateParams} externalToolUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolControllerUpdateExternalTool(externalToolId: string, externalToolUpdateParams: ExternalToolUpdateParams, options?: any): AxiosPromise<ExternalToolResponse>;

    /**
     * 
     * @param {string} contextExternalToolId 
     * @param {Lti11DeepLinkParamsRaw} lti11DeepLinkParamsRaw 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolDeepLinkControllerDeepLink(contextExternalToolId: string, lti11DeepLinkParamsRaw: Lti11DeepLinkParamsRaw, options?: any): AxiosPromise<string>;

    /**
     * 
     * @summary Get tool launch request for a context external tool id
     * @param {string} contextExternalToolId The id of the context external tool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId: string, options?: any): AxiosPromise<ToolLaunchRequestResponse>;

    /**
     * 
     * @summary Get tool launch request for a school external tool
     * @param {string} schoolExternalToolId The id of the school external tool
     * @param {ContextExternalToolBodyParams} contextExternalToolBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId: string, contextExternalToolBodyParams: ContextExternalToolBodyParams, options?: any): AxiosPromise<ToolLaunchRequestResponse>;

    /**
     * 
     * @summary Get ExternalTool Reference for a given context external tool
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolReferenceControllerGetToolReference(contextExternalToolId: string, options?: any): AxiosPromise<ToolReferenceResponse>;

    /**
     * 
     * @summary Get ExternalTool References for a given context
     * @param {string} contextId 
     * @param {ToolContextType} contextType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolReferenceControllerGetToolReferencesForContext(contextId: string, contextType: ToolContextType, options?: any): AxiosPromise<ToolReferenceListResponse>;

    /**
     * 
     * @summary Creates a SchoolExternalTool
     * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any): AxiosPromise<SchoolExternalToolResponse>;

    /**
     * 
     * @summary Deletes a SchoolExternalTool
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId: string, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Gets the metadata of an school external tool.
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId: string, options?: any): AxiosPromise<SchoolExternalToolMetadataResponse>;

    /**
     * 
     * @summary Returns a SchoolExternalTool for the given id
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId: string, options?: any): AxiosPromise<SchoolExternalToolResponse>;

    /**
     * 
     * @summary Returns a list of SchoolExternalTools for a given school
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolSchoolControllerGetSchoolExternalTools(schoolId: string, options?: any): AxiosPromise<SchoolExternalToolSearchListResponse>;

    /**
     * 
     * @summary Updates a SchoolExternalTool
     * @param {string} schoolExternalToolId 
     * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApiInterface
     */
    toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId: string, schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any): AxiosPromise<SchoolExternalToolResponse>;

}

/**
 * ToolApi - object-oriented interface
 * @export
 * @class ToolApi
 * @extends {BaseAPI}
 */
export class ToolApi extends BaseAPI implements ToolApiInterface {
    /**
     * 
     * @summary Lists all available tools that can be added for a given context
     * @param {any} contextType 
     * @param {string} contextId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolConfigurationControllerGetAvailableToolsForContext(contextType: any, contextId: string, options?: any) {
        return ToolApiFp(this.configuration).toolConfigurationControllerGetAvailableToolsForContext(contextType, contextId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all available tools that can be added for a given school
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolConfigurationControllerGetAvailableToolsForSchool(schoolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolConfigurationControllerGetAvailableToolsForSchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest configuration template for a Context External Tool
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolConfigurationControllerGetConfigurationTemplateForContext(contextExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the latest configuration template for a School External Tool
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolConfigurationControllerGetConfigurationTemplateForSchool(schoolExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all preferred tools that can be added for a given context
     * @param {ToolContextType} [contextType] Context types for tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolConfigurationControllerGetPreferredToolsForContext(contextType?: ToolContextType, options?: any) {
        return ToolApiFp(this.configuration).toolConfigurationControllerGetPreferredToolsForContext(contextType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all context types available in the SVS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolConfigurationControllerGetToolContextTypes(options?: any) {
        return ToolApiFp(this.configuration).toolConfigurationControllerGetToolContextTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a ContextExternalTool
     * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolContextControllerCreateContextExternalTool(contextExternalToolPostParams: ContextExternalToolPostParams, options?: any) {
        return ToolApiFp(this.configuration).toolContextControllerCreateContextExternalTool(contextExternalToolPostParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a ContextExternalTool
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolContextControllerDeleteContextExternalTool(contextExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolContextControllerDeleteContextExternalTool(contextExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Searches a ContextExternalTool for the given id
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolContextControllerGetContextExternalTool(contextExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolContextControllerGetContextExternalTool(contextExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of ContextExternalTools for the given context
     * @param {string} contextId 
     * @param {ToolContextType} contextType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolContextControllerGetContextExternalToolsForContext(contextId: string, contextType: ToolContextType, options?: any) {
        return ToolApiFp(this.configuration).toolContextControllerGetContextExternalToolsForContext(contextId, contextType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a ContextExternalTool
     * @param {string} contextExternalToolId 
     * @param {ContextExternalToolPostParams} contextExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolContextControllerUpdateContextExternalTool(contextExternalToolId: string, contextExternalToolPostParams: ContextExternalToolPostParams, options?: any) {
        return ToolApiFp(this.configuration).toolContextControllerUpdateContextExternalTool(contextExternalToolId, contextExternalToolPostParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an ExternalTool
     * @param {ExternalToolCreateParams} externalToolCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerCreateExternalTool(externalToolCreateParams: ExternalToolCreateParams, options?: any) {
        return ToolApiFp(this.configuration).toolControllerCreateExternalTool(externalToolCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an ExternalTool
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerDeleteExternalTool(externalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolControllerDeleteExternalTool(externalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of ExternalTools
     * @param {string} [name] Name of the external tool
     * @param {string} [clientId] OAuth2 client id of the external tool
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {'id' | 'name'} [sortBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerFindExternalTool(name?: string, clientId?: string, skip?: number, limit?: number, sortOrder?: 'asc' | 'desc', sortBy?: 'id' | 'name', options?: any) {
        return ToolApiFp(this.configuration).toolControllerFindExternalTool(name, clientId, skip, limit, sortOrder, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a pdf of the external tool information
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerGetDatasheet(externalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolControllerGetDatasheet(externalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an ExternalTool for the given id
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerGetExternalTool(externalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolControllerGetExternalTool(externalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the logo of an external tool.
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerGetExternalToolLogo(externalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolControllerGetExternalToolLogo(externalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata of an external tool.
     * @param {string} externalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerGetMetaDataForExternalTool(externalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolControllerGetMetaDataForExternalTool(externalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates multiple ExternalTools at the same time.
     * @param {ExternalToolBulkCreateParams} externalToolBulkCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerImportExternalTools(externalToolBulkCreateParams: ExternalToolBulkCreateParams, options?: any) {
        return ToolApiFp(this.configuration).toolControllerImportExternalTools(externalToolBulkCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an ExternalTool
     * @param {string} externalToolId 
     * @param {ExternalToolUpdateParams} externalToolUpdateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolControllerUpdateExternalTool(externalToolId: string, externalToolUpdateParams: ExternalToolUpdateParams, options?: any) {
        return ToolApiFp(this.configuration).toolControllerUpdateExternalTool(externalToolId, externalToolUpdateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} contextExternalToolId 
     * @param {Lti11DeepLinkParamsRaw} lti11DeepLinkParamsRaw 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolDeepLinkControllerDeepLink(contextExternalToolId: string, lti11DeepLinkParamsRaw: Lti11DeepLinkParamsRaw, options?: any) {
        return ToolApiFp(this.configuration).toolDeepLinkControllerDeepLink(contextExternalToolId, lti11DeepLinkParamsRaw, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tool launch request for a context external tool id
     * @param {string} contextExternalToolId The id of the context external tool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolLaunchControllerGetContextExternalToolLaunchRequest(contextExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tool launch request for a school external tool
     * @param {string} schoolExternalToolId The id of the school external tool
     * @param {ContextExternalToolBodyParams} contextExternalToolBodyParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId: string, contextExternalToolBodyParams: ContextExternalToolBodyParams, options?: any) {
        return ToolApiFp(this.configuration).toolLaunchControllerGetSchoolExternalToolLaunchRequest(schoolExternalToolId, contextExternalToolBodyParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ExternalTool Reference for a given context external tool
     * @param {string} contextExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolReferenceControllerGetToolReference(contextExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolReferenceControllerGetToolReference(contextExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get ExternalTool References for a given context
     * @param {string} contextId 
     * @param {ToolContextType} contextType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolReferenceControllerGetToolReferencesForContext(contextId: string, contextType: ToolContextType, options?: any) {
        return ToolApiFp(this.configuration).toolReferenceControllerGetToolReferencesForContext(contextId, contextType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a SchoolExternalTool
     * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any) {
        return ToolApiFp(this.configuration).toolSchoolControllerCreateSchoolExternalTool(schoolExternalToolPostParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a SchoolExternalTool
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolSchoolControllerDeleteSchoolExternalTool(schoolExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the metadata of an school external tool.
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolSchoolControllerGetMetaDataForExternalTool(schoolExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a SchoolExternalTool for the given id
     * @param {string} schoolExternalToolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolSchoolControllerGetSchoolExternalTool(schoolExternalToolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of SchoolExternalTools for a given school
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolSchoolControllerGetSchoolExternalTools(schoolId: string, options?: any) {
        return ToolApiFp(this.configuration).toolSchoolControllerGetSchoolExternalTools(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a SchoolExternalTool
     * @param {string} schoolExternalToolId 
     * @param {SchoolExternalToolPostParams} schoolExternalToolPostParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolApi
     */
    public toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId: string, schoolExternalToolPostParams: SchoolExternalToolPostParams, options?: any) {
        return ToolApiFp(this.configuration).toolSchoolControllerUpdateSchoolExternalTool(schoolExternalToolId, schoolExternalToolPostParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangeLanguageParams} changeLanguageParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerChangeLanguage: async (changeLanguageParams: ChangeLanguageParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeLanguageParams' is not null or undefined
            assertParamExists('userControllerChangeLanguage', 'changeLanguageParams', changeLanguageParams)
            const localVarPath = `/user/language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeLanguageParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangeLanguageParams} changeLanguageParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerChangeLanguage(changeLanguageParams: ChangeLanguageParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessfulResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangeLanguage(changeLanguageParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangeLanguageParams} changeLanguageParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerChangeLanguage(changeLanguageParams: ChangeLanguageParams, options?: any): AxiosPromise<SuccessfulResponse> {
            return localVarFp.userControllerChangeLanguage(changeLanguageParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerMe(options?: any): AxiosPromise<ResolvedUserResponse> {
            return localVarFp.userControllerMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @param {ChangeLanguageParams} changeLanguageParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userControllerChangeLanguage(changeLanguageParams: ChangeLanguageParams, options?: any): AxiosPromise<SuccessfulResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userControllerMe(options?: any): AxiosPromise<ResolvedUserResponse>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @param {ChangeLanguageParams} changeLanguageParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerChangeLanguage(changeLanguageParams: ChangeLanguageParams, options?: any) {
        return UserApiFp(this.configuration).userControllerChangeLanguage(changeLanguageParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerMe(options?: any) {
        return UserApiFp(this.configuration).userControllerMe(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserImportApi - axios parameter creator
 * @export
 */
export const UserImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel current migration process
         * @summary Cancel migration wizard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerCancelMigration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Clear all auto matches from imported users of a school
         * @summary Clear all auto matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerClearAllAutoMatches: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import/clear-all-auto-matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerEndSchoolInMaintenance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import/startSync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [loginName] 
         * @param {Array<'auto' | 'admin' | 'none'>} [match] 
         * @param {boolean} [flagged] 
         * @param {string} [classes] 
         * @param {'student' | 'teacher' | 'admin'} [role] 
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {'firstName' | 'lastName'} [sortBy] 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerFindAllImportUsers: async (firstName?: string, lastName?: string, loginName?: string, match?: Array<'auto' | 'admin' | 'none'>, flagged?: boolean, classes?: string, role?: 'student' | 'teacher' | 'admin', sortOrder?: 'asc' | 'desc', sortBy?: 'firstName' | 'lastName', skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (firstName !== undefined) {
                localVarQueryParameter['firstName'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['lastName'] = lastName;
            }

            if (loginName !== undefined) {
                localVarQueryParameter['loginName'] = loginName;
            }

            if (match) {
                localVarQueryParameter['match'] = match;
            }

            if (flagged !== undefined) {
                localVarQueryParameter['flagged'] = flagged;
            }

            if (classes !== undefined) {
                localVarQueryParameter['classes'] = classes;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerFindAllUnmatchedUsers: async (name?: string, skip?: number, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import/unassigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Populates import users from specific user migration populate endpoint.
         * @summary Populates import users
         * @param {boolean} [matchByPreferredName] Should the users preferred name from the external system be used for auto-matching to existing users?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerPopulateImportUsers: async (matchByPreferredName?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import/populate-import-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (matchByPreferredName !== undefined) {
                localVarQueryParameter['matchByPreferredName'] = matchByPreferredName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerRemoveMatch: async (importUserId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importUserId' is not null or undefined
            assertParamExists('importUserControllerRemoveMatch', 'importUserId', importUserId)
            const localVarPath = `/user/import/{importUserId}/match`
                .replace(`{${"importUserId"}}`, encodeURIComponent(String(importUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerSaveAllUsersMatches: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/import/migrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {UpdateMatchParams} updateMatchParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerSetMatch: async (importUserId: string, updateMatchParams: UpdateMatchParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importUserId' is not null or undefined
            assertParamExists('importUserControllerSetMatch', 'importUserId', importUserId)
            // verify required parameter 'updateMatchParams' is not null or undefined
            assertParamExists('importUserControllerSetMatch', 'updateMatchParams', updateMatchParams)
            const localVarPath = `/user/import/{importUserId}/match`
                .replace(`{${"importUserId"}}`, encodeURIComponent(String(importUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMatchParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} useCentralLdap 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerStartSchoolInUserMigration: async (useCentralLdap: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'useCentralLdap' is not null or undefined
            assertParamExists('importUserControllerStartSchoolInUserMigration', 'useCentralLdap', useCentralLdap)
            const localVarPath = `/user/import/startUserMigration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (useCentralLdap !== undefined) {
                localVarQueryParameter['useCentralLdap'] = useCentralLdap;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {UpdateFlagParams} updateFlagParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerUpdateFlag: async (importUserId: string, updateFlagParams: UpdateFlagParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importUserId' is not null or undefined
            assertParamExists('importUserControllerUpdateFlag', 'importUserId', importUserId)
            // verify required parameter 'updateFlagParams' is not null or undefined
            assertParamExists('importUserControllerUpdateFlag', 'updateFlagParams', updateFlagParams)
            const localVarPath = `/user/import/{importUserId}/flag`
                .replace(`{${"importUserId"}}`, encodeURIComponent(String(importUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFlagParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserImportApi - functional programming interface
 * @export
 */
export const UserImportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserImportApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel current migration process
         * @summary Cancel migration wizard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerCancelMigration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerCancelMigration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Clear all auto matches from imported users of a school
         * @summary Clear all auto matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerClearAllAutoMatches(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerClearAllAutoMatches(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerEndSchoolInMaintenance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerEndSchoolInMaintenance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [loginName] 
         * @param {Array<'auto' | 'admin' | 'none'>} [match] 
         * @param {boolean} [flagged] 
         * @param {string} [classes] 
         * @param {'student' | 'teacher' | 'admin'} [role] 
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {'firstName' | 'lastName'} [sortBy] 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerFindAllImportUsers(firstName?: string, lastName?: string, loginName?: string, match?: Array<'auto' | 'admin' | 'none'>, flagged?: boolean, classes?: string, role?: 'student' | 'teacher' | 'admin', sortOrder?: 'asc' | 'desc', sortBy?: 'firstName' | 'lastName', skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportUserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerFindAllImportUsers(firstName, lastName, loginName, match, flagged, classes, role, sortOrder, sortBy, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerFindAllUnmatchedUsers(name?: string, skip?: number, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserMatchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerFindAllUnmatchedUsers(name, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Populates import users from specific user migration populate endpoint.
         * @summary Populates import users
         * @param {boolean} [matchByPreferredName] Should the users preferred name from the external system be used for auto-matching to existing users?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerPopulateImportUsers(matchByPreferredName?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerPopulateImportUsers(matchByPreferredName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerRemoveMatch(importUserId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerRemoveMatch(importUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerSaveAllUsersMatches(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerSaveAllUsersMatches(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {UpdateMatchParams} updateMatchParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerSetMatch(importUserId: string, updateMatchParams: UpdateMatchParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerSetMatch(importUserId, updateMatchParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} useCentralLdap 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerStartSchoolInUserMigration(useCentralLdap: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerStartSchoolInUserMigration(useCentralLdap, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {UpdateFlagParams} updateFlagParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importUserControllerUpdateFlag(importUserId: string, updateFlagParams: UpdateFlagParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importUserControllerUpdateFlag(importUserId, updateFlagParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserImportApi - factory interface
 * @export
 */
export const UserImportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserImportApiFp(configuration)
    return {
        /**
         * Cancel current migration process
         * @summary Cancel migration wizard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerCancelMigration(options?: any): AxiosPromise<void> {
            return localVarFp.importUserControllerCancelMigration(options).then((request) => request(axios, basePath));
        },
        /**
         * Clear all auto matches from imported users of a school
         * @summary Clear all auto matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerClearAllAutoMatches(options?: any): AxiosPromise<void> {
            return localVarFp.importUserControllerClearAllAutoMatches(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerEndSchoolInMaintenance(options?: any): AxiosPromise<void> {
            return localVarFp.importUserControllerEndSchoolInMaintenance(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [loginName] 
         * @param {Array<'auto' | 'admin' | 'none'>} [match] 
         * @param {boolean} [flagged] 
         * @param {string} [classes] 
         * @param {'student' | 'teacher' | 'admin'} [role] 
         * @param {'asc' | 'desc'} [sortOrder] 
         * @param {'firstName' | 'lastName'} [sortBy] 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerFindAllImportUsers(firstName?: string, lastName?: string, loginName?: string, match?: Array<'auto' | 'admin' | 'none'>, flagged?: boolean, classes?: string, role?: 'student' | 'teacher' | 'admin', sortOrder?: 'asc' | 'desc', sortBy?: 'firstName' | 'lastName', skip?: number, limit?: number, options?: any): AxiosPromise<ImportUserListResponse> {
            return localVarFp.importUserControllerFindAllImportUsers(firstName, lastName, loginName, match, flagged, classes, role, sortOrder, sortBy, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {number} [skip] Number of elements (not pages) to be skipped
         * @param {number} [limit] Page limit, defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerFindAllUnmatchedUsers(name?: string, skip?: number, limit?: number, options?: any): AxiosPromise<UserMatchListResponse> {
            return localVarFp.importUserControllerFindAllUnmatchedUsers(name, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Populates import users from specific user migration populate endpoint.
         * @summary Populates import users
         * @param {boolean} [matchByPreferredName] Should the users preferred name from the external system be used for auto-matching to existing users?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerPopulateImportUsers(matchByPreferredName?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.importUserControllerPopulateImportUsers(matchByPreferredName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerRemoveMatch(importUserId: string, options?: any): AxiosPromise<ImportUserResponse> {
            return localVarFp.importUserControllerRemoveMatch(importUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerSaveAllUsersMatches(options?: any): AxiosPromise<void> {
            return localVarFp.importUserControllerSaveAllUsersMatches(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {UpdateMatchParams} updateMatchParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerSetMatch(importUserId: string, updateMatchParams: UpdateMatchParams, options?: any): AxiosPromise<ImportUserResponse> {
            return localVarFp.importUserControllerSetMatch(importUserId, updateMatchParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} useCentralLdap 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerStartSchoolInUserMigration(useCentralLdap: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.importUserControllerStartSchoolInUserMigration(useCentralLdap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
         * @param {UpdateFlagParams} updateFlagParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUserControllerUpdateFlag(importUserId: string, updateFlagParams: UpdateFlagParams, options?: any): AxiosPromise<ImportUserResponse> {
            return localVarFp.importUserControllerUpdateFlag(importUserId, updateFlagParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserImportApi - interface
 * @export
 * @interface UserImportApi
 */
export interface UserImportApiInterface {
    /**
     * Cancel current migration process
     * @summary Cancel migration wizard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerCancelMigration(options?: any): AxiosPromise<void>;

    /**
     * Clear all auto matches from imported users of a school
     * @summary Clear all auto matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerClearAllAutoMatches(options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerEndSchoolInMaintenance(options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [loginName] 
     * @param {Array<'auto' | 'admin' | 'none'>} [match] 
     * @param {boolean} [flagged] 
     * @param {string} [classes] 
     * @param {'student' | 'teacher' | 'admin'} [role] 
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {'firstName' | 'lastName'} [sortBy] 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerFindAllImportUsers(firstName?: string, lastName?: string, loginName?: string, match?: Array<'auto' | 'admin' | 'none'>, flagged?: boolean, classes?: string, role?: 'student' | 'teacher' | 'admin', sortOrder?: 'asc' | 'desc', sortBy?: 'firstName' | 'lastName', skip?: number, limit?: number, options?: any): AxiosPromise<ImportUserListResponse>;

    /**
     * 
     * @param {string} [name] 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerFindAllUnmatchedUsers(name?: string, skip?: number, limit?: number, options?: any): AxiosPromise<UserMatchListResponse>;

    /**
     * Populates import users from specific user migration populate endpoint.
     * @summary Populates import users
     * @param {boolean} [matchByPreferredName] Should the users preferred name from the external system be used for auto-matching to existing users?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerPopulateImportUsers(matchByPreferredName?: boolean, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerRemoveMatch(importUserId: string, options?: any): AxiosPromise<ImportUserResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerSaveAllUsersMatches(options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
     * @param {UpdateMatchParams} updateMatchParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerSetMatch(importUserId: string, updateMatchParams: UpdateMatchParams, options?: any): AxiosPromise<ImportUserResponse>;

    /**
     * 
     * @param {boolean} useCentralLdap 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerStartSchoolInUserMigration(useCentralLdap: boolean, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
     * @param {UpdateFlagParams} updateFlagParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApiInterface
     */
    importUserControllerUpdateFlag(importUserId: string, updateFlagParams: UpdateFlagParams, options?: any): AxiosPromise<ImportUserResponse>;

}

/**
 * UserImportApi - object-oriented interface
 * @export
 * @class UserImportApi
 * @extends {BaseAPI}
 */
export class UserImportApi extends BaseAPI implements UserImportApiInterface {
    /**
     * Cancel current migration process
     * @summary Cancel migration wizard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerCancelMigration(options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerCancelMigration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Clear all auto matches from imported users of a school
     * @summary Clear all auto matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerClearAllAutoMatches(options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerClearAllAutoMatches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerEndSchoolInMaintenance(options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerEndSchoolInMaintenance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [firstName] 
     * @param {string} [lastName] 
     * @param {string} [loginName] 
     * @param {Array<'auto' | 'admin' | 'none'>} [match] 
     * @param {boolean} [flagged] 
     * @param {string} [classes] 
     * @param {'student' | 'teacher' | 'admin'} [role] 
     * @param {'asc' | 'desc'} [sortOrder] 
     * @param {'firstName' | 'lastName'} [sortBy] 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerFindAllImportUsers(firstName?: string, lastName?: string, loginName?: string, match?: Array<'auto' | 'admin' | 'none'>, flagged?: boolean, classes?: string, role?: 'student' | 'teacher' | 'admin', sortOrder?: 'asc' | 'desc', sortBy?: 'firstName' | 'lastName', skip?: number, limit?: number, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerFindAllImportUsers(firstName, lastName, loginName, match, flagged, classes, role, sortOrder, sortBy, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [name] 
     * @param {number} [skip] Number of elements (not pages) to be skipped
     * @param {number} [limit] Page limit, defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerFindAllUnmatchedUsers(name?: string, skip?: number, limit?: number, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerFindAllUnmatchedUsers(name, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Populates import users from specific user migration populate endpoint.
     * @summary Populates import users
     * @param {boolean} [matchByPreferredName] Should the users preferred name from the external system be used for auto-matching to existing users?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerPopulateImportUsers(matchByPreferredName?: boolean, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerPopulateImportUsers(matchByPreferredName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerRemoveMatch(importUserId: string, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerRemoveMatch(importUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerSaveAllUsersMatches(options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerSaveAllUsersMatches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
     * @param {UpdateMatchParams} updateMatchParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerSetMatch(importUserId: string, updateMatchParams: UpdateMatchParams, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerSetMatch(importUserId, updateMatchParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} useCentralLdap 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerStartSchoolInUserMigration(useCentralLdap: boolean, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerStartSchoolInUserMigration(useCentralLdap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} importUserId The id of an importuser object, that matches an internal user with an external user.
     * @param {UpdateFlagParams} updateFlagParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserImportApi
     */
    public importUserControllerUpdateFlag(importUserId: string, updateFlagParams: UpdateFlagParams, options?: any) {
        return UserImportApiFp(this.configuration).importUserControllerUpdateFlag(importUserId, updateFlagParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserLoginMigrationApi - axios parameter creator
 * @export
 */
export const UserLoginMigrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerCloseMigration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-login-migrations/close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerFindUserLoginMigrationBySchool: async (schoolId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'schoolId' is not null or undefined
            assertParamExists('userLoginMigrationControllerFindUserLoginMigrationBySchool', 'schoolId', schoolId)
            const localVarPath = `/user-login-migrations/schools/{schoolId}`
                .replace(`{${"schoolId"}}`, encodeURIComponent(String(schoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Force migrate an administrator account and its school
         * @param {ForceMigrationParams} forceMigrationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerForceMigration: async (forceMigrationParams: ForceMigrationParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forceMigrationParams' is not null or undefined
            assertParamExists('userLoginMigrationControllerForceMigration', 'forceMigrationParams', forceMigrationParams)
            const localVarPath = `/user-login-migrations/force-migration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forceMigrationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Currently there can only be one migration for a user. Therefore only one migration is returned.
         * @summary Get UserLoginMigrations
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerGetMigrations: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-login-migrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Oauth2MigrationParams} oauth2MigrationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerMigrateUserLogin: async (oauth2MigrationParams: Oauth2MigrationParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'oauth2MigrationParams' is not null or undefined
            assertParamExists('userLoginMigrationControllerMigrateUserLogin', 'oauth2MigrationParams', oauth2MigrationParams)
            const localVarPath = `/user-login-migrations/migrate-to-oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oauth2MigrationParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerRestartMigration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-login-migrations/restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerSetMigrationMandatory: async (userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginMigrationMandatoryParams' is not null or undefined
            assertParamExists('userLoginMigrationControllerSetMigrationMandatory', 'userLoginMigrationMandatoryParams', userLoginMigrationMandatoryParams)
            const localVarPath = `/user-login-migrations/mandatory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLoginMigrationMandatoryParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerStartMigration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-login-migrations/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserLoginMigrationApi - functional programming interface
 * @export
 */
export const UserLoginMigrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserLoginMigrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerCloseMigration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginMigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerCloseMigration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginMigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Force migrate an administrator account and its school
         * @param {ForceMigrationParams} forceMigrationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerForceMigration(forceMigrationParams: ForceMigrationParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerForceMigration(forceMigrationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Currently there can only be one migration for a user. Therefore only one migration is returned.
         * @summary Get UserLoginMigrations
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerGetMigrations(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginMigrationSearchListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerGetMigrations(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Oauth2MigrationParams} oauth2MigrationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams: Oauth2MigrationParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerRestartMigration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginMigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerRestartMigration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginMigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationControllerStartMigration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginMigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationControllerStartMigration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserLoginMigrationApi - factory interface
 * @export
 */
export const UserLoginMigrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserLoginMigrationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerCloseMigration(options?: any): AxiosPromise<UserLoginMigrationResponse> {
            return localVarFp.userLoginMigrationControllerCloseMigration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} schoolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId: string, options?: any): AxiosPromise<UserLoginMigrationResponse> {
            return localVarFp.userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Force migrate an administrator account and its school
         * @param {ForceMigrationParams} forceMigrationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerForceMigration(forceMigrationParams: ForceMigrationParams, options?: any): AxiosPromise<void> {
            return localVarFp.userLoginMigrationControllerForceMigration(forceMigrationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * Currently there can only be one migration for a user. Therefore only one migration is returned.
         * @summary Get UserLoginMigrations
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerGetMigrations(userId?: string, options?: any): AxiosPromise<UserLoginMigrationSearchListResponse> {
            return localVarFp.userLoginMigrationControllerGetMigrations(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Oauth2MigrationParams} oauth2MigrationParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams: Oauth2MigrationParams, options?: any): AxiosPromise<void> {
            return localVarFp.userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerRestartMigration(options?: any): AxiosPromise<UserLoginMigrationResponse> {
            return localVarFp.userLoginMigrationControllerRestartMigration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams, options?: any): AxiosPromise<UserLoginMigrationResponse> {
            return localVarFp.userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationControllerStartMigration(options?: any): AxiosPromise<UserLoginMigrationResponse> {
            return localVarFp.userLoginMigrationControllerStartMigration(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserLoginMigrationApi - interface
 * @export
 * @interface UserLoginMigrationApi
 */
export interface UserLoginMigrationApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerCloseMigration(options?: any): AxiosPromise<UserLoginMigrationResponse>;

    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId: string, options?: any): AxiosPromise<UserLoginMigrationResponse>;

    /**
     * 
     * @summary Force migrate an administrator account and its school
     * @param {ForceMigrationParams} forceMigrationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerForceMigration(forceMigrationParams: ForceMigrationParams, options?: any): AxiosPromise<void>;

    /**
     * Currently there can only be one migration for a user. Therefore only one migration is returned.
     * @summary Get UserLoginMigrations
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerGetMigrations(userId?: string, options?: any): AxiosPromise<UserLoginMigrationSearchListResponse>;

    /**
     * 
     * @param {Oauth2MigrationParams} oauth2MigrationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams: Oauth2MigrationParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerRestartMigration(options?: any): AxiosPromise<UserLoginMigrationResponse>;

    /**
     * 
     * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams, options?: any): AxiosPromise<UserLoginMigrationResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApiInterface
     */
    userLoginMigrationControllerStartMigration(options?: any): AxiosPromise<UserLoginMigrationResponse>;

}

/**
 * UserLoginMigrationApi - object-oriented interface
 * @export
 * @class UserLoginMigrationApi
 * @extends {BaseAPI}
 */
export class UserLoginMigrationApi extends BaseAPI implements UserLoginMigrationApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerCloseMigration(options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerCloseMigration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} schoolId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId: string, options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerFindUserLoginMigrationBySchool(schoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Force migrate an administrator account and its school
     * @param {ForceMigrationParams} forceMigrationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerForceMigration(forceMigrationParams: ForceMigrationParams, options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerForceMigration(forceMigrationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Currently there can only be one migration for a user. Therefore only one migration is returned.
     * @summary Get UserLoginMigrations
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerGetMigrations(userId?: string, options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerGetMigrations(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Oauth2MigrationParams} oauth2MigrationParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams: Oauth2MigrationParams, options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerMigrateUserLogin(oauth2MigrationParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerRestartMigration(options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerRestartMigration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLoginMigrationMandatoryParams} userLoginMigrationMandatoryParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams: UserLoginMigrationMandatoryParams, options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerSetMigrationMandatory(userLoginMigrationMandatoryParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationApi
     */
    public userLoginMigrationControllerStartMigration(options?: any) {
        return UserLoginMigrationApiFp(this.configuration).userLoginMigrationControllerStartMigration(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserLoginMigrationRollbackApi - axios parameter creator
 * @export
 */
export const UserLoginMigrationRollbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Rollback a user from a user login migration
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationRollbackControllerMigrateUserLogin: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userLoginMigrationRollbackControllerMigrateUserLogin', 'userId', userId)
            const localVarPath = `/user-login-migrations/users/{userId}/rollback-migration`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserLoginMigrationRollbackApi - functional programming interface
 * @export
 */
export const UserLoginMigrationRollbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserLoginMigrationRollbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Rollback a user from a user login migration
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLoginMigrationRollbackControllerMigrateUserLogin(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLoginMigrationRollbackControllerMigrateUserLogin(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserLoginMigrationRollbackApi - factory interface
 * @export
 */
export const UserLoginMigrationRollbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserLoginMigrationRollbackApiFp(configuration)
    return {
        /**
         * 
         * @summary Rollback a user from a user login migration
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLoginMigrationRollbackControllerMigrateUserLogin(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.userLoginMigrationRollbackControllerMigrateUserLogin(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserLoginMigrationRollbackApi - interface
 * @export
 * @interface UserLoginMigrationRollbackApi
 */
export interface UserLoginMigrationRollbackApiInterface {
    /**
     * 
     * @summary Rollback a user from a user login migration
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationRollbackApiInterface
     */
    userLoginMigrationRollbackControllerMigrateUserLogin(userId: string, options?: any): AxiosPromise<void>;

}

/**
 * UserLoginMigrationRollbackApi - object-oriented interface
 * @export
 * @class UserLoginMigrationRollbackApi
 * @extends {BaseAPI}
 */
export class UserLoginMigrationRollbackApi extends BaseAPI implements UserLoginMigrationRollbackApiInterface {
    /**
     * 
     * @summary Rollback a user from a user login migration
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLoginMigrationRollbackApi
     */
    public userLoginMigrationRollbackControllerMigrateUserLogin(userId: string, options?: any) {
        return UserLoginMigrationRollbackApiFp(this.configuration).userLoginMigrationRollbackControllerMigrateUserLogin(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoConferenceApi - axios parameter creator
 * @export
 */
export const VideoConferenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to end a running video conference.
         * @summary Ends a running video conference.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerEnd: async (scope: VideoConferenceScope, scopeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceControllerEnd', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceControllerEnd', 'scopeId', scopeId)
            const localVarPath = `/videoconference2/{scope}/{scopeId}/end`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get information about a running video conference.
         * @summary Returns information about a running video conference.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerInfo: async (scope: VideoConferenceScope, scopeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceControllerInfo', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceControllerInfo', 'scopeId', scopeId)
            const localVarPath = `/videoconference2/{scope}/{scopeId}/info`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get a link to join an existing video conference. The conference must be running.
         * @summary Creates a join link for a video conference, if it has started.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerJoin: async (scope: VideoConferenceScope, scopeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceControllerJoin', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceControllerJoin', 'scopeId', scopeId)
            const localVarPath = `/videoconference2/{scope}/{scopeId}/join`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
         * @summary Creates the video conference, if it has not started yet.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerStart: async (scope: VideoConferenceScope, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceControllerStart', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceControllerStart', 'scopeId', scopeId)
            // verify required parameter 'videoConferenceCreateParams' is not null or undefined
            assertParamExists('videoConferenceControllerStart', 'videoConferenceCreateParams', videoConferenceCreateParams)
            const localVarPath = `/videoconference2/{scope}/{scopeId}/start`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoConferenceCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceDeprecatedControllerCreateAndJoin: async (scope: string, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerCreateAndJoin', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerCreateAndJoin', 'scopeId', scopeId)
            // verify required parameter 'videoConferenceCreateParams' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerCreateAndJoin', 'videoConferenceCreateParams', videoConferenceCreateParams)
            const localVarPath = `/videoconference/{scope}/{scopeId}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(videoConferenceCreateParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ends a running video conference.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceDeprecatedControllerEnd: async (scope: string, scopeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerEnd', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerEnd', 'scopeId', scopeId)
            const localVarPath = `/videoconference/{scope}/{scopeId}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about a running video conference.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceDeprecatedControllerInfo: async (scope: string, scopeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerInfo', 'scope', scope)
            // verify required parameter 'scopeId' is not null or undefined
            assertParamExists('videoConferenceDeprecatedControllerInfo', 'scopeId', scopeId)
            const localVarPath = `/videoconference/{scope}/{scopeId}`
                .replace(`{${"scope"}}`, encodeURIComponent(String(scope)))
                .replace(`{${"scopeId"}}`, encodeURIComponent(String(scopeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoConferenceApi - functional programming interface
 * @export
 */
export const VideoConferenceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideoConferenceApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to end a running video conference.
         * @summary Ends a running video conference.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceControllerEnd(scope: VideoConferenceScope, scopeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceControllerEnd(scope, scopeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to get information about a running video conference.
         * @summary Returns information about a running video conference.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceControllerInfo(scope: VideoConferenceScope, scopeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoConferenceInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceControllerInfo(scope, scopeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to get a link to join an existing video conference. The conference must be running.
         * @summary Creates a join link for a video conference, if it has started.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceControllerJoin(scope: VideoConferenceScope, scopeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VideoConferenceJoinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceControllerJoin(scope, scopeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
         * @summary Creates the video conference, if it has not started yet.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceControllerStart(scope: VideoConferenceScope, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceControllerStart(scope, scopeId, videoConferenceCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceDeprecatedControllerCreateAndJoin(scope: string, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceDeprecatedControllerCreateAndJoin(scope, scopeId, videoConferenceCreateParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Ends a running video conference.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceDeprecatedControllerEnd(scope: string, scopeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceDeprecatedControllerEnd(scope, scopeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns information about a running video conference.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async videoConferenceDeprecatedControllerInfo(scope: string, scopeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.videoConferenceDeprecatedControllerInfo(scope, scopeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VideoConferenceApi - factory interface
 * @export
 */
export const VideoConferenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideoConferenceApiFp(configuration)
    return {
        /**
         * Use this endpoint to end a running video conference.
         * @summary Ends a running video conference.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerEnd(scope: VideoConferenceScope, scopeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.videoConferenceControllerEnd(scope, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get information about a running video conference.
         * @summary Returns information about a running video conference.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerInfo(scope: VideoConferenceScope, scopeId: string, options?: any): AxiosPromise<VideoConferenceInfoResponse> {
            return localVarFp.videoConferenceControllerInfo(scope, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get a link to join an existing video conference. The conference must be running.
         * @summary Creates a join link for a video conference, if it has started.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerJoin(scope: VideoConferenceScope, scopeId: string, options?: any): AxiosPromise<VideoConferenceJoinResponse> {
            return localVarFp.videoConferenceControllerJoin(scope, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
         * @summary Creates the video conference, if it has not started yet.
         * @param {VideoConferenceScope} scope 
         * @param {string} scopeId 
         * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceControllerStart(scope: VideoConferenceScope, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any): AxiosPromise<void> {
            return localVarFp.videoConferenceControllerStart(scope, scopeId, videoConferenceCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceDeprecatedControllerCreateAndJoin(scope: string, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any): AxiosPromise<object> {
            return localVarFp.videoConferenceDeprecatedControllerCreateAndJoin(scope, scopeId, videoConferenceCreateParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ends a running video conference.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceDeprecatedControllerEnd(scope: string, scopeId: string, options?: any): AxiosPromise<object> {
            return localVarFp.videoConferenceDeprecatedControllerEnd(scope, scopeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about a running video conference.
         * @param {string} scope 
         * @param {string} scopeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoConferenceDeprecatedControllerInfo(scope: string, scopeId: string, options?: any): AxiosPromise<object> {
            return localVarFp.videoConferenceDeprecatedControllerInfo(scope, scopeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideoConferenceApi - interface
 * @export
 * @interface VideoConferenceApi
 */
export interface VideoConferenceApiInterface {
    /**
     * Use this endpoint to end a running video conference.
     * @summary Ends a running video conference.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceControllerEnd(scope: VideoConferenceScope, scopeId: string, options?: any): AxiosPromise<void>;

    /**
     * Use this endpoint to get information about a running video conference.
     * @summary Returns information about a running video conference.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceControllerInfo(scope: VideoConferenceScope, scopeId: string, options?: any): AxiosPromise<VideoConferenceInfoResponse>;

    /**
     * Use this endpoint to get a link to join an existing video conference. The conference must be running.
     * @summary Creates a join link for a video conference, if it has started.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceControllerJoin(scope: VideoConferenceScope, scopeId: string, options?: any): AxiosPromise<VideoConferenceJoinResponse>;

    /**
     * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
     * @summary Creates the video conference, if it has not started yet.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceControllerStart(scope: VideoConferenceScope, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any): AxiosPromise<void>;

    /**
     * 
     * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
     * @param {string} scope 
     * @param {string} scopeId 
     * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceDeprecatedControllerCreateAndJoin(scope: string, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Ends a running video conference.
     * @param {string} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceDeprecatedControllerEnd(scope: string, scopeId: string, options?: any): AxiosPromise<object>;

    /**
     * 
     * @summary Returns information about a running video conference.
     * @param {string} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApiInterface
     */
    videoConferenceDeprecatedControllerInfo(scope: string, scopeId: string, options?: any): AxiosPromise<object>;

}

/**
 * VideoConferenceApi - object-oriented interface
 * @export
 * @class VideoConferenceApi
 * @extends {BaseAPI}
 */
export class VideoConferenceApi extends BaseAPI implements VideoConferenceApiInterface {
    /**
     * Use this endpoint to end a running video conference.
     * @summary Ends a running video conference.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceControllerEnd(scope: VideoConferenceScope, scopeId: string, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceControllerEnd(scope, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get information about a running video conference.
     * @summary Returns information about a running video conference.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceControllerInfo(scope: VideoConferenceScope, scopeId: string, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceControllerInfo(scope, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get a link to join an existing video conference. The conference must be running.
     * @summary Creates a join link for a video conference, if it has started.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceControllerJoin(scope: VideoConferenceScope, scopeId: string, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceControllerJoin(scope, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to start a video conference. If the conference is not yet running, it will be created.
     * @summary Creates the video conference, if it has not started yet.
     * @param {VideoConferenceScope} scope 
     * @param {string} scopeId 
     * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceControllerStart(scope: VideoConferenceScope, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceControllerStart(scope, scopeId, videoConferenceCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a join link for a video conference and creates the video conference, if it has not started yet.
     * @param {string} scope 
     * @param {string} scopeId 
     * @param {VideoConferenceCreateParams} videoConferenceCreateParams 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceDeprecatedControllerCreateAndJoin(scope: string, scopeId: string, videoConferenceCreateParams: VideoConferenceCreateParams, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceDeprecatedControllerCreateAndJoin(scope, scopeId, videoConferenceCreateParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ends a running video conference.
     * @param {string} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceDeprecatedControllerEnd(scope: string, scopeId: string, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceDeprecatedControllerEnd(scope, scopeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about a running video conference.
     * @param {string} scope 
     * @param {string} scopeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoConferenceApi
     */
    public videoConferenceDeprecatedControllerInfo(scope: string, scopeId: string, options?: any) {
        return VideoConferenceApiFp(this.configuration).videoConferenceDeprecatedControllerInfo(scope, scopeId, options).then((request) => request(this.axios, this.basePath));
    }
}


