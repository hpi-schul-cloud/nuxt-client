import Vue from "vue";
//import Vuex from "vuex";
import fs from "fs";
import path from "path";
//import axios from "axios";

// ===
// Utility functions
// ===

// https://vue-test-utils.vuejs.org/
import vueTestUtils from "@vue/test-utils";
// https://lodash.com/
import _ from "lodash";
_.mixin({
	pascalCase: _.flow(
		_.camelCase,
		_.upperFirst
	),
});

// ===
// Configure Vue
// ===

// Don't warn about not using the production build of Vue, as
// we care more about the quality of errors than performance
// for tests.
Vue.config.productionTip = false;

// ===
// Register global components
// ===

const globalComponentFiles = fs
	.readdirSync(path.join(__dirname, "../../src/components/ui"))
	.filter((fileName) => /^Base[A-Z][\w]+\.vue$/.test(fileName));

for (const fileName of globalComponentFiles) {
	const componentName = _.pascalCase(
		fileName.match(/^(Base[A-Z][\w]+)\.vue$/)[1]
	);
	const componentConfig = require("../../src/components/ui/" + fileName);
	Vue.component(componentName, componentConfig.default || componentConfig);
}

// ===
// Mock window properties not handled by jsdom
// ===

Object.defineProperty(window, "localStorage", {
	value: (function() {
		let store = {};
		return {
			getItem: function(key) {
				return store[key] || null;
			},
			setItem: function(key, value) {
				store[key] = value.toString();
			},
			clear: function() {
				store = {};
			},
		};
	})(),
});

// ===
// Global helpers
// ===

// https://vue-test-utils.vuejs.org/api/#mount
global.mount = vueTestUtils.mount;

// https://vue-test-utils.vuejs.org/api/#shallowmount
global.shallowMount = vueTestUtils.shallowMount;

/*
// A special version of `shallowMount` for view components
global.shallowMountView = (Component, options = {}) => {
	return global.shallowMount(Component, {
		...options,
		stubs: {
			Layout: {
				functional: true,
				render(h, { slots }) {
					return <div>{slots().default}</div>;
				},
			},
			...(options.stubs || {}),
		},
	});
};
*/
// A helper for creating Vue component mocks
global.createComponentMocks = ({ store, router, style, mocks, stubs }) => {
	// Use a local version of Vue, to avoid polluting the global
	// Vue and thereby affecting other tests.
	// https://vue-test-utils.vuejs.org/api/#createlocalvue
	const localVue = vueTestUtils.createLocalVue();
	const returnOptions = { localVue };

	// https://vue-test-utils.vuejs.org/api/options.html#stubs
	returnOptions.stubs = stubs || {};
	// https://vue-test-utils.vuejs.org/api/options.html#mocks
	returnOptions.mocks = mocks || {};
	/*
	// Converts a `store` option shaped like:
	//
	// store: {
	//   someModuleName: {
	//     state: { ... },
	//     getters: { ... },
	//     actions: { ... },
	//   },
	//   anotherModuleName: {
	//     getters: { ... },
	//   },
	// },
	//
	// to a store instance, with each module namespaced by
	// default, just like in our app.
	if (store) {
		localVue.use(Vuex);
		returnOptions.store = new Vuex.Store({
			modules: Object.keys(store)
				.map((moduleName) => {
					const storeModule = store[moduleName];
					return {
						[moduleName]: {
							state: storeModule.state || {},
							getters: storeModule.getters || {},
							actions: storeModule.actions || {},
							namespaced:
								typeof storeModule.namespaced === "undefined"
									? true
									: storeModule.namespaced,
						},
					};
				})
				.reduce((moduleA, moduleB) => Object.assign({}, moduleA, moduleB), {}),
		});
	}
	*/
	// If using `router: true`, we'll automatically stub out
	// components from Vue Router.
	if (router) {
		returnOptions.stubs["nuxt-link"] = true;
		returnOptions.stubs["nuxt"] = true;
	}
	/*
	// If a `style` object is provided, mock some styles.
	if (style) {
		returnOptions.mocks.$style = style;
	}*/

	return returnOptions;
};

/*
global.createModuleStore = (vuexModule, options = {}) => {
	vueTestUtils.createLocalVue().use(Vuex);
	const store = new Vuex.Store({
		..._.cloneDeep(vuexModule),
		modules: {
			auth: {
				namespaced: true,
				state: {
					currentUser: options.currentUser,
				},
			},
		},
	});
	axios.defaults.headers.common.Authorization = options.currentUser
		? options.currentUser.token
		: "";
	if (vuexModule.actions.init) {
		store.dispatch("init");
	}
	return store;
};
*/
